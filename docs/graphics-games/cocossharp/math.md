---
title: 2D математические операции с CocosSharp
description: В настоящем руководстве описывается 2D математических операций для разработки игр. Он использует CocosSharp показано, как выполнять типичные задачи разработки игр и объясняет математически этих задач.
ms.prod: xamarin
ms.assetid: 5C241AB4-F97E-4B61-B93C-F5D307BCD517
author: charlespetzold
ms.author: chape
ms.date: 03/27/2017
ms.openlocfilehash: 13279df69b7a22117c10d74f1a15c082aff13264
ms.sourcegitcommit: 0a72c7dea020b965378b6314f558bf5360dbd066
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/09/2018
---
# <a name="2d-math-with-cocossharp"></a>2D математические операции с CocosSharp

_В настоящем руководстве описывается 2D математических операций для разработки игр. Он использует CocosSharp показано, как выполнять типичные задачи разработки игр и объясняет математически этих задач._

Для размещения и перемещения объектов с кодом является основной частью разработки игр всех размеров. Размещение и перемещение требуют использования математических операций, требуется ли для игр перемещения объекта вдоль прямой или использование тригонометрических для поворота. В этом документе рассматривается в следующих разделах:

 - Скорость
 - Ускорение
 - Поворот CocosSharp объектов
 - Использование с скорость вращения

Разработчики, не имеющие надежный математические фона или кто долго забыли эти разделы в школе, не нужно беспокоиться — в этом документе будет разбить основные понятия в виде кратких размера фрагментов и сопровождающий теоретической объяснений с практические примеры. Иными словами, в этой статье будет ответить на вопрос голосованием математические студента: «При будет фактически нужно использовать этот stuff?»


## <a name="requirements"></a>Требования

Несмотря на то, что в этом документе рассматриваются главным образом от математических части CocosSharp, примерах кода предполагается работать с объектами, наследование формы `CCNode`. Кроме того, с момента `CCNode` не включает значения скорости и ускорения, в коде предполагается, работе с сущностями, которые предоставляют значения, такие как VelocityX, VelocityY, AccelerationX и AccelerationY. Дополнительные сведения о сущностях см на нашем пошаговом руководстве [сущностей в CocosSharp](~/graphics-games/cocossharp/entities.md).


## <a name="velocity"></a>Скорость

Игры разработчики используют термин *скорости* для описания того, как объект больше не — специально быстродействия нечто и движения направление что он больше не. 

Скорости определяется с помощью два вида единиц измерения: единицы позиции и единицу времени. Например скоростью автомобиля считается мили в час или километры в час. Перемещает часто используется точках в секунду для определения быстродействия объекта разработчиков игр. Например маркер может перемещать скоростью 300 пикселей в секунду. То есть если маркера перемещения на 300 пикселей в секунду, затем его будет были перемещены 600 единиц в две секунды, а 900 единицы в три секунды и т. д. Как правило, значение скорости *добавляет* позиции объекта (как мы будем см. ниже).

Несмотря на то, что мы использовали скорость для объяснения единиц скорости, скорость термин обычно ссылается на значение, независимо от направления, пока термин скорость определяет скорость и направление. Таким образом назначение скорости маркера (при условии, что маркер — это класс, который включает необходимые свойства) может выглядеть следующим образом:


```csharp
// This bullet is not moving horizontally, so set VelocityX to 0:
bulletInstance.VelocityX = 0;
// Positive Y is "up" so move the bullet up 300 units per second:
bulletInstance.VelocityY = 300;
```


### <a name="implementing-velocity"></a>Реализация скорости

CocosSharp не реализует скорости, поэтому объекты, подлежащие перемещения должен реализовывать свою собственную логику перемещения. Начинающим разработчикам игры, реализация скорости часто допущена ошибка создания их скорости зависит от частоты кадров. То есть следующие *неправильная реализация* будет казаться, что обеспечивают правильные результаты, но будет основываться на частота кадров игры в:

```csharp
// VelocityX and VelocityY will be added every time this code executes
this.PositionX += this.VelocityX;
this.PositionY += this.VelocityY;
```

Если игра работает на увеличение частоты кадров (например, 60 кадров в секунду, вместо 30 кадров в секунду), объект будет отображаться для перемещения быстрее, чем если работает медленнее частотой кадров. Аналогичным образом Если игры не удалось обработать кадры в качестве высокое частоту кадров (который может быть вызвано фоновые процессы с помощью ресурсов устройства), игра будет отображаться замедляется.

С учетом этого скорости часто реализуется с помощью значения времени. Например если `seconds` переменная представляет число (или дробной части) секунд с момента последнего скорости времени была применена, то следующий код приведет к необходимости перемещения согласованных независимо от частоты кадров объекта:

```csharp
// VelocityX and VelocityY will be added every time this code executes
this.PositionX += this.VelocityX * seconds;
this.PositionY += this.VelocityY * seconds;
```

Рассмотрим игру, работающей с меньшей скоростью кадра будет обновлять часто положение меньше его объектов. Таким образом каждое обновление приведет к дальнейшей, чем требовалось бы, если игры обновляли чаще перемещение объектов. `seconds` Значение учетные записи для этого, сообщая о том, сколько времени прошло с момента последнего обновления.

Пример добавления время на перемещение см. в разделе [Этот рецепт, охватывающие времени на основе перемещения](https://developer.xamarin.com/recipes/cross-platform/game_development/time_based_movement/).


### <a name="calculating-positions-using-velocity"></a>Вычисление должностей с использованием скорости

Скорости можно использовать для создания прогнозов о которой объект будет после некоторое количество времени или для настройки поведения объектов без необходимости запустить игру. Например разработчика, который реализует перемещение срабатывание маркера необходимо задать маркер скорости после ее создания. Размер экрана можно использовать, чтобы служить основой для задания скорости. То есть если разработчику известно, что маркера следует переместить высоту экрана за 2 секунды, а затем скорости должно быть равно высоте экрана, деленному на 2. Если экрана 800 пикселей, затем скорость маркера устанавливается до 400 (который 800/2).

Аналогичным образом логику игры может потребоваться рассчитать, сколько времени объект перейдете к назначению, учитывая его скорость. Это может рассчитывается делением расстояние по скорости переносной объекта. В следующем примере показано присвоение текст метки, отображающий продолжительность пока ракетным не достигнет цели:


```csharp
// We'll assume only the X axis for this example
float distanceX = target.PositionX - missile.PositionX;

float secondsToReachTarget = distanceX / missile.VelocityX;

label.Text = secondsToReachTarget + " seconds to reach target"; 
```


## <a name="acceleration"></a>Ускорение

*Ускорение* — общие понятие в разработки игр и она имеет много общего с скорости. Ускорение содержит количественные ли объект ускорение или замедление работы (как значение скорости изменяется со временем). Ускорение *добавляет* скорости, так же, как добавляет скорости для размещения. Общие приложения ускорения включают центра тяжести, автомобиль, ускорение и места отгрузки, срабатывание его thrusters. 

Аналогичный скорости, ускорение, определен в позиции и единицу времени; Тем не менее, ускорение в единицу времени называется *квадрат* блок, который соответствует определению ускорение математически. То есть игры ускорение часто измеряется в *пикселей в секунду в квадрате*.

Если у объекта имеется ускорение X 10 единиц за секунду в квадрате, затем это означает, что повышает его скорость, 10 каждую секунду. Если запуск из начнут, после одной секунды сделает его перемещения на 10 единиц в секунду, после двух секунд 20 единиц на во-вторых, и т. д.

Ускорение в двух измерений необходимо компоненту X и Y, поэтому может быть присвоено следующим образом:


```csharp
// No horizontal acceleration:
icicle.AccelerationX = 0;
// Simulate gravity with Y acceleration. Negative Y is down, so assign a negative value:
icicle.AccelerationY = -50; 
```


### <a name="acceleration-vs-deceleration"></a>Ускорение или замедление

Несмотря на то, что иногда ускорение и замедление отличаются в каждый день речи, нет технических разницы между ними. Центра тяжести является force, что приводит к ускорение. Если объект создается вверх затем тяжести замедлится его (замедление), но после объекта остановлена экстремума и попадающие в направлении центра тяжести затем тяжести ускоряет его (ускорение). Как показано ниже, приложение ускорение одинаково независимо от применения в одном направление или обратное направление перемещения. 


### <a name="implementing-acceleration"></a>Реализация ускорение

Ускорение, аналогичный скорости при реализации — не реализуется автоматически CocosSharp и ускорения на основе времени является необходимого внедрения (в отличие от ускорение, основанных на кадре). Поэтому реализация простой ускорения (а также скорости) может иметь вид:

```csharp
this.VelocityX += this.AccelerationX * seconds;
this.VelocityY += this.AccelerationY * seconds;
this.PositionX += this.VelocityX * seconds;
this.PositionY += this.VelocityY * seconds;
```

Приведенный выше код является то, что называется *линейной аппроксимации* для ускорения реализации. По сути он реализует ускорение достаточно тесная степень точности, но не вполне точной модели ускорения. Она включена выше, чтобы помочь понять концепцию реализации ускорение.

Следующая реализация является приложением математически точны ускорение и скорости:


```csharp
float halfSecondsSquared = (seconds * seconds) / 2.0f;

this.PositionX += 
    this.Velocity.X * seconds + this.AccelerationX * halfSecondsSquared;
this.PositionY += 
    this.Velocity.Y * seconds + this.AccelerationY * halfSecondsSquared;

this.VelocityX += this.AccelerationX * seconds;
this.VelocityY += this.AccelerationY * seconds; 
```

В приведенном выше коде Очевидное различие заключается в `halfSecondsSquared` переменную и их использование для применения ускорение для размещения. Математические причина выходит за рамки данного руководства, но разработчиков, заинтересованных в математически это можно найти дополнительные сведения в [об интеграции ускорение данного обсуждения.](http://www.cliffsnotes.com/math/calculus/calculus/integration/distance-velocity-and-acceleration)

Практические влияние `halfSecondSquare` — что ускорение будет вести себя математически точно и предсказуемое независимо от частоты кадров. Линейной аппроксимации ускорения зависит от частоты кадров — чем меньше значение частоты кадров опускается становится менее точным приближением. С помощью `halfSecondsSquared` гарантирует, что код будет функционировать так же, независимо от частоты кадров.


## <a name="angles-and-rotation"></a>Углы и поворота

Визуальные объекты, такие как `CCSprite` поддерживают поворот через `Rotation` переменной. Это может назначаться значение для задания его поворота в градусах. Например, следующий код демонстрируется поворот `CCSprite` экземпляр:


```csharp
CCSprite unrotatedSprite = new CCSprite("star.png");
unrotatedSprite.IsAntialiased = false;
unrotatedSprite.PositionX = 100;
unrotatedSprite.PositionY = 100;
this.AddChild (unrotatedSprite);

CCSprite rotatedSprite = new CCSprite("star.png");
rotatedSprite.IsAntialiased = false;
// This sprite is moved to the right so it doesn’t overlap the first
rotatedSprite.PositionX = 130;
rotatedSprite.PositionY = 100;
rotatedSprite.Rotation = 45;
this.AddChild (rotatedSprite); 
```

Эти действия произведут следующий результат:

![](math-images/image1.png "Результатом на этом снимке экрана")

Обратите внимание, что вращения на 45 градусов по часовой стрелке (которые Исторически сложилось противоположен как математически применяется поворот):

![](math-images/image2.png "Обратите внимание, что поворот по часовой стрелке на 45 градусов Исторически сложилось так это противоположность как математически применяется поворот")

В целом поворота CocosSharp и регулярное математике можно представить следующим образом:

![](math-images/image3.png "В целом поворота CocosSharp и регулярное математике можно представить следующим образом")

![](math-images/image4.png "В целом поворота CocosSharp и регулярное математике можно представить следующим образом")

Это различие важно из-за `System.Math` класс использует поворот против часовой стрелки, поэтому разработчики, знакомые с этим классом необходимо обратить углы при работе с `CCNode` экземпляров.

Следует отметить, что выше схемы отображать поворота в градусах; Тем не менее некоторые математические функции (такие как функции в `System.Math` пространство имен) ожидается, что и возвращаемых значений в *радиан* вместо градусов. Мы рассмотрим преобразование между типами два модульных позднее в этом руководстве.


### <a name="rotating-to-face-a-direction"></a>Поворот на направление

Как показано выше, `CCSprite` повернутый с использованием `Rotation` свойство. `Rotation` Предоставляется свойство `CCNode` (базовый класс для `CCSprite`), это означает, что поворот может применяться к сущности, которые наследуют от `CCNode` также. 

Некоторые игры требуют объекты должны быть повернуты, часто сталкиваются целевого объекта. Примеры включают enemy управляемый компьютером, устранении неполадок в целевой проигрыватель или места отгрузки, полета по направлению к точке, где пользователь является касаясь экрана. Тем не менее значение поворота должен сначала вычислить на основе расположение заменяемым сущности и сталкиваются целевого объекта.

Этот процесс требует нескольких этапов:

 - Определение *смещение* целевого объекта. Смещение ссылается X и Y расстояние между поворота сущности и целевой сущности.
 - Вычисление угол от смещения, используя функцию тригонометрические арктангенс (подробно рассматривается ниже).
 - Настройка для разницы между 0 градусов, указывающим вправо, а также направление, в котором указывает поворота сущности при отмене повернуто.
 - Настройка разницу математических поворот (против часовой стрелки) и CocosSharp поворота (по часовой стрелке).

Следующая функция (предполагается, что будут записываться в сущности) Поворачивает объект на целевой объект:


```csharp
// This function assumes that it is contained in a CCNode-inheriting object
public void FacePoint(float targetX, float targetY)
{
    // Calculate the offset - the target's position relative to "this"
    float xOffset = targetX - this.PositionX;
    float yOffset = targetY - this.PositionY;

    // Make sure the target isn't the same point as "this". If so,
    // then rotation cannot be calculated.
    if (targetX != this.PositionX || targetY != this.Position.Y)
    {

        // Call Atan2 to get the radians representing the angle from 
        // "this" to the target
        float radiansToTarget = (float)System.Math.Atan2 (yOffset, xOffset);

        // Since CCNode uses degrees for its rotation, we need to convert
        // from radians
        float degreesToTarget = CCMathHelper.ToDegrees (radiansToTarget);

        // The direction that the entity faces when unrotated. In this case
        // the entity is facing "up", which is 90 degrees 
        const float forwardAngle = 90;

        // Adjust the angle we want to rotate by subtracting the
        // forward angle.
        float adjustedForDirecitonFacing = degreesToTarget - forwardAngle;

        // Invert the angle since CocosSharp uses clockwise rotation
        float cocosSharpAngle = adjustedForDirecitonFacing * -1;

        // Finally assign the rotation
        this.Rotation = rotation = cocosSharpAngle;
    }
} 
```

Приведенный выше код может использоваться для поворота сущности, чтобы она была направлена в точке, где пользователь касается экрана, как показано ниже:


```csharp
private void HandleInput(System.Collections.Generic.List<CCTouch> touches, CCEvent touchEvent)
{
    if(touches.Count > 0)
    {
        CCTouch firstTouch = touches[0];
        FacePoint (firstTouch.Location.X, firstTouch.Location.Y);
    }
} 
```

Этот код вызывает следующее поведение:

![](math-images/image5.gif "Этот код вызывает это поведение")

#### <a name="using-atan2-to-convert-offsets-to-angles"></a>С помощью Atan2 для преобразования смещений в углы

`System.Math.Atan2` можно использовать для преобразования смещение угол. Имя функции `Atan2` поступают из арктангенс тригонометрические функции. Суффикс «2» отличающее эту функцию из стандартного `Atan` функции, которая строго соответствует математических поведение арктангенс числа. Арктангенс — это функция, которая возвращает значение в диапазоне от -90 и + 90 градусов (или его эквивалент в радианах). Многие приложения, включая игры на компьютере, часто требуют полного 360 градусов значений, поэтому `Math` класс включает `Atan2` для удовлетворения этой потребности.

Обратите внимание, что приведенный выше код передает параметр Y во-первых, затем параметр X, при вызове `Atan2` метода. Это вперед от обычного X, Y упорядочение положение координаты. Для получения дополнительной информации [разделе документы Atan2](https://msdn.microsoft.com/library/system.math.atan2(v=vs.110).aspx).

Также стоит отметить, что возвращаемое значение из `Atan2` — в радианах, который является другой записи используются для измерения углов. В этом руководстве не подробно рассмотрены радиан, но следует помнить, все тригонометрические функции в `System.Math` радиан с использованием пространства имен, поэтому все значения должны быть преобразованы в градусах перед использованием CocosSharp объектов. Можно найти дополнительные сведения о радианах [в радианах страница](http://en.wikipedia.org/wiki/Radian).

#### <a name="forward-angle"></a>Прямой угол

Один раз `FacePoint` метод преобразует угол в радианах, он определяет `forwardAngle` значение. Это значение представляет угол, в которой обращен к сущности, если его значение поворота значение 0. В этом примере предполагается, что сущность испытывает снизу вверх, при использовании математических поворота (в отличие от поворота CocosSharp), который является 90 градусов. Мы используем математических поворот здесь так, как мы еще не инвертированный поворота для CocosSharp.

В следующем примере показаны какие сущности с `forwardAngle` 90 градусов может выглядеть:

![](math-images/image6.png "Показано, как может выглядеть сущность с forwardAngle 90 градусов")


### <a name="angled-velocity"></a>Угловые скорости

Пока мы рассмотрели, как преобразовать смещения в угол. В этом разделе идет другим способом — получает значение угла и преобразует его в X и Y значения. Распространенные примеры включают перемещение в направлении, лицевой или места отгрузки, устранении неполадок маркера, который перемещается в направлении, который испытывает доставки автомобиля. 

По существу можно вычислить скорости, сначала определить нужный скорости при отмене поворачивать, а затем вращение на угол, обращен к сущности, скорости. Чтобы объяснить эту концепцию (и ускорение) могут быть визуализированы как двумерные *вектор* (который обычно отображенный в виде стрелки). Вектор, значения скорости с X = 100, а Y = 0 можно представить следующим образом:

![](math-images/image7.png "Вектор, значения скорости с X = 100, а Y = 0 можно представить следующим образом")

В результате новый скорости могут быть повернуты данного вектора. Например Смена вектор на 45 градусов (с помощью поворот по часовой стрелке) произведут следующий результат:

![](math-images/image8.png "Поворот на 45 градусов с помощью результатов поворот по часовой стрелке в этом векторе")

К счастью скорости, ускорение и даже положение можно все поворачивать с тем же кодом независимо от того, как применяются значения. Следующая функция общего назначения используется для поворота вектор по значению CocosSharp поворота:


```csharp
// Rotates the argument vector by degrees specified by
// cocosSharpDegrees. In other words, the rotation
// value is expected to be clockwise.
// The vector parameter is modified, so it is both an in and out value
void RotateVector(ref CCVector2 vector, float cocosSharpDegrees)
{
    // Invert the rotation to get degrees as is normally
    // used in math (counterclockwise)
    float mathDegrees = -cocosSharpDegrees;

    // Convert the degrees to radians, as the System.Math
    // object expects arguments in radians
    float radians = CCMathHelper.ToRadians (mathDegrees);

    // Calculate the "up" and "right" vectors. This is essentially
    // a 2x2 matrix that we'll use to rotate the vector
    float xAxisXComponent = (float)System.Math.Cos (radians);
    float xAxisYComponent = (float)System.Math.Sin (radians);
    float yAxisXComponent = (float)System.Math.Cos (radians + CCMathHelper.Pi / 2.0f);
    float yAxisYComponent = (float)System.Math.Sin (radians + CCMathHelper.Pi / 2.0f);

    // Store the original vector values which will be used
    // below to perform the final operation of rotation.
    float originalX = vector.X;
    float originalY = vector.Y;

    // Use the axis values calculated above (the matrix values)
    // to rotate and assign the vector.
    vector.X = originalX * xAxisXComponent + originalY * yAxisXComponent;
    vector.Y = originalX * xAxisYComponent + originalY * yAxisYComponent;
} 
```

Более полное представление о `RotateVector` метода необходимо ознакомиться с косинус и синус тригонометрические функции, а также некоторые линейной алгебры, который выходит за рамки данной статьи. Однако после реализации `RotateVector` метод может использоваться для любого объекта vector, включая вектора скорости поворота. Например, следующий код может активироваться маркера в направлении, указанным `rotation` значение:


```csharp
// Create a Bullet instance
Bullet newBullet = new Bullet();

// Define the velocity of the bullet when 
// rotation is 0
CCVector2 velocity = new CCVector2 (0, 100);

// Modify the velocity according to rotation
RotateVector (ref velocity, rotation);

// Assign the newBullet's velocity using the
// rotated vector
newBullet.VelocityX = velocity.X;
newBullet.VelocityY = velocity.Y;

// Set the bullet's rotation so it faces
// the direction that it's flying
newBullet.Rotation = rotation; 
```

Этот код может привести к примерно так:

![](math-images/image9.png "Этот код может привести к нечто похожее на следующий снимок экрана")


## <a name="summary"></a>Сводка

В этом руководстве рассматриваются основные понятия математических в 2D разработки игр. Показано, как назначать и реализовать и ускорение и описывается, как поворачивать объекты и векторов для перемещения в любом направлении.
