---
title: Шаблон Model-View-ViewModel
description: В этой главе описывается, как eShopOnContainers мобильное приложение использует шаблон MVVM для разделения бизнеса и презентации логику приложения из его пользовательский интерфейс без ошибок.
ms.prod: xamarin
ms.assetid: dd8c1813-df44-4947-bcee-1a1ff2334b87
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: fe2cace6a0fc3a1d901f55556eed09380f8f2006
ms.sourcegitcommit: 66682dd8e93c0e4f5dee69f32b5fc5a96443e307
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2018
ms.locfileid: "35245436"
---
# <a name="the-model-view-viewmodel-pattern"></a>Шаблон Model-View-ViewModel

Взаимодействие разработчика с Xamarin.Forms обычно включает создание пользовательского интерфейса в XAML и добавления кода, работающая в пользовательском интерфейсе. Приложения будут изменены и увеличиваются размер и область, сложное обслуживание проблемы могут возникнуть. Эти проблемы могут быть тесную связь между элементов управления пользовательского интерфейса и бизнес-логика, что приводит к росту затрат на реализацию изменения пользовательского интерфейса и сложность модульное тестирование такого кода.

Шаблон Model-View-ViewModel (MVVM) помогает полностью разделения бизнеса и презентации логику приложения из его пользовательский интерфейс (UI). Поддержание четкое разделение между логикой приложений и пользовательский Интерфейс позволяет устранить множество проблем разработки и облегчает тестирование приложения, обслуживать и развития. Он может также значительно повысить возможности повторного использования кода и позволяет разработчикам и конструктора пользовательского интерфейса, которые более тесно сотрудничать при разработке своих соответствующим частям приложения.

## <a name="the-mvvm-pattern"></a>Шаблон MVVM

В шаблоне MVVM существует три основных компонента: модель, представление и модели представления. Каждый используется в различных целях. Рис. 2-1 показаны связи между трех компонентов.

![](mvvm-images/mvvm.png "Шаблон MVVM")

**Рис. 2-1**: шаблона MVVM

Помимо понимания обязанностей каждого компонента, также важно понимать, как взаимодействуют друг с другом. На высоком уровне, представление «знает об» модели представления и модель представления «знает о» модели, но модели не знает о модели представления, и модели представления не знает о представлении. Таким образом модель представления изолирует представление из модели и позволяет модели развиваться, независимо от представления.

Преимущества использования шаблона MVVM выглядят следующим образом:

-   Если имеется существующая реализация модели, инкапсулирующий существующего бизнес-логики, может быть трудно или рискованно, чтобы изменить его. В этом случае модель представления выступает в качестве адаптера для классов модели и позволяет избежать внесения любых основных изменений кода модели.
-   Разработчики могут создавать модульные тесты для модели представления и модели без использования представления. Модульные тесты для модели представления можно использовать только те же функциональные возможности, используемый в представлении.
-   Пользовательский Интерфейс приложения можно перестроить таким образом, без изменения кода, при условии, что представление реализуется полностью в XAML. Таким образом новая версия представления должны работать с существующие модели представления.
-   Проектировщикам и разработчикам могут работать независимо друг от друга и параллельно их компонентов во время разработки. Конструкторы можно сосредоточиться на представлении, во время работы разработчиков представление модели и модели компонентов.

Эффективное использование MVVM ключ находится в основные сведения об код приложения в правильный классы и понять, как взаимодействуют классы. В следующих разделах рассматриваются обязанности каждого из классов в шаблоне MVVM.

### <a name="view"></a>Просмотр

Представление отвечает за определение структуры, макет и внешний вид пользователь видит на экране. В идеальном случае каждое представление определяется на языке XAML, с ограниченной фоновым кодом, содержащий бизнес-логики. Однако в некоторых случаях кода может содержать логика пользовательского интерфейса, который реализует поведение visual, которые трудно выразить в XAML, таких как анимации.

В приложении Xamarin.Forms представление — обычно [ `Page` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Page/)-производным или [ `ContentView` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ContentView/)-производного класса. Тем не менее представления могут также быть представлен шаблон данных, который определяет элементы пользовательского интерфейса для визуального представления объекта при его отображении. Шаблон данных как представление не имеет любого кода и предназначен для привязки к определенному представлению типу модели.

> [!TIP]
> Избегайте Включение и отключение элементов пользовательского интерфейса в кода. Убедитесь, что ответственность за определение состояния логического изменения, которые влияют на некоторые аспекты отображения представления, например, доступен ли команды или указывает на то, что операция ожидает Просмотр моделей. Таким образом Включение и отключение элементов пользовательского интерфейса с помощью привязки, чтобы просмотреть свойства модели, а не Включение и отключение их в коде.

Существует несколько вариантов для выполнения кода на модели представления в ответ на взаимодействие с представлением, такому как нажатие кнопки или Выбор элементов. Если элемент управления поддерживает команды, элемент управления `Command` свойство может быть привязкой к данным для `ICommand` свойства в модели представления. При вызове команды элемента управления, будет выполняться код в модели представления. Помимо команд поведения можно подключить к объекту в представлении и может прослушивать события или вызывать команду. В ответ, могут вызывать поведение `ICommand` в модели представления или в методе на модели представления.

### <a name="viewmodel"></a>ViewModel

Модель представления реализует свойства и команд, для которых представление может связывания данных и уведомляет представление изменения состояния через события уведомления об изменении. Свойства и команды, которые предоставляет модели представления в определении функциональности предлагаемый пользовательского интерфейса, но представление определяет, как эти функциональные возможности для отображения.

> [!TIP]
> Пользовательский Интерфейс продолжал отвечать на запросы с асинхронными операциями. Мобильные приложения следует хранить в поток пользовательского интерфейса, разблокирован для повышения производительности впечатление пользователя. В модели представления использовать асинхронные методы для операций ввода-вывода и вызывать события, чтобы асинхронно уведомить представления об изменении свойств.

Модель представления также отвечает за координацию представления взаимодействия с любыми классами модели, которые необходимы. Обычно является один ко многим связь между классы модели и модели представления. Модель представления можно предоставлять классы модели непосредственно к представлению, чтобы элементы управления в представлении выполнить привязку данных непосредственно к ним. В этом случае классы модели необходимо предназначен для поддержки привязки данных и события уведомления об изменении.

Каждая модель представлений содержит данные из модели в форме, которую можно легко использовать представление. Для этого представления модели иногда выполняет преобразования данных. Установив это преобразование данных в модель представления имеет смысл, поскольку он предоставляет свойства, которые можно привязать представление. Например модель представления может объединить значения из двух свойств, чтобы упростить для отображения в представлении.

> [!TIP]
> Централизовать преобразования данных в слое преобразования. Можно также использовать преобразователь как уровень преобразования отдельных данных, который располагается между модели представления и представления. Это может быть необходимо, например, когда требуется специальное форматирование, которое не предоставляет модель представления данных.

Чтобы модель представлений для участия в двухстороннюю привязку данных с помощью представления, необходимо изменить его свойства `PropertyChanged` событий. Просмотр моделей удовлетворяют этим требованиям, реализовав `INotifyPropertyChanged` интерфейс и вызов `PropertyChanged` событие при изменении свойства.

Для коллекций, используется понятное представление `ObservableCollection<T>` предоставляется. Эта коллекция реализует коллекции изменен уведомление, что разработчика от необходимости реализовывать `INotifyCollectionChanged` интерфейс с коллекциями.

### <a name="model"></a>Модель

Классы модели являются невизуальных классов, инкапсулирующих данные приложения. Таким образом модель может рассматриваться как модели домена приложения, которая обычно содержит модель данных вместе с бизнеса и проверка логики. Объекты модели примеры объекты передачи данных (DTO), старые объекты CLR (POCO) и создаваемый сущности и прокси-объекты.

Классы модели обычно используются в сочетании с служб или репозитории, которые инкапсулируют доступ к данным и кэширование.

## <a name="connecting-view-models-to-views"></a>Подключение к представлениям Просмотр моделей

Просмотр моделей может подключаться к представлениям с помощью Xamarin.Forms возможности привязки данных. Существует множество подходов, которые могут использоваться для создания представления и Просмотр моделей и связать их во время выполнения. Эти подходы делятся на две категории, известные как первый создание представлений и Создание первой модели представлений. Выбор между первой создание представлений и просматривать композиции первой модели является проблемой, предпочтения и сложности. Тем не менее все эти подходы совместное использование одной целью, предназначенной для представления для получения представления модели, назначить его свойству BindingContext.

С представлением Первый композиции приложения по существу состоит из представления, которые подключаются к модели представления, для которых они зависят. Основное преимущество данного подхода является, чтобы он мог его просто создать слабо связанных модульного тестирования приложений, так как представление модели имеют зависимость от представления, сами. Также можно легко понять структуру приложения, после ее визуальную структуру, вместо того, чтобы отслеживать выполнение кода, чтобы понять, как создаются и связанных классов. Кроме того представление первого построения выравнивает Xamarin.Forms навигации система, отвечает за создание страниц, когда происходит переход, благодаря чему состав первой модели представления сложных и невыровненных с платформой.

С представлением композиции первой модели приложения по существу состоит из моделей представление со службой, отвечает за поиск представление модели представления. Создание первой модели представлений является более естественным некоторым разработчикам, с момента создания представления может быть абстрагироваться, позволяя им сосредоточиться на структуре логической без пользовательского интерфейса приложения. Кроме того она позволяет Просмотр моделей с другими моделями представления. Тем не менее часто оказывается сложной и может стать трудными для понимания, как различные части приложения создаются и связанные.

> [!TIP]
> Следите за независимых Просмотр моделей и представления. Привязка представлений для свойства источника данных должна быть представления участника зависимость от его соответствующей модели представления. В частности, не ссылку на представление типов, таких как [ `Button` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Button/) и [ `ListView` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ListView/), из представления модели. Перечисленные здесь описаны принципы, Просмотр моделей можно протестировать в изоляции, тем самым уменьшая вероятность дефектов, ограничивая область.

В следующих разделах рассматриваются основных подхода к соединению Просмотр моделей для представления.

### <a name="creating-a-view-model-declaratively"></a>Декларативное создание модели представления

Самым простым подходом является представления для декларативного создания экземпляра его соответствующей модели представления в XAML. При создании представления будет создан и соответствующий объект модели представления. Этот подход демонстрируется в следующем примере кода:

```xaml
<ContentPage ... xmlns:local="clr-namespace:eShop">  
    <ContentPage.BindingContext>  
        <local:LoginViewModel />  
    </ContentPage.BindingContext>  
    ...  
</ContentPage>
```

Когда [ `ContentPage` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ContentPage/) создается экземпляр `LoginViewModel` автоматически создается и задать в качестве представления [ `BindingContext` ](https://developer.xamarin.com/api/property/Xamarin.Forms.BindableObject.BindingContext/).

Это декларативного построения и назначение модели представления в представлении имеет то преимущество, это простой, но недостаток, что требуется конструктор по умолчанию (без параметров) в модели представления.

### <a name="creating-a-view-model-programmatically"></a>Создание модели представления программным способом

Представление может включать код в файле кода, который приводит к модели представления, назначаемый его [ `BindingContext` ](https://developer.xamarin.com/api/property/Xamarin.Forms.BindableObject.BindingContext/) свойство. Это часто выполняется в представление конструктора, как показано в следующем примере кода:

```csharp
public LoginView()  
{  
    InitializeComponent();  
    BindingContext = new LoginViewModel(navigationService);  
}
```

Программное создание и назначение модели представления в представлении кода имеет то преимущество, что это просто. Основной недостаток этого подхода то, что представление должно для предоставления модели представления какие-либо зависимости. Использование контейнера внедрения зависимостей может помочь для поддержания свободные взаимозависимость между представлением и модели представления. Дополнительные сведения см. в разделе [внедрения зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md).

### <a name="creating-a-view-defined-as-a-data-template"></a>Создание представления, определенного как шаблон данных

Представление можно определить в качестве шаблона данных и связанных с типом модели, представления. Шаблоны данных можно определить как ресурсы, или они могут быть определен как встроенный в элементе управления, который будет отображать модели представления. Содержимое элемента управления экземпляр модели представления и шаблон данных используется для визуального представления. Этот метод является примером ситуации, в котором модель представления создается во-первых, затем создается представление.

<a name="automatically_creating_a_view_model_with_a_view_model_locator" />

### <a name="automatically-creating-a-view-model-with-a-view-model-locator"></a>Автоматическое создание модели представления с локатора представление модели

Указатель модели представления является пользовательский класс, который управляет создание экземпляров Просмотр моделей и их связь с представлениями. В мобильном приложении eShopOnContainers `ViewModelLocator` класс имеет вложенное свойство `AutoWireViewModel`, который позволяет связать Просмотр моделей с представлениями. В представлении XAML это вложенное свойство имеет значение true, чтобы указать, что модели представления должен быть автоматически подключен к представлению, как показано в следующем примере кода:

```xaml
viewModelBase:ViewModelLocator.AutoWireViewModel="true"
```

`AutoWireViewModel` Свойство может быть привязано устанавливается равным false, а также при изменении значения `OnAutoWireViewModelChanged` вызывается обработчик события. Этот метод разрешает модель представлений для представления. В следующем примере кода показано, как это сделать:

```csharp
private static void OnAutoWireViewModelChanged(BindableObject bindable, object oldValue, object newValue)  
{  
    var view = bindable as Element;  
    if (view == null)  
    {  
        return;  
    }  

    var viewType = view.GetType();  
    var viewName = viewType.FullName.Replace(".Views.", ".ViewModels.");  
    var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName;  
    var viewModelName = string.Format(  
        CultureInfo.InvariantCulture, "{0}Model, {1}", viewName, viewAssemblyName);  

    var viewModelType = Type.GetType(viewModelName);  
    if (viewModelType == null)  
    {  
        return;  
    }  
    var viewModel = _container.Resolve(viewModelType);  
    view.BindingContext = viewModel;  
}
```

`OnAutoWireViewModelChanged` Метод пытается разрешить просмотр модели, используя подход на основе соглашения. Это соглашение предполагает, что:

-   Просмотр моделей находятся в одной сборке с типы представлений.
-   Представления находятся в. Дочернее пространство имен представления.
-   Просмотр моделей находятся в. Дочернее пространство имен ViewModels.
-   Просмотр модели имена соответствуют имена представлений и заканчиваться «ViewModel».

Наконец `OnAutoWireViewModelChanged` метода задает [ `BindingContext` ](https://developer.xamarin.com/api/property/Xamarin.Forms.BindableObject.BindingContext/) типа представления для типа модели Разрешить представления. Дополнительные сведения о разрешении типа модели представления в разделе [разрешение](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#resolution).

Такой подход имеет то преимущество, что приложение имеет один класс, ответственный за создание экземпляров Просмотр моделей и их подключение к представлениям.

> [!TIP]
> Используйте представление модели локатора для простоты подстановки. Локатора представление модели может также использоваться как точка подстановки альтернативных реализаций зависимости, такие как для модульного тестирования или разработки времени.

## <a name="updating-views-in-response-to-changes-in-the-underlying-view-model-or-model"></a>Обновление представления в ответ на изменения в базовых просмотр модели или модели

Все модели представления и классов модели, которые доступны в представлении должен реализовывать `INotifyPropertyChanged` интерфейса. Реализация этого интерфейса в класс модели или модели представления позволяет класса для предоставления уведомления об изменениях для всех элементов управления с привязкой к данным в представлении при изменении базового значения свойства.

Приложения должны быть разработана для правильного использования уведомления об изменении свойства с учетом следующих требований:

-   Всегда вызов `PropertyChanged` событие при изменении значения открытого свойства. Не следует предполагать, что вызов `PropertyChanged` событий может быть пропущено из-за знания о том, как происходит привязка XAML.
-   Всегда вызов `PropertyChanged` событий для любых вычисляемых свойств, значения которых используются другие свойства в представлении модели или модели.
-   Всегда вызов `PropertyChanged` событие в конце метода, который позволяет изменить свойства или если обращение к объекту в безопасном состоянии. Порождает событие прерывает операцию путем вызова обработчиков событий в синхронном режиме. Если это происходит в процессе выполнения операции, может предоставлять объект для функции обратного вызова, когда он находится в состоянии unsafe, частично обновлена. Кроме того, возможна для каскадных изменений в инициироваться `PropertyChanged` события. Каскадные изменения обычно требуют обновления быть завершено до каскадных изменений является безопасным для выполнения.
-   Никогда не вызов `PropertyChanged` события, если свойство не изменяется. Это означает, что необходимо сравнить старое и новое значения перед порождением `PropertyChanged` событий.
-   Никогда не вызов `PropertyChanged` событий во время модель представления конструктора при инициализации свойства. Элементы управления с привязкой к данным в представлении не будут подписаны для получения уведомлений об изменениях в этот момент.
-   Никогда не более одного вызова `PropertyChanged` событие с тем же аргументом имя свойства в пределах одного синхронный вызов открытого метода класса. Например, если `NumberOfItems` резервным хранилищем которого является свойство `_numberOfItems` Если метода увеличивает `_numberOfItems` 50 раз во время выполнения цикла, он должен только вызывать уведомление об изменении свойства на `NumberOfItems` один раз, свойство После завершения всех действий. Асинхронные методы вызывают `PropertyChanged` событий для данного имени свойства в каждом сегменте синхронной асинхронное продолжение цепочки.

Использование мобильного приложения eShopOnContainers `ExtendedBindableObject` класса для предоставления уведомления об изменениях, как показано в следующем примере кода:

```csharp
public abstract class ExtendedBindableObject : BindableObject  
{  
    public void RaisePropertyChanged<T>(Expression<Func<T>> property)  
    {  
        var name = GetMemberInfo(property).Name;  
        OnPropertyChanged(name);  
    }  

    private MemberInfo GetMemberInfo(Expression expression)  
    {  
        ...  
    }  
}
```

В Xamarin.Form [ `BindableObject` ](https://developer.xamarin.com/api/type/Xamarin.Forms.BindableObject/) класс реализует `INotifyPropertyChanged` интерфейсов и предоставляет [ `OnPropertyChanged` ](https://developer.xamarin.com/api/member/Xamarin.Forms.BindableObject.OnPropertyChanged/p/System.String/) метод. `ExtendedBindableObject` Класс предоставляет `RaisePropertyChanged` метод, который вызывается свойство уведомления об изменениях и при этом использует функциональные возможности, предоставляемые `BindableObject` класса.

Каждый класс модели представления в мобильном приложении eShopOnContainers является производным от `ViewModelBase` класс, который в свою очередь является производным от `ExtendedBindableObject` класса. Таким образом, каждый класс модели представления используется `RaisePropertyChanged` метод `ExtendedBindableObject` класса для предоставления уведомления об изменении свойства. В следующем примере кода показано, каким образом eShopOnContainers мобильное приложение вызывает уведомление об изменении свойства с помощью лямбда-выражения:

```csharp
public bool IsLogin  
{  
    get  
    {  
        return _isLogin;  
    }  
    set  
    {  
        _isLogin = value;  
        RaisePropertyChanged(() => IsLogin);  
    }  
}
```

Обратите внимание, что такое использование лямбда-выражение включает небольшой производительность, поскольку имеет лямбда-выражение, вычисляемое для каждого вызова. Несмотря на то, что потери производительности мал и не повлияет на обычно приложения, затраты можно провести при, что многие уведомления об изменениях. Однако преимущество этого подхода заключается в обеспечении безопасности типов во время компиляции и оптимизации кода при переименовании свойства.

## <a name="ui-interaction-using-commands-and-behaviors"></a>Взаимодействие с интерфейсом пользователя с помощью команд и поведения

В мобильных приложениях действия обычно вызываются в ответ на действия пользователя, например нажатие кнопки, который можно реализовать путем создания обработчика событий в файле кода. Однако в шаблоне MVVM лежит ответственность за реализации действия с модели представления и следует избегать размещения кода в код программной части.

Команды предоставляют удобный способ представляют действия, которые могут быть привязаны к элементам управления в пользовательском Интерфейсе. Они инкапсулировать код, который реализует действие и помогают обеспечить его лишается визуальное представление в представлении. Xamarin.Forms включает элементы управления, которые могут быть подключены к команде декларативно, а эти элементы управления будет вызвать команду, когда пользователь взаимодействует с элементом управления.

Поведение также позволяют элементы управления декларативно подключиться к команде. Тем не менее поведение может использоваться для вызова действия, связанный с диапазоном событий, вызванных элементом управления. Таким образом поведение решать многие из сценариев, где включена команда элементов управления, обеспечивая большую степень гибкости и управляемости. Поведение может использоваться для связывания объектов команды или методов с элементами управления, которые не были специально разработаны для взаимодействия с командами.

### <a name="implementing-commands"></a>Реализация команды

Просмотр моделей обычно представляют свойства команды, для привязки в представлении, являются экземпляры объектов, которые реализуют `ICommand` интерфейса. Указать ряд элементов управления Xamarin.Forms `Command` свойство, которое может быть данных привязаны к `ICommand` объект, предоставляемый модели представления. `ICommand` Интерфейс определяет `Execute` метод, который инкапсулирует самой операции, `CanExecute` метод, который указывает, является ли команда может быть вызвана и `CanExecuteChanged` событие, возникающее при внесении изменений, влияющих на ли будет выполняться. [ `Command` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) И [ `Command<T>` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) реализовать классы, предоставляемые Xamarin.Forms, `ICommand` интерфейса, где `T` тип аргументов `Execute`и `CanExecute`.

В представлении модели должен быть объектом типа [ `Command` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) или [ `Command<T>` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) для каждого открытого свойства в модели представления типа `ICommand`. `Command` Или `Command<T>` конструктор требует `Action` объект обратного вызова, вызванным при `ICommand.Execute` вызывается метод. `CanExecute` Метод конструктора необязательный параметр, который `Func` , возвращающий `bool`.

В следующем коде показано, как [ `Command` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) экземпляра, которое представляет команду register, создается путем указания делегат для `Register` просмотра модели метода:

```csharp
public ICommand RegisterCommand => new Command(Register);
```

Команда предоставляется представлению через свойство, возвращающее ссылку на `ICommand`. Когда `Execute` метод будет вызван на [ `Command` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) объекта, он просто пересылает вызов метода в модель представления через делегата, который был указан в `Command` конструктора.

Асинхронный метод может вызываться с помощью команды с помощью `async` и `await` ключевые слова при указании команды `Execute` делегата. Это означает, что обратный вызов `Task` и следует ожидать. Например, в следующем коде показано, как [ `Command` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) экземпляра, которое представляет команду, вход, создается путем указания делегат для `SignInAsync` просмотра модели метода:

```csharp
public ICommand SignInCommand => new Command(async () => await SignInAsync());
```

Параметры могут быть переданы `Execute` и `CanExecute` действия с помощью [ `Command<T>` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) класса для создания экземпляра команды. Например, в следующем коде показано, как `Command<T>` экземпляра используется для указания того, что `NavigateAsync` метод потребует аргумент типа `string`:

```csharp
public ICommand NavigateCommand => new Command<string>(NavigateAsync);
```

В обоих [ `Command` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) и [ `Command<T>` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Command/) классы делегат, `CanExecute` в каждом конструкторе является необязательным. Если делегат не указана, `Command` вернет `true` для `CanExecute`. Однако модель представления можно уведомить об изменении в команде `CanExecute` состояния путем вызова `ChangeCanExecute` метод `Command` объекта. В результате `CanExecuteChanged` вызова события. Все элементы управления в пользовательском Интерфейсе, привязанных к команде обновляют их включенное состояние, чтобы отразить наличие команды с привязкой к данным.

#### <a name="invoking-commands-from-a-view"></a>Вызов команды из представления

В следующем коде показано, как [ `Grid` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Grid/) в `LoginView` привязывает `RegisterCommand` в `LoginViewModel` класса с помощью [ `TapGestureRecognizer` ](https://developer.xamarin.com/api/type/Xamarin.Forms.TapGestureRecognizer/) экземпляр:

```xaml
<Grid Grid.Column="1" HorizontalOptions="Center">  
    <Label Text="REGISTER" TextColor="Gray"/>  
    <Grid.GestureRecognizers>  
        <TapGestureRecognizer Command="{Binding RegisterCommand}" NumberOfTapsRequired="1" />  
    </Grid.GestureRecognizers>  
</Grid>
```

Параметр команды также можно дополнительно определить с помощью [ `CommandParameter` ](https://developer.xamarin.com/api/property/Xamarin.Forms.TapGestureRecognizer.CommandParameter/) свойство. Тип ожидаемый аргумент `Execute` и `CanExecute` целевых методов. [ `TapGestureRecognizer` ](https://developer.xamarin.com/api/type/Xamarin.Forms.TapGestureRecognizer/) Автоматически вызывают команда, когда пользователь взаимодействует с помощью вложенного элемента управления. Параметр команды, если указано, будет передан в качестве аргумента команды `Execute` делегата.

<a name="implementing_behaviors" />

### <a name="implementing-behaviors"></a>Реализация поведения

Поведения позволяют функциональные возможности для добавления элементов управления пользовательского интерфейса без необходимости подкласс их. Вместо этого функциональность реализуется в классе поведение и присоединенных к элементу управления, как если бы он был частью самого элемента управления. Поведения позволяют реализовать код, который вы обычно имеет для записи в виде кода программной части, так как он взаимодействует непосредственно с API-Интерфейс управления, так что можно кратко присоединенных к элементу управления и упакованные для повторного использования через более одного представления или приложения. В контексте MVVM поведения — полезна для подключения команд элементов управления.

Это поведение, которое присоединяется к элементу управления с помощью вложенных свойств, известный как *присоединенного поведение*. Поведение можно использовать предоставленные API элемента, к которому присоединяется Добавление функциональных возможностей этого элемента управления или других элементов управления в визуальном дереве представления. Мобильное приложение eShopOnContainers содержит `LineColorBehavior` класса, который является вложенное поведение. Дополнительные сведения об этом поведении см. в разделе [отображения ошибок проверки](~/xamarin-forms/enterprise-application-patterns/validation.md#displaying_validation_errors).

Поведение Xamarin.Forms — это класс, производный от [ `Behavior` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Behavior/) или [ `Behavior<T>` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Behavior%3CT%3E/) класса, где `T `тип элемента управления, к которому должно применяться поведение. Эти классы обеспечивают `OnAttachedTo` и `OnDetachingFrom` методы, которые необходимо переопределить, чтобы добавить логику, которая будет выполняться при поведение прикрепляется к и отсоединения от элементов управления.

В мобильном приложении eShopOnContainers `BindableBehavior<T>` класс является производным от [ `Behavior<T>` ](https://developer.xamarin.com/api/type/Xamarin.Forms.Behavior%3CT%3E/) класса. Назначение `BindableBehavior<T>` класса является предоставление базового класса для Xamarin.Forms поведений, которые требуют [ `BindingContext` ](https://developer.xamarin.com/api/property/Xamarin.Forms.BindableObject.BindingContext/) поведения, задаваемое для вложенного элемента управления.

`BindableBehavior<T>` Класс предоставляет overridable `OnAttachedTo` метод, который задает [ `BindingContext` ](https://developer.xamarin.com/api/property/Xamarin.Forms.BindableObject.BindingContext/) поведение и переопределяемым `OnDetachingFrom` метод, который выполняет очистку `BindingContext`. Кроме того, класс хранит ссылку на вложенный элемент управления в `AssociatedObject` свойство.

Мобильное приложение eShopOnContainers включает `EventToCommandBehavior` класс, который выполняет команду в ответ на появление события. Этот класс является производным от `BindableBehavior<T>` класса, чтобы поведение можно привязать к и выполнить `ICommand` заданные `Command` свойства, если используются в поведение. Следующий пример кода демонстрирует класс `EventToCommandBehavior`:

```csharp
public class EventToCommandBehavior : BindableBehavior<View>  
{  
    ...  
    protected override void OnAttachedTo(View visualElement)  
    {  
        base.OnAttachedTo(visualElement);  

        var events = AssociatedObject.GetType().GetRuntimeEvents().ToArray();  
        if (events.Any())  
        {  
            _eventInfo = events.FirstOrDefault(e => e.Name == EventName);  
            if (_eventInfo == null)  
                throw new ArgumentException(string.Format(  
                        "EventToCommand: Can't find any event named '{0}' on attached type",   
                        EventName));  

            AddEventHandler(_eventInfo, AssociatedObject, OnFired);  
        }  
    }  

    protected override void OnDetachingFrom(View view)  
    {  
        if (_handler != null)  
            _eventInfo.RemoveEventHandler(AssociatedObject, _handler);  

        base.OnDetachingFrom(view);  
    }  

    private void AddEventHandler(  
            EventInfo eventInfo, object item, Action<object, EventArgs> action)  
    {  
        ...  
    }  

    private void OnFired(object sender, EventArgs eventArgs)  
    {  
        ...  
    }  
}
```

`OnAttachedTo` И `OnDetachingFrom` методы используются для регистрации и отмены регистрации обработчика событий для события, определенного в `EventName` свойство. Затем, при возникновении события, `OnFired` вызывается метод, который выполняет команду.

Преимущество использования `EventToCommandBehavior` для выполнения команды при запуске события, является то, что команды можно связать с элементами управления, которые не были предназначены для взаимодействия с помощью команд. Кроме того перемещается код обработки событий Просмотр моделей, где он может быть модульного тестирования.

#### <a name="invoking-behaviors-from-a-view"></a>Вызов поведения из представления

`EventToCommandBehavior` Особенно полезна для присоединения команды управления, который не поддерживает команды. Например `ProfileView` использует `EventToCommandBehavior` для выполнения `OrderDetailCommand` при [ `ItemTapped` ](https://developer.xamarin.com/api/event/Xamarin.Forms.ListView.ItemTapped/) событие запускается на [ `ListView` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ListView/) , содержащая список заказов для пользователя, как показано в следующем коде:

```xaml
<ListView>  
    <ListView.Behaviors>  
        <behaviors:EventToCommandBehavior             
            EventName="ItemTapped"  
            Command="{Binding OrderDetailCommand}"  
            EventArgsConverter="{StaticResource ItemTappedEventArgsConverter}" />  
    </ListView.Behaviors>  
    ...  
</ListView>
```

Во время выполнения `EventToCommandBehavior` будет отвечать на действия с [ `ListView` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ListView/). При выборе элемента в `ListView`, [ `ItemTapped` ](https://developer.xamarin.com/api/event/Xamarin.Forms.ListView.ItemTapped/) активизируется событие, в которой будет выполнен `OrderDetailCommand` в `ProfileViewModel`. По умолчанию аргументы событий для события передаются в команду. Эти данные преобразуются при передаче между источником и целью преобразователем, указанный в `EventArgsConverter` свойство, которое возвращает [ `Item` ](https://developer.xamarin.com/api/property/Xamarin.Forms.ItemTappedEventArgs.Item/) из `ListView` из [ `ItemTappedEventArgs` ](https://developer.xamarin.com/api/type/Xamarin.Forms.ItemTappedEventArgs/). Таким образом, когда `OrderDetailCommand` выполняется, выбранный `Order` передается как параметр зарегистрированных действий.

Дополнительные сведения о поведении см. в разделе [поведения](~/xamarin-forms/app-fundamentals/behaviors/index.md).

## <a name="summary"></a>Сводка

Шаблон Model-View-ViewModel (MVVM) помогает полностью разделения бизнеса и презентации логику приложения из его пользовательский интерфейс (UI). Поддержание четкое разделение между логикой приложений и пользовательский Интерфейс позволяет устранить множество проблем разработки и облегчает тестирование приложения, обслуживать и развития. Он может также значительно повысить возможности повторного использования кода и позволяет разработчикам и конструктора пользовательского интерфейса, которые более тесно сотрудничать при разработке своих соответствующим частям приложения.

С помощью MVVM шаблон пользовательского интерфейса приложения и разделены на три отдельные классы базового представления и бизнес-логики: представление, которое инкапсулирует пользовательского интерфейса и пользовательского интерфейса логика; модель представления, инкапсулирующей логики презентации и состояния. и модель, которая инкапсулирует бизнес-логику и данные приложения.


## <a name="related-links"></a>Связанные ссылки

- [Загрузить электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
