---
title: "Проверьте атрибуты"
ms.topic: article
ms.prod: xamarin
ms.assetid: 107FBCEA-266B-4295-B7AA-40A881B82B7B
ms.technology: xamarin-cross-platform
author: asb3993
ms.author: amburns
ms.date: 01/15/2016
ms.openlocfilehash: 10fb2e2824a05954e19f9b483884061b217be683
ms.sourcegitcommit: 5fc1c4d17cd9c755604092cf7ff038a6358f8646
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2018
---
# <a name="verify-attributes"></a>Проверьте атрибуты


Вы обнаружите, что созданные Sharpie цели привязки будет сопровождаться `[Verify]` атрибута. Эти атрибуты указывают, что следует _проверить_ , Sharpie цель выполнялось правильнее сравнение привязка, с помощью исходного объявления C, Objective-C (который будет предоставляться в комментарии перед объявлением связанных).

Рекомендуется использовать для проверки _все_ привязан объявления, но скорее всего, _необходимые_ для объявления, сопровождаемых `[Verify]` атрибута. Это так, как во многих ситуациях, не хватает метаданных в исходного машинного кода, чтобы определить, как лучше всего создать привязку. Необходимо ссылаться документации или комментарии к коду в файлах заголовка для принятия наиболее привязки.

После проверки того, что привязка используется исправить или имеют фиксированное оно было правильным, _удалить_ `[Verify]` атрибут для привязки.

> [!IMPORTANT]
> `[Verify]` атрибуты намеренно приведет к ошибкам компиляции C#, чтобы вам придется проверить привязку. Следует удалить `[Verify]` атрибут после проверки (и возможно исправлено) код.

## <a name="verify-hints-reference"></a>Проверить ссылку подсказки

Указание аргумента, предоставленные для атрибута может быть перекрестные ссылки на перечисленные ниже. Документация для любых полученных `[Verify]` атрибутов будет помещена на консоль, а также после завершения привязки.

|Убедитесь, указание|Описание|
|---|---|
|InferredFromPreceedingTypedef|Имя этого объявления было выведено из распространенных соглашением сразу же предшествующих `typedef` в собственного исходного кода. Проверьте правильность выводимого имени как этому соглашению, является неоднозначным.|
|ConstantsInterfaceAssociation|Нет не может определить, с какой интерфейс Objective-C может быть связан объявление переменной внешнего выглядел таким эксперимент. Эти экземпляры привязаны как `[Field]` свойства в частичной интерфейса в рядом с конкретный интерфейс для создания более понятный API, возможно, что исключает константы интерфейс вообще.|
|MethodToProperty|Метод Objective-C были привязаны как свойство C# из-за соглашением, например получающие без параметров и возвращающие значение (результат с отличным от void). Часто такие методы, как они должны быть привязаны как свойства для отображения лучше API, но иногда может возникнуть ложных срабатываний и привязка должна быть фактически метод.|
|StronglyTypedNSArray|Собственный `NSArray*` были привязаны как `NSObject[]`. Можно более строгой типизации массива в привязке, основаны на оценках задать с помощью документации по API (например комментарии в файле заголовка) или с помощью проверки путем тестирования содержимое массива. Например, NSArray * содержащий только NSNumber * instancescan привязываться в виде `NSNumber[]` вместо `NSObject[]`.|

Можно также быстро получить документацию по использованию указание `sharpie verify-docs` средство, например:

```csharp
sharpie verify-docs InferredFromPreceedingTypedef
```

