---
title: "Введение в переносимые библиотеки классов"
description: "В этой статье представлены проекты переносимой библиотеки классов (PCL) и описывается создание и использование Классов проектов в Visual Studio для Mac и Visual Studio."
ms.topic: article
ms.prod: xamarin
ms.assetid: 76ba8f7a-9b6e-40f5-9a29-ff1274ece4f2
ms.technology: xamarin-cross-platform
author: asb3993
ms.author: amburns
ms.date: 03/23/2017
ms.openlocfilehash: e81ecd10f4dfc101cf63ba9d052d15b51a367ee5
ms.sourcegitcommit: 30055c534d9caf5dffcfdeafd6f08e666fb870a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/09/2018
---
# <a name="introduction-to-portable-class-libraries"></a>Введение в переносимые библиотеки классов

_В этой статье представлены проекты переносимой библиотеки классов (PCL) и описывается создание и использование Классов проектов в Visual Studio для Mac и Visual Studio._


Создание кросс платформенных приложений ключевым компонентом является возможность совместно использовать код в различных проектах конкретную платформу. Тем не менее это осложняется тем, что часто используют другой вложенный набор из .NET библиотеке базовых классов (BCL) различных платформ и поэтому фактически предназначены для другой профиль библиотеки .NET Core. Это означает, что каждой платформы можно использовать только библиотеки классов, направленные на один и тот же профиль, чтобы они отображались на запрос отдельных проектов библиотеки классов для каждой платформы.

Существует три основных подхода к совместного использования кода, предназначенных для решения этой проблемы: **проекты .NET Standard**, **проекты переносимой библиотеки классов (PCL)**, и **общих проектов активов**.

- **Проекты .NET standard** [.NET Standard](~/cross-platform/app-fundamentals/net-standard.md).
-  **PCL** проекты предназначаться для конкретных профилей, которые поддерживают набор известных BCL классов и компонентов. С другой стороны, PCL, то, часто требуют дополнительного архитектуры трудозатраты, необходимые для разделения конкретного кода профиля на свои собственные библиотеки. Более подробные сведения об этих двух подходов, в разделе [описываются варианты совместного использования кода](~/cross-platform/app-fundamentals/code-sharing.md) .
-  **Общие проекты активов** использовать один набор файлов и предоставляет быстрый и простой способ для совместного использования кода в решении и обычно применяются директивы условной компиляции для указания путей кода для различных платформ, которые будут использовать (для получения дополнительных сведений сведения см. в разделе [статье общие проекты](~/cross-platform/app-fundamentals/shared-projects.md) и [Настройка Xamarin кросс-платформенных руководство](~/cross-platform/app-fundamentals/code-sharing.md) ).


Эта страница содержит описание процедуры создания **PCL** проект, предназначенный для конкретного профиля, который можно ссылаться в нескольких проектах конкретную платформу.


## <a name="what-is-a-portable-class-library"></a>Что такое переносимой библиотеки классов

При создании проекта приложения или проекта библиотеки, получившийся файл DLL ограничен для определенной платформы, для которой он создан для работы. Это предотвращает запись сборки для приложения Windows, и использующий его в Xamarin.iOS и Xamarin.Android повторно.

При создании переносимой библиотеки классов, тем не менее, вы можете сочетание платформы, которые требуется код для выполнения на. Совместимость выбора, сделанного при создании переносимой библиотеки классов преобразуются в «Профиль» идентификатор, описывающий поддерживает библиотеку платформы.

В следующей таблице показаны некоторые возможности, которые зависят от платформы .NET. Для добавления сборки PCL, который обязательно выполняется для конкретного устройства и платформы, нужно просто выбрать какие поддержки является обязательным при создании проекта.

<table border="1" cellpadding="1" cellspacing="1">
  <tbody>
    <tr>
      <td>
Функция </td>
      <td>
.NET Framework </td>
      <td>
Приложения универсальной платформы Windows </td>
      <td>
Silverlight </td>
      <td>
Windows Phone </td>
      <td>
Xamarin </td>
    </tr>
    <tr>
      <td>
Ядро </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
    </tr>
    <tr>
      <td>
LINQ </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
    </tr>
    <tr>
      <td>
IQueryable </td>
       <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
7.5 + </td>
      <td>
Y </td>
    </tr>
    <tr>
      <td>
Сериализация </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
Y </td>
    </tr>
    <tr>
      <td>
Заметки к данным </td>
      <td>
4.0.3 + </td>
      <td>
Y </td>
      <td>
Y </td>
      <td>
      </td>
      <td>
Y </td>
    </tr>
  </tbody>
</table>

Столбец Xamarin отражает тот факт, что Xamarin.iOS и Xamarin.Android поддерживает все профили, поставляемых с Visual Studio и доступность функций во всех библиотеках, создаваемые вами будет ограничен только на платформах, выбранная для поддержки.

Сюда входят профили, которые являются сочетания:

-  .NET 4 или .NET 4.5
-  Silverlight 5
-  Windows Phone 8
-  Приложения универсальной платформы Windows

Вы можете прочитать больше о возможностях разных профилей на [веб-сайта корпорации Майкрософт](http://msdn.microsoft.com/en-us/library/gg597391(v=vs.110).aspx) и другой член сообщества см [сводки профиля PCL](http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY) включающее поддерживается framework сведения и другие примечания.



Создание Классов для совместного использования кода имеет ряд преимуществ и недостатков и связывание файла вместо:


**Преимущества**

1. Совместное использование централизованного кода — писать и тестировать код в одном проекте, которые могут использоваться другими библиотек и приложений.
1. Операции рефакторинга влияет на весь код загружен в решение (переносимой библиотеки классов и проекты под конкретные платформы).
1. Проект переносимой библиотеки Классов позволяет легко ссылаться на другие проекты в решении или выходной сборки могут использоваться для других ссылок в своих решениях.


**Недостатки**

1. Так как же переносимой библиотеки классов распределена между несколькими приложениями, библиотеки для конкретных платформ, не может ссылаться (например) Community.CsharpSqlite.WP7).
1. Подмножество переносимой библиотеки классов не могут содержать классы, которые в противном случае были бы доступны в MonoTouch и Mono для Android (например, DllImport или System.IO.File).



В некоторой степени на обоих недостатки, можно обойти с помощью шаблона поставщика или внедрения зависимостей для кода фактическую реализацию в проектах платформы для интерфейса или базового класса, который определен в переносимой библиотеки классов.



На этой диаграмме показана архитектура кросс платформенных приложений с помощью переносимой библиотеки классов для совместного использования кода, но также для передачи в функции зависят от платформы с помощью внедрения зависимости.



[![](pcl-images/image1.png "На этой диаграмме показана архитектура кросс платформенных приложений с помощью переносимой библиотеки классов для совместного использования кода, но также для передачи в функции зависят от платформы с помощью внедрения зависимости")](pcl-images/image1.png#lightbox)



# <a name="visual-studio-for-mactabvsmac"></a>[Visual Studio для Mac](#tab/vsmac)



## <a name="visual-studio-for-mac-walkthrough"></a>Пошаговое руководство по Visual Studio для Mac


В этом разделе рассматриваются способы создания и использования переносимой библиотеки классов с помощью Visual Studio для Mac. См. в разделе примеров PCL полную реализацию.



### <a name="creating-a-pcl"></a>Создание PCL


Добавление переносимой библиотеки классов в решение очень сходно с добавлением обычного проекта библиотеки.


1. В диалоговом окне нового проекта выберите `Multiplatform > Library > Portable Library` параметр


    ![](pcl-images/image2.png "Многоплатформенных > библиотеки > переносимой библиотеки")


1. При создании PCL в Visual Studio для Mac автоматически настраивается с использованием профиля, работает для Xamarin.iOS и Xamarin.Android. Проект PCL отображаются так, как показано в этом снимке экрана:

    ![](pcl-images/image3.png "Проект PCL отображаются так, как показано в этом снимке экрана")

PCL готов для кода для добавления. Можно также ссылаться в других проектах (проекты приложений, проекты библиотек и даже в других проектах PCL).



### <a name="editing-pcl-settings"></a>Изменение параметров PCL


Чтобы просмотреть и изменить параметры PCL для этого проекта, щелкните правой кнопкой мыши проект и выберите **параметры > сборки > Общие** для просмотра на экране, показано ниже:



[![](pcl-images/image4.png "Для просмотра и изменения параметров PCL для этого проекта, щелкните правой кнопкой мыши проект и выберите параметры построения общие для просмотра экран, показанный здесь")](pcl-images/image4.png#lightbox)



На этом экране параметров какие платформы не совместима с этой конкретной PCL. При изменении любого из этих параметров изменяет профиль этого PCL, который в свою очередь управляет возможностей, которые можно использовать в переносимом коде.



При изменении любого из `Target Framework` автоматически обновляет параметры `Current Profile`; экрана также выводит предупреждение, если выбраны параметры несовместимы.



[![](pcl-images/image5.png "Изменение любого параметра требуемой версии .NET Framework автоматически обновляет текущий профиль на экране также появится предупреждение, если выбраны несовместимые параметры")](pcl-images/image5.png#lightbox)



Если профиль был изменен после кода уже был добавлен в переносимую библиотеку классов, возможно, что библиотеки больше не будет компилироваться, если код ссылается на функции, которые не являются частью вновь выбранного профиля.


## <a name="working-with-a-pcl"></a>Работа с PCL


Если код написан на библиотеки PCL, Visual Studio для Mac редактора распознает ограничения выбранного профиля и соответствующим образом настроить параметры автозаполнения. Например, на этом снимке экрана показаны параметры автозаполнения System.IO с использованием профиля по умолчанию (Profile136), используемых в Visual Studio для Mac — Обратите внимание, указывающий половину доступных классов, отображаются полосы прокрутки (на самом деле существует только 14 классы доступны).



[![](pcl-images/image6.png "С помощью профиля по умолчанию Profile136, используемых в Visual Studio для Mac Обратите внимание, полосы прокрутки, который указывает половину доступных классов, отображаются на самом деле существует только 14 классы, доступные операции ввода-ВЫВОДА")](pcl-images/image6.png#lightbox)



Сравнить с System.IO, активирующей автозаполнение в проект Xamarin.iOS и Xamarin.Android —, 40 классы, доступные включая часто используемые классы, такие как `File` и `Directory` какие нет ни одного профиля PCL.



[![](pcl-images/image7.png "40 классы, доступные включая часто используемые классы как файлов и каталогов, которые отсутствуют в любой PCL профиль")](pcl-images/image7.png#lightbox)



Это отражает базовой недостаток использования PCL — возможность легко совместно использовать код на многих платформах означает, что некоторые API вам недоступны, поскольку они не имеют сравнимые реализации для всех возможных платформ.



### <a name="using-pcl"></a>С помощью PCL


После создания проект переносимой библиотеки Классов можно добавить ссылку на него из любого совместимого проекта приложения или библиотеки таким же образом, обычно добавляются ссылки. В Visual Studio для Mac, щелкните правой кнопкой мыши узел "ссылки" и выберите `Edit References…` затем перейдите на вкладку проекты, как показано:



[![](pcl-images/image8.png "В Visual Studio для Mac щелкните правой кнопкой мыши узел "ссылки" и выберите Изменить ссылки, затем перейдите на вкладку "Проекты", как показано")](pcl-images/image8.png#lightbox)



На следующем рисунке показан pad решений для примера приложения TaskyPortable, показывающая библиотеки PCL снизу и ссылку на эту библиотеку Классов в проекте Xamarin.iOS.



[![](pcl-images/image9.png "Разредить решение для образца приложения TaskyPortable")](pcl-images/image9.png#lightbox)



Выходные данные PCL (т. е. результирующую сборку DLL) также можно добавить как ссылку на большинство проектов. Это делает PCL идеальный способ отправки кросс платформенных компоненты и библиотеки.




# <a name="visual-studiotabvswin"></a>[Visual Studio](#tab/vswin)




## <a name="visual-studio-walkthrough"></a>Пошаговое руководство по Visual Studio


В этом разделе рассматриваются способы создания и использования переносимой библиотеки классов с помощью Visual Studio. См. в разделе примеров PCL полную реализацию.



### <a name="creating-a-pcl"></a>Создание PCL


Добавление PCL решение в Visual Studio несколько отличается по добавлению обычный проект.



1. В окне Добавление нового проекта выберите `Portable Class Library` параметр


    ![](pcl-images/image10.png "Переносимая библиотека классов")


1. Visual Studio немедленно отобразит запрос с следующее диалоговое окно, чтобы можно было настроить профиль.
 Деления платформы, которые требуются для поддержки и нажмите кнопку ОК.


    ![](pcl-images/image11.png "Деления платформы, которые требуются для поддержки и нажмите "OK"")


1. Проект PCL отображаются так, как показано в обозревателе решений. Узел "ссылки" покажет, что библиотеке использует подмножество .NET Framework (определенные в профиле PCL).

    ![](pcl-images/image12.png "NET Framework, определенные в профиле PCL")

PCL готов для кода для добавления. Можно также ссылаться в других проектах (проекты приложений, проекты библиотек и даже в других проектах PCL).



### <a name="editing-pcl-settings"></a>Изменение параметров PCL


Можно просмотреть и изменить, щелкнув правой кнопкой мыши проект и выбрав параметры PCL **свойства > Библиотека** , как показано на этом снимке экрана:



[![](pcl-images/image13.png "Параметры PCL можно просмотреть и изменить, щелкнув правой кнопкой мыши проект и выбрав библиотеки свойства, как показано на этом снимке экрана")](pcl-images/image13.png#lightbox)



Если профиль был изменен после кода уже был добавлен в переносимую библиотеку классов, возможно, что библиотеки больше не будет компилироваться, если код ссылается на функции, которые не являются частью вновь выбранного профиля.



### <a name="working-with-a-pcl"></a>Работа с PCL


Если код написан на библиотеки PCL, Visual Studio распознает ограничения выбранного профиля и соответствующим образом настроить параметры технологии Intellisense. Например, на этом снимке экрана показаны параметры автозаполнения System.IO с использованием профиля по умолчанию (Profile136) – Обратите внимание, указывающий половину доступных классов, отображаются полосы прокрутки (на самом деле доступны только классы 14).



[![](pcl-images/image14.png "Операции ввода-ВЫВОДА с помощью профиля по умолчанию Profile136")](pcl-images/image14.png#lightbox)



Сравнить с System.IO, активирующей автозаполнение в обычный проект —, 40 классы, доступные включая часто используемые классы, такие как `File` и `Directory` какие нет ни одного профиля PCL.



[![](pcl-images/image15.png "Автозаполнение в обычный проект")](pcl-images/image15.png#lightbox)



Это отражает базовой недостаток использования PCL — возможность легко совместно использовать код на многих платформах означает, что некоторые API вам недоступны, поскольку они не имеют сравнимые реализации для всех возможных платформ.



### <a name="using-pcl"></a>С помощью PCL


После создания проект переносимой библиотеки Классов можно добавить ссылку на него из любого совместимого проекта приложения или библиотеки таким же образом, обычно добавляются ссылки. В Visual Studio, щелкните правой кнопкой мыши узел "ссылки" и выберите `Add Reference...` переключитесь **решения: проекты** вкладки, как показано:



[![](pcl-images/image16.png "Вкладка «проекты» как показано")](pcl-images/image16.png#lightbox)



На следующем рисунке показан область решений для примера приложения TaskyPortable, показывающая библиотеки PCL снизу и ссылку на эту библиотеку Классов в проекте Xamarin.iOS.



[![](pcl-images/image17.png "Область решений для примера приложения TaskyPortable")](pcl-images/image17.png#lightbox)



Выходные данные PCL (т. е. результирующую сборку DLL) также можно добавить как ссылку на большинство проектов.
Это делает PCL идеальный способ отправки кросс платформенных компоненты и библиотеки.




-----



## <a name="pcl-example"></a>Пример PCL


[TaskyPortable](https://developer.xamarin.com/samples/mobile/TaskyPortable/) образце приложения показано использование переносимой библиотеки классов с помощью Xamarin.
Ниже приведены некоторые снимки полученный приложения, работающие на iOS, Android и Windows Phone.



[![](pcl-images/image18.png "Ниже приведены некоторые снимки полученный приложения, работающие на iOS, Android и Windows Phone")](pcl-images/image18.png#lightbox)



Она имеет ряд данных и логики классы, которые являются чисто переносимого кода, а также показано, как внедрить требований платформой, с помощью внедрения зависимости для реализации базы данных SQLite.




Ниже приведен структуры решения (в Visual Studio для Mac и Visual Studio соответственно):



[![](pcl-images/image19.png "Структуры решений показано в Visual Studio для Mac и Visual Studio соответственно")](pcl-images/image19.png#lightbox)



Так как код SQLite NET содержит специфический для платформы (для работы с реализациями SQLite каждого других операционных системах) для демонстрационных целей был выполнен рефакторинг в абстрактный класс, который может быть скомпилирован в переносимой библиотеки классов, и фактический код, реализованный как подклассов в проекты iOS и Android.



### <a name="taskyportablelibrary"></a>TaskyPortableLibrary

Компоненты .NET, которые может поддерживать ограничен переносимой библиотеки классов. Так как она компилируется на нескольких платформах, нельзя сделать использование `[DllImport]` функциональность, используемую в SQLite NET. Вместо этого SQLite NET реализуется как абстрактный класс и затем указываются с помощью остальная часть общего кода. Ниже приводится извлечения абстрактный API-интерфейса.


```csharp
public abstract class SQLiteConnection : IDisposable {

    public string DatabasePath { get; private set; }
    public bool TimeExecution { get; set; }
    public bool Trace { get; set; }
    public SQLiteConnection(string databasePath) {
         DatabasePath = databasePath;
    }
    public abstract int CreateTable<T>();
    public abstract SQLiteCommand CreateCommand(string cmdText, params object[] ps);
    public abstract int Execute(string query, params object[] args);
    public abstract List<T> Query<T>(string query, params object[] args) where T : new();
    public abstract TableQuery<T> Table<T>() where T : new();
    public abstract T Get<T>(object pk) where T : new();
    public bool IsInTransaction { get; protected set; }
    public abstract void BeginTransaction();
    public abstract void Rollback();
    public abstract void Commit();
    public abstract void RunInTransaction(Action action);
    public abstract int Insert(object obj);
    public abstract int Update(object obj);
    public abstract int Delete<T>(T obj);

    public void Dispose()
    {
        Close();
    }
    public abstract void Close();

}
```


В оставшейся части общий код использует абстрактный класс для «store» и «получить» объекты из базы данных. В любое приложение, использующее этот абстрактный класс необходимо передать в полную реализацию функциональности реальной базы данных.



### <a name="taskyandroid-and-taskyios"></a>TaskyAndroid и TaskyiOS


IOS и Android приложения проектов содержат пользовательского интерфейса и других платформ код, используемый для передачи показатель общего кода в PCL.



Эти проекты также содержат реализацию абстрактного базы данных API, который работает на этой платформе. В iOS и Android Sqlite компонент database engine встроенной операционной системы, чтобы можно было использовать реализацию `[DllImport]` как показано для предоставления конкретную реализацию подключение к базе данных. Фрагмент кода реализации платформой приведен ниже:


```csharp
[DllImport("sqlite3", EntryPoint = "sqlite3_open")]
public static extern Result Open(string filename, out IntPtr db);

[DllImport("sqlite3", EntryPoint = "sqlite3_close")]
public static extern Result Close(IntPtr db);
```


Полная реализация можно увидеть в образце кода.

### <a name="taskywinphone"></a>TaskyWinPhone


Его пользовательского интерфейса, созданного с помощью XAML и содержит другие кода под конкретную платформу для подключения общих объектов с помощью пользовательского интерфейса приложения Windows Phone.



В отличие от реализацию, используемую для iOS и Android, необходимо создать и использовать экземпляр приложения Windows Phone `Community.Sqlite.dll` как часть его абстрактный базы данных API. Вместо использования `DllImport`, методы, такие как Open реализуются с помощью Community.Sqlite сборки, которая указывается в `TaskWinPhone` проекта. Ниже показана фрагмент кода для сравнения с iOS и Android версии выше


```csharp
public static Result Open(string filename, out Sqlite3.sqlite3 db)
{
    db = new Sqlite3.sqlite3();
    return (Result)Sqlite3.sqlite3_open(filename, ref db);
}

public static Result Close(Sqlite3.sqlite3 db)
{
    return (Result)Sqlite3.sqlite3_close(db);
}
```


## <a name="summary"></a>Сводка


В этой статье кратко имеет рассматриваются преимущества и подводные камни переносимой библиотеки классов, было показано, как создавать и использовать PCLs из внутри Visual Studio для Mac и Visual Studio. и наконец, появившиеся полный пример приложения — TaskyPortable —, показывающий PCL в действие.


## <a name="related-links"></a>Связанные ссылки

- [TaskyPortable (пример)](https://developer.xamarin.com/samples/mobile/TaskyPortable/)
- [Создание кроссплатформенных приложений](~/cross-platform/app-fundamentals/building-cross-platform-applications/index.md)
- [Переносимый Visual Basic](~/cross-platform/platform/visual-basic/index.md)
- [Общие проекты](~/cross-platform/app-fundamentals/shared-projects.md)
- [Параметры совместного использования кода](~/cross-platform/app-fundamentals/code-sharing.md)
- [Межплатформенная разработка в .NET Framework (Майкрософт)](http://msdn.microsoft.com/en-us/library/gg597391(v=vs.110).aspx)
