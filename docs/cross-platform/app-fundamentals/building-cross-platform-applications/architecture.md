---
title: Часть 2 - архитектура
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
ms.technology: xamarin-cross-platform
author: asb3993
ms.author: amburns
ms.date: 03/27/2017
ms.openlocfilehash: d8da218e081b0c3da7a7590f232c8e604b98a790
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="part-2---architecture"></a>Часть 2 - архитектура

Ключевой принцип построения кросс платформенные приложения является создание архитектуры, который пригоден для максимизации совместному использованию платформы кода. Соблюдение следующих общих принципах объектно-ориентированное программирование помогает построить приложение с хорошей архитектурой:

-   **Инкапсуляция** — обеспечение, классов и даже архитектурных слоев предоставляют только минимальные API, который выполняет их необходимые функции и скрывает подробности реализации. На уровне класса это означает объекты ведут себя как «черный поля» и что код не нужно знать, как они выполнять свои задачи. На уровне архитектуры это означает, что реализации шаблонов как оболочкой, способствующих упрощенный API, который управляет более сложного взаимодействия от имени кода в абстрактной слои. Это означает, что код пользовательского интерфейса (например) должны только отвечает за отображение экраны и принимать ввод данных пользователем; и никогда не прямого обращения к базе данных. Аналогичным образом кода доступа к данным необходимо только для чтения записи в базу данных, а не взаимодействовать непосредственно с помощью кнопок и метки.
-   **Разделение обязанностей** — убедитесь, что каждый компонент (оба архитектуры и класса уровень) с целью очистки и четко определенных. Каждый компонент следует выполнять не только его определенные задачи и предоставляют эти функциональные возможности через API-Интерфейс, доступном для других классов, необходимых для его использования.
-   **Полиморфизм** — программирования интерфейса (или абстрактного класса), которая поддерживает несколько реализаций означает, что основного кода могут быть написаны и общих разных платформ, а по-прежнему взаимодействия с платформой возможности.


Естественным результатом является приложением, реальный или абстрактные сущности с отдельных логических слоев, созданных. Разделение кода на слои делать приложения более понятным, тестирование и поддержку. Рекомендуется, чтобы код в каждом слое был физически отдельном (либо в каталоги или даже отдельные проекты для очень крупных приложений), а также логически отдельно (с помощью пространств имен).

 <a name="Typical_Application_Layers" />


## <a name="typical-application-layers"></a>Типичное приложение слоев

В этом документе и практические примеры мы называем со следующими уровнями шесть приложения:

-   **Уровень данных** — долговременного сохраняемости данных, скорее всего, будут в базу данных SQLite, но могут быть реализованы с XML-файлы или любой другой подходящий механизм.
-   **Уровень доступа к данным** — оболочка уровень данных, обеспечивающий создание, чтение, обновление, удаление (CRUD) доступ к данным без предоставления особенностей реализации в вызывающий объект. Например DAL может содержать инструкции SQL для запроса или обновления данных, но код ссылки не нужно знать.
-   **Бизнес-слое** — (иногда называется уровня бизнес-логики и уровень бизнес-ЛОГИКИ) содержит определения сущности бизнеса (модель) и бизнес-логики. Кандидат для бизнеса Фасадной шаблона.
-   **Уровень доступа к службе** — используется для доступа к службам в облаке: из сложных веб-служб (WCF REST, JSON) простое извлечение данных и изображений с удаленных серверов. Инкапсулирует параметры сети и предоставляет простой API для использования уровней приложений и пользовательского интерфейса.
-   **Уровень приложения** — код, который обычно является конкретной платформе (совместно используемые обычно не на платформах) или кода, зависящие от приложения (не обычно многократного использования). Является хорошей проверки того, можно ли поместить код на уровне приложения и уровень пользовательского интерфейса (a) для того, чтобы определить, является ли класс имеет все фактические отображаемыми элементами управления или (б) ли он может совместно использоваться несколько экранов и устройства (например) iPhone и iPad).
-   **Уровень пользовательского интерфейса (UI)** — уровень пользовательского интерфейса содержит экраны, мини-приложений и контроллеров, управлять ими.


Приложения не обязательно содержит все слои, например не будет существовать на уровне доступа к службе в приложении, которое не осуществляет доступ к сетевым ресурсам. Очень простое приложение может объединить уровень данных и уровень доступа к данным из-за слишком основных операций.

 <a name="Common_Mobile_Software_Patterns" />


## <a name="common-mobile-software-patterns"></a>Общие шаблоны для мобильного программного обеспечения

Шаблоны являются установленного способ захвата повторяющихся решения распространенных проблем. Существует несколько основных шаблонов, полезные для понимания в разработке мобильных приложений, сопровождения и понятным.

-   **Модель, представление, ViewModel (MVVM)** — шаблон Model-View-ViewModel популярен с платформ, которые поддерживают привязку данных, например Xamarin.Forms. Он был того, с поддержкой XAML пакеты SDK, такие как Windows Presentation Foundation (WPF) и Silverlight; где ViewModel выступает в качестве посредника между данных (модель) и пользовательский интерфейс (представление) через привязку данных и команд.
-   **Модель, представление, Controller (MVC)** — шаблон общих и часто всего MVC чаще всего используется при построении пользовательских интерфейсов и предоставляет для разделения между фактическому определению экрана пользовательского интерфейса (представление), стоящий за ней ядра, который обеспечивает взаимодействие (контроллер) и данных, который заполняет его (модели). Модели — фактически это полностью необязательно, и таким образом, ядро основные сведения об этой модели заключается в представление и контроллер. MVC — это популярный подход для приложений iOS.
-   **Business Фасадной** -AKA шаблон Manager предоставляет упрощенный точку входа для сложных действий. Например, в приложении отслеживания задач может потребоваться `TaskManager` класса с помощью методов, таких как `GetAllTasks()` , `GetTask(taskID)` , `SaveTask (task)` и т. д. `TaskManager` Класс служит оболочкой для внутренней работы фактически сохранение и извлечение объектов задачи.
-   **Одноэлементный** — предоставляет единый шаблон для способом, в которой когда-либо может существовать только один экземпляр определенного объекта. Например при использовании SQLite в мобильных приложениях, только когда-либо требуется один экземпляр базы данных. С помощью единый шаблон является простой способ обеспечить это.
-   **Поставщик** — шаблон придумал корпорацией Майкрософт (возможно аналогично стратегии или basic внедрения зависимостей), чтобы стимулировать повторного использования кода в приложениях Silverlight, WPF и WinForms. Общий код можно создавать интерфейс или абстрактный класс и конкретные реализации платформой записываются и переданный при использовании кода.
-   **Асинхронный** — не следует путать с ключевого слова Async при долгосрочных работ должен быть выполнен без задержать пользовательского интерфейса или обработки текущего используется шаблон асинхронных операций. В простейшей форме асинхронный шаблон просто перечислены длительно выполняемых задач должны быть запущена в другом потоке (или аналогичные абстракции потока, например задачи) во время текущего потока продолжает обрабатывать и ожидает ответа от фоновый процесс и затем обновляет пользовательский Интерфейс при возврате данных и состояние.


Каждый из шаблонов будут проверены более подробно стремительного их практического применения в случае успеха. Википедии с более подробными описаниями [MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel), [MVC](https://en.wikipedia.org/wiki/Model–view–controller), [Facade](http://en.wikipedia.org/wiki/Facade_pattern), [одноэлементный](http://en.wikipedia.org/wiki/Singleton_pattern), [стратегии](http://en.wikipedia.org/wiki/Strategy_pattern)и [поставщика](http://en.wikipedia.org/wiki/Provider_model) шаблонов (и [шаблоны проектирования](http://en.wikipedia.org/wiki/Design_Patterns) обычно).
