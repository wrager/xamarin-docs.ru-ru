---
title: "Выполнение Android служб в удаленных процессов"
description: "Как правило все компоненты в приложение будет выполняться в рамках одного процесса. Android службы являются исключением, настроенных для работы в собственные процессы и совместно с другими приложениями, включая те, у других разработчиков Android. В этом руководстве описывается, как создавать и использовать Android удаленной службы, с помощью Xamarin."
ms.topic: article
ms.prod: xamarin
ms.assetid: 27A2E972-A690-480B-B31D-5EF1F74F673C
ms.technology: xamarin-android
author: topgenorth
ms.author: toopge
ms.date: 02/16/2018
ms.openlocfilehash: ebbb4b527b27b87bb6357723978e730304658720
ms.sourcegitcommit: cc38757f56aab53bce200e40f873eb8d0e5393c3
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/20/2018
---
# <a name="running-android-services-in-remote-processes"></a>Выполнение Android служб в удаленных процессов

_Как правило все компоненты в приложение будет выполняться в рамках одного процесса. Android службы являются исключением, настроенных для работы в собственные процессы и совместно с другими приложениями, включая те, у других разработчиков Android. В этом руководстве описывается, как создавать и использовать Android удаленной службы, с помощью Xamarin._

## <a name="out-of-process-services-overview"></a>Общие сведения о службах процесса внешней

При запуске приложения Android создает процесс, в котором выполняется приложение. Как правило все компоненты приложение будет выполняться в один процесс. Android службы являются исключением, настроенных для работы в собственные процессы и совместно с другими приложениями, включая те, у других разработчиков Android. Эти типы служб, называются _удаленной_ или _out of process службы_. Код для этих служб будут содержаться в одной APK как основное приложение; Тем не менее, при запуске службы Android будет создан новый процесс для только на эту службу. Напротив, служба, которая выполняется в том же процессе, что и остальные части приложения иногда называют _локальной службы_.

Как правило это необходимо для приложения для реализации удаленной службы. Локальная служба достаточно (и желательно) требования приложения во многих случаях. Out-of-process имеет собственный памяти пространства, который должен находиться под управлением Android. Несмотря на то, что это вводит дополнительные издержки для приложения в целом, существуют некоторые сценарии, где может быть полезен для запуска службы в своем собственном процессе:

1. **Общий доступ к функциональности** &ndash; некоторые разработчики приложений могут иметь несколько приложений и функциональные возможности, общим для всех приложений. Упаковка определенной функции в Android службы, которая выполняется в собственном процессе может упростить обслуживание приложений. Можно также для упаковки службы в свой собственный автономного APK и развертывать отдельно от остальной части приложения.
2. **Повышения столкнуться пользователь** &ndash; существует два возможных способа, что службы out of process можно улучшить взаимодействие с пользователем приложения. Первый способ работает с управления памятью. После сбора мусора (GC) происходит цикла Android приостанавливает все действия в процессе, пока сборщик Мусора не завершится. Пользователь может воспринимать паузы как «дерганья» или «jank». Если служба работает в собственный процесс, процесс службы, которое приостанавливается, не процесс приложения. Приостановить будет намного менее заметным, пользователю, как процесс приложения (и, следовательно, пользовательский интерфейс) не приостановлена.

    Во-вторых Если требования к памяти процесса становится слишком большим, Android может завершить этот процесс для освобождения ресурсов для устройства. Если он выполняется в том же процессе, как пользовательский Интерфейс службы имеют большой объем памяти, затем при Android принудительно высвобождает ресурсы пользовательского интерфейса завершит работу, заставляя пользователя для запуска приложения. Тем не менее если служба, выполняющаяся в собственном процессе завершается системой Android, процесс пользовательского интерфейса остается без изменений. Пользовательский Интерфейс можно выполнить привязку (и перезапустите) службы прозрачно для пользователя и возобновления работы.

3. **Повышение производительности приложений** &ndash; процесс пользовательского интерфейса может быть завершен или завершение работы независимо от процесса службы. Переместив задачи длительное время запуска службы out of process, существует вероятность, что время запуска пользовательского интерфейса может быть улучшена (предполагается, что служба процесс остается активным между попыток запуска пользовательского интерфейса).

Во многих отношениях привязку к службе, запущенной в другом процессе является таким же, как [привязка к локальной службе](~/android/app-fundamentals/services/creating-a-service/bound-services.md). Клиент будет вызывать `BindService` привязку (и запустить, если это необходимо) службы. `Android.OS.IServiceConnection` Будет создан объект для управления подключением между клиентом и службой. Если клиент успешно привязывается к службе, то Android вернет объект через `IServiceConnection` может использоваться для вызова методов на стороне службы. Клиент затем взаимодействует со службой, с помощью данного объекта. Чтобы просмотреть, ниже приведены шаги для привязки к службе.

* **Создать назначение** &ndash; необходимо использовать явную целью для привязки к службе.
* **Реализация и создания экземпляра `IServiceConnection` объекта** &ndash; `IServiceConnection` объект выступает в роли посредника между клиентом и службой.  Он отвечает за мониторинг соединение между клиентом и сервером.
* **Вызвать `BindService` метод** &ndash; вызов `BindService` отправляет цель и подключения службы, созданные в предыдущих шагах, для Android, которое берет на себя запуск службы и установления связи между клиентом и службой.

Необходимость выходить за границы процесса создает дополнительные сложности: связи является односторонней (клиент к серверу) и клиент не может напрямую вызвать методы в классе службы. Помните, что если служба выполняется тот же процесс, как клиент, Android предоставляет `IBinder` объекта, которые могут разрешать для двустороннего взаимодействия. Это не относится к службе, запущенной в своем собственном процессе. Клиент взаимодействует с удаленной службой с помощью `Android.OS.Messenger` класса.

Если клиент запрашивает для привязки удаленной службы, будут вызывать Android `Service.OnBind` метод жизненный цикл, который будет возвращать внутренний `IBinder` объекта, которое инкапсулируется `Messenger`. `Messenger` Является тонкой оболочкой для специального `IBinder` реализацию, предоставляемую Android SDK. `Messenger` Берет на себя связи между двумя различными процессами. Разработчик озабочены подробные сведения о сериализации сообщения, маршалинг сообщения через границу процесса и затем ее десериализующий на стороне клиента. Эта работа обрабатывается `Messenger` объекта. На этой диаграмме показаны клиентские компоненты Android, задействованными при запуске клиентом привязки к службе out of process:

![Схема, показывающая шаги и компоненты для привязки к службе клиента](out-of-process-services-images/ipc-01.png "схема, показывающая шаги и компонентов для клиента, привязка к службе.")

`Service` Класса в удаленный процесс проходит через же жизненного цикла обратные вызовы, которые привязанной службы в локальный процесс проходит через и многие API участвующих совпадают. `Service.OnCreate` используется для инициализации `Handler` и вставить его в `Messenger` объекта. Аналогичным образом `OnBind` переопределен, но вместо возвращения `IBinder` объекта, служба будет возвращать `Messenger`.  Диаграмма иллюстрирует происходит в службе, когда клиент пытается привязать его.

![Схема, показывающая шаги и компоненты службы проходит через при привязке к удаленным клиентом](out-of-process-services-images/ipc-02.png "схема, показывающая шаги и компоненты службы проходит через при привязке к удаленным клиентом.")

Когда `Message` принимается службой, он обрабатывается в экземпляре `Android.OS.Handler`. Служба реализует собственную `Handler` подкласс, в котором необходимо переопределить `HandleMessage` метод. Этот метод вызывается `Messenger` и получает `Message` как параметр. `Handler` Будет проверять `Message` метаданных и использовать эту информацию для вызова методов на стороне службы.

Односторонний обмен данными происходит, когда клиент создает `Message` объекта и отправляет его службы с использованием `Messenger.Send` метод. `Messenger.Send` Выполняет сериализацию `Message` и наличии этих сериализованных данных для Android, которое будет перенаправлять сообщения через границу процесса и службы.  `Messenger` , Размещенного на служба ее создаст `Message` объекта из входящих данных. Это `Message` помещается в очередь, где сообщения, отправленные поочередно для `Handler`. `Handler` Будет проверять мета данные, содержащиеся в `Message` и вызывать соответствующие методы на `Service`. На следующей схеме показана этих различных концепций в действии:

![Схема, показывающая, как сообщения передаются между процессами](out-of-process-services-images/ipc-03.png "схема, показывающая, как сообщения передаются между процессами.")

В этом руководстве будет обсуждения деталей реализации службы out of process. Он будут рассматриваться как реализовать службу, которая предназначена для выполнения в отдельном процессе, а также как клиент может связаться с службу с помощью `Messenger` framework. Также кратко рассмотрим двустороннего взаимодействия: клиент, отправляющий сообщение для службы и отправке сообщения обратно клиенту. Поскольку службы могут совместно использоваться разными приложениями, в этом руководстве также обсуждаются методика, ограничивая доступ клиента к службе с использованием разрешений на Android.

> [!IMPORTANT]
> [Bugzilla 51940 - службы с изолированных процессах и пользовательского класса приложения, не неправильного разрешения перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940) отчеты, которые служба Xamarin.Android не будет запущен, надлежащим образом при `IsolatedProcess` равно `true`. В этом руководстве предоставляются для ссылки. Приложение Xamarin.Android должно быть по-прежнему могут взаимодействовать со службой out of process, написанного на языке Java.

## <a name="requirements"></a>Требования

Это руководство предполагает знание создания служб.

Несмотря на то, что можно использовать неявный целей для приложений, предназначенных для более старых API Android, в этом руководстве основное внимание исключительно на использование явных целей. Приложения, предназначенные для Android 5.0 (уровень API 21) или более поздней версии необходимо использовать явную целью для привязки со службой; Это метод, который будет показано в этом руководстве...

## <a name="create-a-service-that-runs-in-a-separate-process"></a>Создать службу, которая выполняется в отдельном процессе

Как описано выше, тот факт, что служба работает в собственном процессе означает, что некоторые другие API-интерфейсы участвующих. Как краткий обзор ниже приведены шаги для привязки с и использования удаленной службы.  

* **Создание `Service` подкласс** &ndash; подкласс `Service` введите и реализовать методы жизненного цикла для привязанного службы. Это также необходимо задать метаданные, сообщит Android, служба будет работать в собственном процессе.
* **Реализуйте `Handler`**  &ndash; `Handler` отвечает за анализ клиентские запросы, извлечения любые параметры, переданные от клиента и вызова соответствующих методов на стороне службы.
* **Создать экземпляр `Messenger`**  &ndash; как описано выше, каждый `Service` должен поддерживать экземпляр `Messenger` класса, которая будет направлять клиентские запросы на `Handler` , созданного на предыдущем шаге.

Служба, которая предназначена для выполнения в своем собственном процессе является, по существу, по-прежнему связанные службы. Класс службы будет расширять базовый `Service` класса и снабжен `ServiceAttribute` с meta данными, которые необходимо объединить в манифесте Android Android. Чтобы начать со следующих свойств `ServiceAttribute` нужных out of process службы:

1. `Exported` &ndash; Это свойство должно быть присвоено `true` позволяет другим приложениям взаимодействовать со службой. По умолчанию этому свойству присваивается значение `false`.
2. `Process` &ndash; Это свойство должно быть задано. Он используется для указания имени процесса, выполняемого в службе.
3. `IsolatedProcess` &ndash; Это свойство позволит повысить уровень защиты, предписывая Android для запуска службы в изолированной, с минимальными разрешениями для iteract с остальной части системы. В разделе [Bugzilla 51940 - служб с изолированных процессах и пользовательского класса приложения не удается правильно разрешить перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940).
4. `Permission` &ndash; Это позволяет контролировать доступ клиента к службе, указав разрешение, которое клиенты должны запрашивать (и предоставляться).

Для запуска службы свой собственный процесс `Process` свойство `ServiceAttribute` должно быть присвоено имя службы. Для взаимодействия с внешними приложениями `Exported` должно быть равно `true`. Если `Exported` — `false`, только клиенты в одном APK (т. е. то же приложение) и работает в том же процессе сможет взаимодействовать со службой.

Служба будет выполняться в процесс какого рода зависит от значения `Process` свойство. Android определяет три различных типа процессов:

-   **Процесс закрытого** &ndash; закрытый процесс — то, доступна только для приложений, что и запустивший его. Чтобы определить процесс как закрытый, его имя должно начинаться с **:** (точку с запятой). Службы, описанные в предыдущем фрагменте кода и снимок экрана — это закрытый процесс. В следующем фрагменте кода приведен пример `ServiceAttribute`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process=":timestampservice_process",
             Exported=true)]
    ```

-   **Глобальные процесс** &ndash; службы, которая выполняется в процессе, глобальные доступны для всех приложений, работающих на устройстве. Глобальные процесс должен быть полное имя класса, начинающееся с символов нижнего регистра.
    (Если не меры для защиты службы другие приложения может привязать и взаимодействовать с ней. Защита службы от несанкционированного использования обсуждаются далее в этом руководстве.)

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

-   **Изолированные процесс** &ndash; изолированный процесс является процессом, который выполняется в свой собственный "песочницы", изолированная от остального системы и без специальных разрешений свои собственные. Для запуска службы в изолированном процессе `IsolatedProcess` свойство `ServiceAttribute` равно `true` как показано в этом фрагменте кода:
    
    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             IsolatedProcess= true,
             Process="com.xamarin.xample.messengerservice.timestampservice_process",
             Exported=true)]
    ```

> [!IMPORTANT]
> В разделе [Bugzilla 51940 - служб с изолированных процессах и пользовательского класса приложения не удается правильно разрешить перегрузки](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)

Изолированной службы является простым способом для обеспечения безопасности приложения и устройства от ненадежного кода. Например приложение может загрузить и выполнения сценария с веб-сайта. В этом случае выполнение это в изолированном процессе предоставляет дополнительный уровень защиты от ненадежного кода риска для устройства Android.

> [!IMPORTANT]
> После экспорта службы имя службы, не следует изменять. Изменение имени службы может прерываться других приложений, которые используют службу.

Чтобы увидеть эффект, `Process` свойство, на следующем рисунке показан службой, работающей в свой собственный закрытый процесс:

![Снимок экрана, показывающий службой, работающей в частной процесс](out-of-process-services-images/ipc-04.png "снимок экрана, показывающий службой, работающей в частной процесса.")

Этом снимке экрана ниже показано `Process="com.xamarin.xample.messengerservice.timestampservice_process"` и что служба выполняется в процессе, глобальные:

![Снимок экрана службы, запущенных в процессе, глобальные](out-of-process-services-images/ipc-05.png "службы, запущенных в процессе, глобальные снимок экрана.")

Один раз `ServiceAttribute` был установлен, службы необходимо реализовать `Handler`.

### <a name="implementing-a-handler"></a>Реализация обработчика

Чтобы обработать запросы клиентов, служба должна реализовывать `Handler` и Переопределите `HandleMessage` methodThis является метод принимает `Message` экземпляра какие, который инкапсулирует вызов метода со стороны клиента и преобразует этот вызов в какое-либо действие или Задача, которая будет выполнять служба. `Message` Объект предоставляет свойство с именем `What` которого является целое число, значение которой распределяется между клиентом и службой и связь с какой-либо задачи, для выполнения для клиента службы.

В следующем фрагменте кода из образца приложения показан пример `HandleMessage`. В этом примере существует два действия, которые клиент может запрашивать службы:

* Первое действие — _Hello, World_ сообщение, клиент отправил простое сообщение службе.
* Второе действие будет вызывать метод для службы и получить строку, в этом случае строка будет сообщение, которое возвращает какое время служба запущена и как долго он запущен:

```csharp
public class TimestampRequestHandler : Android.OS.Handler
{
    // other code omitted for clarity

    public override void HandleMessage(Message msg)
    {
        int messageType = msg.What;
        Log.Debug(TAG, $"Message type: {messageType}.");

        switch (messageType)
        {
            case Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE:
                // The client as sent a simple Hello, say in the Android Log.
                break;

            case Constants.GET_UTC_TIMESTAMP:
                // Call methods on the service to retrive a timestamp message.
                break;
            default:
                Log.Warn(TAG, $"Unknown messageType, ignoring the value {messageType}.");
                base.HandleMessage(msg);
                break;
        }
    }
}
```

Можно также с параметрами пакета службы в `Message`. Это будет описано далее в этом руководстве. Создание следующего раздела, которые следует учитывать `Messenger` объектов для обработки входящего `Message`s.

### <a name="instantiating-the-messenger"></a>При создании экземпляра Messenger

Как уже упоминалось, десериализации `Message` объект и вызова `Handler.HandleMessage` является ответственности от `Messenger` объекта. `Messenger` Класс также предоставляет `IBinder` объекта, что клиент будет использовать для отправки сообщений в службе.  

При запуске службы, она создает экземпляр `Messenger` и вставляют `Handler`. Хорошая возможность выполнить эту инициализацию находится на `OnCreate` метода службы. Этот фрагмент кода является примером службы, которая инициализирует свой собственный `Handler` и `Messenger`:

```csharp
private Messenger messenger; // Instance variable for the Messenger

public override void OnCreate()
{
    base.OnCreate();
    messenger = new Messenger(new TimestampRequestHandler(this));
    Log.Info(TAG, $"TimestampService is running in process id {Android.OS.Process.MyPid()}.");
}
```

На этом этапе последний шаг — для `Service` для переопределения `OnBind`.

### <a name="implementing-serviceonbind"></a>Реализация Service.OnBind

Все связанные службы, является ли они выполняются в собственном процессе или нет, необходимо реализовать `OnBind` метод. Возвращаемое значение этого метода является некоторые объекты, которые клиент может использовать для взаимодействия со службой. Именно то, что этот объект зависит от того, является ли служба локальной службы или удаленной службы. Во время локальной службы возвращает пользовательский `IBinder` реализации вернет удаленной службы `IBinder` инкапсулируется, но `Messenger` , созданного в предыдущем разделе:

```csharp
public override IBinder OnBind(Intent intent)
{
    Log.Debug(TAG, "OnBind");
    return messenger.Binder;
}
```

Когда эти три шага выполняются, удаленная служба может считаться завершенным.

## <a name="consuming-the-service"></a>Использование службы

Все клиенты необходимо реализовать некоторый код для привязки и использования удаленной службы. По существу с точки зрения клиента, являются очень небольшое число различия между привязки для локальной или удаленной службы. Клиент вызывает `BindService` метод, передавая явным намерением для идентификации службы и `IServiceConnection` , помогает управлять соединение между клиентом и службой.

Этот фрагмент кода приведен пример создания **явным намерением** для привязки удаленной службы. Назначение необходимо указать пакет, содержащий службы и имя службы. Чтобы задать эти сведения можно использовать `Android.Content.ComponentName` объекта и получить эту цель. Этот фрагмент кода является одним из примеров:  

```csharp
// This is the package name of the APK, set in the Android manifest
const string REMOTE_SERVICE_COMPONENT_NAME = "com.xamarin.TimestampService";
// This is the name of the service, according the value of ServiceAttribute.Name
const string REMOTE_SERVICE_PACKAGE_NAME   = "com.xamarin.xample.messengerservice";

// Provide the package name and the name of the service with a ComponentName object.
ComponentName cn = new ComponentName(REMOTE_SERVICE_PACKAGE_NAME, REMOTE_SERVICE_COMPONENT_NAME);
Intent serviceToStart = new Intent();
serviceToStart.SetComponent(cn);
```

При привязке службы `IServiceConnection.OnServiceConnected` вызывается метод он предоставляет `IBinder` клиенту. Тем не менее, клиент не будет использовать напрямую `IBinder`. Вместо этого она создает экземпляр `Messenger` объекта из, `IBinder`. Это `Messenger` , клиент будет использовать для взаимодействия с удаленной службой.

Ниже приведен пример очень простой `IServiceConnection` реализации, который демонстрирует, как клиент может обрабатывать подключение и отключение от службы. Обратите внимание, что `OnServiceConnected` метод получает и `IBinder`, и клиент создает `Messenger` из того, что `IBinder`:

```csharp
public class TimestampServiceConnection : Java.Lang.Object, IServiceConnection
{
    static readonly string TAG = typeof(TimestampServiceConnection).FullName;

    MainActivity mainActivity;
    Messenger messenger;

    public TimestampServiceConnection(MainActivity activity)
    {
        IsConnected = false;
        mainActivity = activity;
    }

    public bool IsConnected { get; private set; }
    public Messenger Messenger { get; private set; }

    public void OnServiceConnected(ComponentName name, IBinder service)
    {
        Log.Debug(TAG, $"OnServiceConnected {name.ClassName}");

        IsConnected = service != null
        Messenger = new Messenger(service);

        if (IsConnected)
        {
            // things to do when the connection is successful. perhaps notify the client? enable UI features?
        }
        else
        {
            // things to do when the connection isn't successful.
        }
    }

    public void OnServiceDisconnected(ComponentName name)
    {
        Log.Debug(TAG, $"OnServiceDisconnected {name.ClassName}");
        IsConnected = false;
        Messenger = null;

        // Things to do when the service disconnects. perhaps notify the client? disable UI features?

    }
}
```

После создания подключения службы и намерение возможна клиента для вызова `BindService` и инициировать процесс привязки:

```csharp
IServiceConnection serviceConnection = new TimestampServiceConnection(this);
BindActivity(serviceToStart, serviceConnection, Bind.AutoCreate);
```

После клиент успешно привязан к службе и `Messenger` — доступны, это возможно для отправки клиентом `Messages` к службе.

## <a name="sending-messages-to-the-service"></a>Отправка сообщений в службу

Когда клиент подключен и `Messenger` объекта, существует возможность взаимодействия со службой путем отправки `Message` объектов через `Messenger`. Эта связь является односторонней, клиент отправляет сообщение, но нет возвращаемого сообщения от службы клиенту. В этом отношении `Message` — это механизм выстрелил и забыл.

Рекомендуемый способ создания `Message` необходимо использовать [ `Message.Obtain` ](https://developer.xamarin.com/api/type/Android.OS.Message/#Public%20Methods) фабричный метод. Этот метод будет получать `Message` объекта из глобального пула, который ведется с Android. `Message.Obtain` также имеет некоторые перегруженные методы, позволяющие `Message` объект инициализирован со значениями и параметры, необходимые для службы.  Один раз `Message` будет создан экземпляр, он отправляется службы путем вызова `Messenger.Send`. Этот фрагмент кода представляет собой пример создания и отправки `Message` к процессу службы:

```csharp
Message msg = Message.Obtain(null, Constants.SAY_HELLO_TO_TIMESTAMP_SERVICE);
try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a error trying to send the message.");
}
```

Существует несколько различных форм `Message.Obtain` метод. В предыдущем примере используется [ `Message.Obtain(Handler h, Int32 what)` ](https://developer.xamarin.com/api/member/Android.OS.Message.Obtain/p/Android.OS.Handler/System.Int32/). Поскольку это асинхронный запрос к службе out of process; будет нет ответа от службы, поэтому `Handler` равно `null`. Второй параметр `Int32 what`, будет храниться в `.What` свойство `Message` объекта. `.What` Свойство используется код в процессе службы для вызова методов на стороне службы.

`Message` Класс также предоставляет два дополнительных свойства, которые может быть использована для recipent: `Arg1` и `Arg2`. Эти два свойства: целочисленные значения, которые, возможно, некоторые специальные согласованные значения, которые имеют значение между клиентом и службой. Например `Arg1` может содержать идентификатор клиента и `Arg2` может содержать номер заказа на покупку для этого клиента. [ `Method.Obtain(Handler h, Int32 what, Int32 arg1, Int32 arg2)` ](https://developer.xamarin.com/api/member/Android.OS.Message.Obtain/p/Android.OS.Handler/System.Int32/System.Int32/System.Int32/) Можно задать два свойства при `Message` создается. Другой способ заполнения этих двух значений — для установки `.Arg` и `.Arg2` напрямую на свойства `Message` объекта после его создания.

### <a name="passing-additional-values-to-the-service"></a>Передача дополнительных значений в службу

Можно передать службе более сложных данных с помощью `Bundle`. В этом случае можно указать дополнительные значения в `Bundle` и отправленные вместе с `Message` , установив [ `.Data` свойство](https://developer.xamarin.com/api/property/Android.OS.Message.Data/) свойство перед отправкой.

```csharp
Bundle serviceParameters = new Bundle();
serviceParameters.

var msg = Message.Obtain(null, Constants.SERVICE_TASK_TO_PERFORM);
msg.Data = serviceParameters;

messenger.Send(msg);
```


> [!NOTE]
> Как правило `Message` не должен иметь полезных данных, размер которых превышает 1 МБ. Предельный размер может зависеть от версии Android, и частные изменения могли сделать поставщика для их реализации для Android откройте исходного проекта (AOSP), объединенными с устройством.

## <a name="returning-values-from-the-service"></a>Возврат значений из службы

Архитектура обработки сообщений, который описан в этой точке является односторонней, клиент отправляет сообщение службе. Если это необходимо для службы для возврата клиенту затем все данные, которые обсуждались в этой точке обращено. Служба должна создать `Message`, объединенных всех возвращенных значений и диспетчеризации `Message` через `Messenger` клиенту. Однако служба создает свой собственный `Messenger`; вместо этого при создании экземпляра клиента и пакета `Messenger` как часть исходного запроса. Служба будет `Send` сообщения с использованием этом условии для клиента `Messenger`.  

Последовательность событий для двустороннего взаимодействия такова:

1. Клиент привязывается к службе. Если подключение службы и клиента, `IServiceConnection` , обслуживаемый клиента будут иметь ссылку на `Messenger` объект, используемый для передачи `Message`s для службы. Чтобы избежать путаницы, это будет называться _службы Messenger_.
2. Клиент создает `Handler` (называют _клиентского обработчика_) и использует его для инициализации свой собственный `Messenger` ( _Messenger клиента_). Обратите внимание, что служба сообщений и сообщений клиента двух разных объектов, которые обработки трафика в двух разных направлениях. Служба сообщений обрабатывает сообщения от клиента к службе, в то время Messenger клиента будет обрабатывать сообщения от службы клиенту.
3. Клиент создает `Message` и устанавливается `ReplyTo` свойство с Messenger клиента. Затем сообщение отправляется в службу с помощью службы Messenger.
4. Служба получает сообщения от клиента и выполняет запрашиваемую работу.
5. Когда все готово для службы при отправке ответа клиенту, будет использоваться `Message.Obtain` для создания нового `Message` объекта.
6. Это сообщение отправляется клиенту, служба извлечет Messenger клиента из `.ReplyTo` свойства клиента сообщение и использовать его для `.Send` `Message` обратно клиенту.
7. Когда клиент получает ответ, он имеет свой собственный `Handler` обрабатывать `Message` путем проверки `.What` свойство (и при необходимости извлечения любые параметры, содержащиеся в `Message`).

Этот пример кода демонстрирует, как клиент создает экземпляр `Message` и пакета `Messenger` , служба должна использовать для ответа:

```csharp
Handler clientHandler = new ActivityHandler();
Messenger clientMessenger = new Messenger(activityHandler);

Message msg = Message.Obtain(null, Constants.GET_UTC_TIMESTAMP);
msg.ReplyTo = clientMessenger;

try
{
    serviceConnection.Messenger.Send(msg);
}
catch (RemoteException ex)
{
    Log.Error(TAG, ex, "There was a problem sending the message.");
}
```

Службу необходимо внести некоторые изменения в свой собственный `Handler` для извлечения `Messenger` и использовать его для отправки ответов клиенту. Этот фрагмент кода приведен пример того, как службы `Handler` приведет к созданию `Message` и отправить его клиенту:  

```csharp
// This is the message that the service will send to the client.
Message responseMessage = Message.Obtain(null, Constants.RESPONSE_TO_SERVICE);
Bundle dataToReturn = new Bundle();
dataToReturn.PutString(Constants.RESPONSE_MESSAGE_KEY, "This is the result from the service.");
responseMessage.Data = dataToReturn;

// The msg object here is the message that was received by the service. The service will not instantiate a client,
// It will use the client that is encapsulated by the message from the client.
Messenger clientMessenger = msg.ReplyTo;
if (clientMessenger!= null)
{
    try
    {
        clientMessenger.Send(responseMessage);
    }
    catch (Exception ex)
    {
        Log.Error(TAG, ex, "There was a problem sending the message.");
    }
}
```

Обратите внимание, что в примерах выше, `Messenger` экземпляр, который создается с помощью клиента *не* тот же объект, полученных службой. Это могут быть две различные `Messenger` объектов, выполняемых в двух разных процессах, которые представляют канала связи.

## <a name="securing-the-service-with-android-permissions"></a>Защита службы с разрешениями на Android

Служба, которая выполняется в процессе, глобальные доступен всем приложениям, выполняемым на этом устройстве Android. В некоторых ситуациях это открытость и доступности нежелательно и это необходимо для защиты от несанкционированного использования клиентами службы от доступа. Использование разрешений Android является единственным способом ограничения доступа к удаленной службе.

Разрешения можно определить по `Permission` свойство `ServiceAttribute` который оформляет `Service` вложенный класс. Это будет имя разрешение, которое клиент должен предоставляться при привязке к службе. Если клиент не имеет соответствующих разрешений, а затем создаст исключение Android `Java.Lang.SecurityException` когда клиент пытается выполнить привязку к службе.

Существует четыре различные уровни доступа, предоставляемые Android:

* **Обычный** &ndash; это уровень разрешений по умолчанию. Он используется для определения разрешений низким риском, которые могут автоматически предоставляться системой Android для клиентов, запрашивающих его. Пользователь не имеет явно предоставлять эти разрешения, но разрешения могут просматриваться в параметрах приложения.
* **подпись** &ndash; это специальные категория разрешения предоставляются автоматически системой Android для приложения, подписанные с помощью сертификата. Это разрешение позволяет сделать его легко для разработчиков приложений, для совместного использования компонентов или данных между приложениями, их без беспокоить пользователя для констант утверждений.
* **signatureOrSystem** &ndash; это очень похоже на **подписи** разрешений, описанных выше. Помимо автоматически предоставляются для приложений, которые должны быть подписаны тем же сертификатом, это разрешение также будет предоставлено для приложений, подписанных установлен тот же сертификат, который использовался для подписания приложений с помощью образа системы Android. Это разрешение обычно используется только разработчиками Android ДИСКОВ позволяет их в приложениях для работы с приложениями сторонних производителей. Обычно оно не используется в приложениях, предоставляющих общее распределение для широкой публики.
* **опасные** &ndash; небезопасные разрешения — это те, которые могут вызвать проблемы для пользователя. По этой причине **небезопасные** разрешения должны быть явно утверждены пользователем.

Поскольку `signature` и `normal` разрешения автоматически предоставляются во время установленного системой Android, очень важно установить APK, на котором размещена служба **перед** apk-ФАЙЛ, содержащий клиента. Если сначала установлен клиент Android не предоставит разрешения. В этом случае он будет необходимо удалить клиент APK, установите службу apk-ФАЙЛ и затем заново установить клиент APK.

Существует два способа защиты службы с разрешениями на Android:

1.  **Реализовать безопасность на уровне подписи** &ndash; подписи безопасность на уровне означает, что разрешение предоставляется автоматически для тех приложений, которые подписаны с тем же ключом, который использовался для подписи apk-ФАЙЛ, содержащий службы. Это простой способ для разработчиков защитить свои службы, но обеспечить доступ из своих приложений. Разрешения на уровне подписи объявляются, задав `Permission` свойство `ServiceAttribute` для `signature`:

    ```csharp
    [Service(Name = "com.xamarin.TimestampService",
             Process="com.xamarin.TimestampService.timestampservice_process",
             Permission="signature")]
    public class TimestampService : Service
    {
    }
    ```

2.  **Создать пользовательское разрешение** &ndash; возможно для разработчика службы для создания пользовательского разрешения для службы. Этот способ удобен для когда разработчик хочет предоставить свои службы и приложения от других разработчиков. Пользовательское разрешение требует немного больших усилий для реализации и рассматриваются ниже.

Упрощенный пример создания пользовательской `normal` разрешения, которые будут описаны в следующем разделе. Дополнительные сведения о разрешениях для Android, обратитесь к документации Google для [рекомендации по обеспечению и безопасности](https://developer.android.com/training/articles/security-tips.html). Дополнительные сведения о разрешениях для Android см. в разделе [разделе разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms) Android документации для манифеста приложения, Дополнительные сведения о разрешениях для Android.

> [!NOTE]
> Как правило [Google не рекомендует использовать пользовательские разрешения](https://developer.android.com/training/articles/security-tips.html#RequestingPermissions) как они гарантируют заблуждение пользователей.

### <a name="creating-a-custom-permission"></a>Создание пользовательского разрешения

Чтобы использовать пользовательское разрешение, он объявлен службой, пока клиент явно запрашивает такое разрешение.

Создание разрешения в службе APK, `permission` элемент будет добавлен к `manifest` элемент в **AndroidManifest.xml**. Должен иметь это разрешение `name`, `protectionLevel`, и `label` заданные атрибуты. `name` Атрибута должно быть присвоено строку, которая однозначно идентифицирует разрешение. Имя будет отображаться в **информация приложения** представление **параметры Android** (как показано в следующем разделе).

`protectionLevel` Атрибута должно быть присвоено одно из четырех строковые значения, которые были описаны выше.  `label` И `description` должен ссылаться на строковые ресурсы и используются для предоставления понятное имя и описание для пользователя.

В этом фрагменте приведен пример объявления пользовательского `permission` атрибута в **AndroidManifest.xml** из apk-ФАЙЛ, содержащий службу:

```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerservice">

    <uses-sdk android:minSdkVersion="21" />

    <permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP"
                android:protectionLevel="signature"
                android:label="@string/permission_label"
                android:description="@string/permission_description"
                />

    <application android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">

    </application>
</manifest>
```

Затем **AndroidManifest.xml** клиента APK должен явно запросить это новое разрешение. Это делается путем добавления `users-permission` атрибут **AndroidManifest.xml**:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          android:versionCode="1"
          android:versionName="1.0"
          package="com.xamarin.xample.messengerclient">

    <uses-sdk android:minSdkVersion="21" />

    <uses-permission android:name="com.xamarin.xample.messengerservice.REQUEST_TIMESTAMP" />

    <application
            android:allowBackup="true"
            android:icon="@mipmap/icon"
            android:label="@string/app_name"
            android:theme="@style/AppTheme">
    </application>
    </manifest>
```

### <a name="view-the-permissions-granted-to-an-app"></a>Просмотреть разрешения, предоставленные приложению

Чтобы просмотреть разрешения, которые были предоставлены приложения, откройте приложение Android параметров и выберите **приложения**. Найдите и выберите приложение из списка. Из **информация приложения** экрана, коснитесь **разрешений** котором появится представление, отображающее все разрешения, предоставленные приложению:

[![Снимки экрана из устройство Android, показывающий, как определить разрешения, предоставляемые приложению](out-of-process-services-images/ipc-06-sml.png)](out-of-process-services-images/ipc-06.png#lightbox)

## <a name="summary"></a>Сводка

В этом руководстве было дополнительно обсуждения о том, как запустить службу Android в удаленном процессе. Объяснялось различия между локальной и удаленной службы, а также некоторые причины, почему удаленной службы может быть полезным стабильности и производительности приложения Android. После объяснения, как реализовать удаленной службы и как клиент может связаться со службой, направляющую происходило предоставить один способ ограничить доступ к службе из только авторизованные клиенты.


## <a name="related-links"></a>Связанные ссылки

- [Handler](https://developer.xamarin.com/api/type/Android.OS.Handler/)
- [Message](https://developer.xamarin.com/api/type/Android.OS.Message/)
- [Messenger](https://developer.xamarin.com/api/type/Android.OS.Messenger/)
- [ServiceAttribute](https://developer.xamarin.com/api/type/Android.App.ServiceAttribute)
- [Атрибут экспорта](https://developer.android.com/guide/topics/manifest/service-element.html#exported)
- [Происходит сбой разрешения перегрузки служб с изолированных процессах и пользовательского класса приложения](https://bugzilla.xamarin.com/show_bug.cgi?id=51940)
- [Процессы и потоки](https://developer.android.com/guide/components/processes-and-threads.html)
- [Android манифест - разрешения](https://developer.android.com/guide/topics/manifest/manifest-intro.html#perms)
- [Советы по безопасности](https://developer.android.com/training/articles/security-tips.html)
- [MessengerServiceDemo (sample)](https://developer.xamarin.com/samples/monodroid/ApplicationFundamentals/ServiceSamples/MessengerServiceDemo/)
