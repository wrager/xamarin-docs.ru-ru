---
title: "Xamarin для разработчиков Java"
description: "Если вы разработчик Java, вы можете применять свои навыки работы с существующим кодом на платформе Xamarin, получая возможность повторно использовать код C#. Вы заметите, что синтаксис C# очень напоминает синтаксис Java и что оба языка обеспечивают очень схожие функции. Кроме того, вы ознакомитесь с уникальными функциями C#, которые упрощают разработку."
ms.topic: article
ms.prod: xamarin
ms.assetid: A3B6C041-4052-4E7D-999C-C4FA10BE3D67
ms.technology: xamarin-android
author: mgmclemore
ms.author: mamcle
ms.openlocfilehash: fb74e0efd62c6347534e6f301953325bd4d378d2
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="xamarin-for-java-developers"></a>Xamarin для разработчиков Java

_Если вы разработчик Java, вы можете применять свои навыки работы с существующим кодом на платформе Xamarin, получая возможность повторно использовать код C#. Вы заметите, что синтаксис C# очень напоминает синтаксис Java и что оба языка обеспечивают очень схожие функции. Кроме того, вы ознакомитесь с уникальными функциями C#, которые упрощают разработку._

<a name="overview" />

## <a name="overview"></a>Обзор

Из этой статьи вы узнаете о программировании C# для разработчиков Java, а также ознакомитесь с функциями языка C#, которые используются при разработке приложений Xamarin.Android. Здесь также объясняется, как эти функции отличаются от таких же функций Java. Здесь описываются важные функции C# (применимые к Xamarin.Android), недоступные в Java. В этом руководстве содержатся ссылки на дополнительные справочные материалы, поэтому его можно использовать как стартовую точку для дальнейшего изучения C# и .NET.

Если вы знакомы с Java, понимание синтаксиса C# не вызовет никаких сложностей. Синтаксис C# очень похож на синтаксис Java — в C#, как и в Java, C и C++, используются фигурные скобки. Во многих отношениях синтаксис C# считается расширенным вариантом синтаксиса Java, но с несколькими переименованными и добавленными ключевыми словами.

В C# можно найти многие основные характеристики Java:

-   основанное на классах объектно-ориентированное программирование;

-   строгая типизация;

-   поддержка интерфейсов;

-   Универсальные шаблоны

-   Сборка мусора

-   компиляция среды выполнения.

Java и C# компилируются в промежуточный язык, выполняемый в управляемой среде выполнения. C# и Java являются статически типизированными и распознают строки как неизменяемые типы.
Оба языка используют иерархию классов с одним корнем. Подобно Java, C# поддерживает только одно наследование и не позволяет использовать глобальные методы.
В этих языках объекты создаются в куче с использованием ключевого слова `new` и удаляются сборщиком мусора, когда в них больше нет необходимости. Оба языка обеспечивают официальную поддержку обработки исключений с помощью семантики `try`/`catch`, а также поддержку синхронизации и управления потоками.

Однако между этими языками есть немало различий. Пример:

-   Java не поддерживает неявно типизированные локальные переменные (C# поддерживает ключевое слово `var`).

-   В Java вы можете передавать параметры только по значению, тогда как в C# их можно передавать как по ссылке, так и по значению. (C# предоставляет ключевые слова `ref` и `out` для передачи параметров по ссылке. В Java нет эквивалентов.)

-   Java не поддерживает директивы препроцессора, например `#define`.

-   Java не поддерживает типы целого числа без знака, тогда как C# поддерживает такие типы целого числа без знака, как `ulong`, `uint`, `ushort` и `byte`.

-   Java не поддерживает перегрузку операторов. В C# вы можете перегружать операторы и преобразования.

-   В инструкции `switch` Java код может попасть в следующий раздел switch, но в C# в конце каждого раздела `switch` должен находиться переключатель (каждый раздел должен закрываться с помощью инструкции `break`).

-   В Java вы указываете исключения, создаваемые методом с ключевым словом `throws`, но в C# нет понятия проверенных исключений — ключевое слово `throws` не поддерживается в C#.

-   C# поддерживает синтаксис LINQ, который позволяет использовать зарезервированные слова `from`, `select` и `where` для написания запросов к коллекциям способом, похожим на запросы к базе данных.


Разумеется, между C# и Java имеется гораздо больше различий, которые никак нельзя рассмотреть в одной статье. Кроме того, Java и C# продолжают развиваться (например, Java 8 — версия, которой еще нет в цепочке инструментов Android, поддерживает лямбда-выражения в стиле C#), поэтому эти различия со временем будут изменяться. Здесь перечислены только самые важные отличия, с которыми в настоящее время сталкиваются разработчики Java, только начинающие изучать расширение Xamarin.Android.

-   В разделе, посвященном [переходу от разработки Java к C#](#fundamentals) приводится обзор основных различий между C# и Java.

-   В разделе, посвященном [возможностям объектно-ориентированного программирования](#oopfeatures), описываются наиболее важные объектно-ориентированные отличия между двумя языками.

-   В разделе, посвященном [различиям в ключевых словах](#keywords), приводится таблица полезных эквивалентов ключевых слов, ключевые слова только для C# и ссылки на определения ключевых слов C#.

C# предоставляет ряд основных функций Xamarin.Android, которые в настоящее время не доступны для разработчиков Java на Android. С помощью этих функций можно написать качественный код за короткий срок.

-   [Свойства](#properties) — с помощью системы свойств C# можно напрямую и безопасно получить доступ к переменным—элементам без необходимости писать методы задания и получения.

-   [Лямбда-выражения](#lambdas) — в C# можно использовать анонимные методы (также называемые*лямбдами*), чтобы более четко и эффективно выразить функции. Вы можете избежать сложностей, связанных с необходимостью писать одноразовые объекты, и передать локальное состояние методу без необходимости добавлять параметры.

-   [Обработка событий](#events) — C# обеспечивает поддержку на уровне языка для *программирования на основе событий*, где объект можно зарегистрировать для получения уведомления о соответствующем событии. Ключевое слово `event` определяет механизм многоадресного вещания, который класс издателя может использовать для уведомления подписчиков событий.

-   [Асинхронное программирование](#async) — функции асинхронного программирования C# (`async`/`await`) обеспечивают быстрое реагирование приложений.
    Поддержка этой функции на уровне языка упрощает реализацию асинхронного программирования и снижает вероятность ошибок.


И, наконец, Xamarin позволяет [использовать имеющиеся ресурсы Java](#interop) с помощью технологии *привязки*. Вы можете вызвать имеющийся Java-код, платформы и библиотеки из C# с помощью автоматических генераторов привязки Xamarin. Для этого нужно просто создать статическую библиотеку в Java и предоставить ее C# через привязку.

<a name="fundamentals" />

## <a name="going-from-java-to-c-development"></a>Переход от разработки на Java к разработке на C#

В следующих разделах описываются основные базовые различия между C# и Java. В разделе ближе к концу статьи описываются объектно-ориентированные различия между этими языками.


<a name="assemblies" />

### <a name="libraries-vs-assemblies"></a>Библиотеки и Сборки

Java обычно упаковывает связанные классы в **JAR**-файлы. Однако в C# и .NET предварительно скомпилированный код, который можно многократно использовать, упаковывается в *сборки*, которые обычно объединяются в пакет как *DLL*-файлы. Сборка — это единица развертывания кода C# или .NET. Каждая сборка обычно связана с проектом C#. Сборки содержат промежуточный код, который компилируется в среде выполнения по методу JIT.

Дополнительные сведения о сборках см. в разделе MSDN [Сборки и глобальный кэш сборок](https://msdn.microsoft.com/en-us/library/ms173099.aspx).

<a name="namespaces" />

### <a name="packages-vs-namespaces"></a>Пакеты и Пространства имен

C# использует ключевое слово `namespace`, чтобы сгруппировать связанные типы. В Java эквивалентом является ключевое слово `package`. Обычно приложение Xamarin.Android размещается в пространстве имен, созданном для него. Например, следующий код C# объявляет программу-оболочку пространства имен `WeatherApp` для приложения отправки отчетов о погоде:

```csharp
namespace WeatherApp
{
    ...
```

<a name="imports" />

### <a name="importing-types"></a>Импорт типов

Когда вы используете типы, определенные во внешних пространствах имен, вы импортируете их с помощью инструкции `using` (которая очень похожа на инструкцию `import` Java). В Java вы можете импортировать один тип с инструкцией, подобной следующей:

```java
import javax.swing.JButton
```

Вы можете импортировать весь пакет Java с помощью инструкции, подобной ниже:

```java
import javax.swing.*
```

Инструкция `using` C# работает очень схожим образом, но она позволяет вам импортировать весь пакет без указания подстановочного знака. Например, вы будете часто встречать серию инструкций `using` в начале исходных файлов Xamarin.Android, как показано в этом примере:

```csharp
using System;
using Android.App;
using Android.Content;
using Android.Runtime;
using Android.Views;
using Android.Widget;
using Android.OS;
using System.Net;
using System.IO;
using System.Json;
using System.Threading.Tasks;
```

С помощью этих инструкций импортируются функции из `System`, `Android.App`, `Android.Content` и других пространств имен.


<a name="generics" />

### <a name="generics"></a>Универсальные шаблоны

Java и C# поддерживают *универсальные шаблоны*, которые являются заполнителями, позволяющими подключаться к различным типам во время компиляции. Однако в C# универсальные шаблоны работают несколько иначе. В Java при использовании [стирания типа](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html) сведения становятся доступными только во время компиляции, а не выполнения. И напротив, среда выполнения CLR .NET обеспечивает явную поддержку универсальных типов. Это означает, что в этой среде у C# есть доступ к сведениям о типах. В повседневной разработке Xamarin.Android важность этого различия не всегда очевидна, но если вы используете [отражение](https://msdn.microsoft.com/en-us/library/ms173183.aspx), именно эта функция будет определять доступ к сведениям о типах во время выполнения.

В Xamarin.Android вы будете часто видеть универсальный метод `FindViewById`, используемый для получения ссылки на элемент управления макета. Этот метод принимает параметр универсального типа, который определяет тип элемента управления для поиска. Пример:

```csharp
TextView label = FindViewById<TextView> (Resource.Id.Label);
```

В этом примере кода метод `FindViewById` получает ссылку на элемент управления `TextView`, который определен в макете как **метка**, а затем возвращает его как тип `TextView`.

Дополнительные сведения об универсальных шаблонах см. в статье [Универсальные шаблоны (Руководство по программированию на C#)](https://msdn.microsoft.com/en-us/library/512aeb7t.aspx).
Обратите внимание, что в поддержке Xamarin.Android есть некоторые ограничения для универсальных классов C#. Дополнительные сведения см. в [этом](~/android/internals/limitations.md) разделе.


<a name="oopfeatures" />

## <a name="object-oriented-programming-features"></a>Функции объектно-ориентированного программирования

Java и C# используют очень похожие способы объектно-ориентированного программирования.

-   Все классы в конечном итоге выводятся из одного корневого объекта: все объекты Java выводятся из `java.lang.Object`, а все объекты C# — из `System.Object`.

-   Экземпляры классов являются ссылочными типами.

-   Когда вы обращаетесь к свойствам и методам экземпляра, вы используете оператор <code>.</code>.

-   Все экземпляры классов создаются в куче через оператор `new`.

-   Так как оба языка используют сборку мусора, можно явно освободить неиспользуемые объекты (например, в этих языках не используется ключевое слово `delete`, как в C++).

-   Вы можете расширять классы через наследование, и оба языка допускают только один базовый класс для каждого типа.

-   Вы можете определить интерфейсы, а класс может наследовать (например, реализовывать) функции из нескольких определений интерфейсов.

Однако есть и некоторые важные отличия.

-   Java поддерживает две эффективные функции, которые не поддерживаются в C#: анонимные классы и внутренние. (Тем не менее, C# разрешает вложение определений классов: вложенные классы C# аналогичны статическим вложенным классам Java.)

-   C# в отличие от Java поддерживает типы структуры стиля C (`struct`).

-   В C# вы можете реализовать определение класса в отдельных исходных файлах с использованием ключевого слова `partial`.

-   Интерфейсы C# не могут объявлять поля.

-   C# использует синтаксис деструктора стиля C++ для выражения методов завершения. Синтаксис отличается от метода `finalize` Java, но семантика почти одинакова. (Обратите внимание, что в C# деструкторы автоматически вызывают деструктор базового класса, в отличие от Java, где используется явный вызов `super.finalize`.)


<a name="inheritance" />

### <a name="class-inheritance"></a>Наследование классов

Чтобы расширить класс в Java, нужно использовать ключевое слово `extends`. Чтобы расширить класс в C#, нужно использовать двоеточие (`:`) для указания наследования. Например, в приложениях Xamarin.Android вы будете часто встречать наследования классов, которые напоминают фрагмент кода ниже:

```csharp
public class MainActivity : Activity
{
    ...
```

В этом примере `MainActivity` наследуется от класса `Activity`.

Чтобы объявить поддержку интерфейса в Java, нужно использовать ключевое слово `implements`. Однако в C# нужно просто добавить имена интерфейсов в список классов, которые будут использоваться для наследования, как показано в этом фрагменте кода:

```csharp
public class SensorsActivity : Activity, ISensorEventListener
{
    ...
```

В этом примере `SensorsActivity` наследуется от `Activity` и реализует функцию, объявленную в интерфейсе `ISensorEventListener`. Обратите внимание, что список интерфейсов должен следовать за базовым классом (в противном случае вы получите ошибку времени компиляции). По соглашению к именам интерфейсов C# добавляется "I" в верхнем регистре, что позволяет определить без ключевого слова `implements`, какие классы являются интерфейсами.

Если вы не хотите, чтобы в C# к классу позднее было применено наследование, имени класса должно предшествовать ключевое слово `sealed` — в Java перед именем класса нужно использовать ключевое слово `final`.

Дополнительные сведения об определениях классов C# см. в статье [Классы (Руководство по программированию на C#)](https://msdn.microsoft.com/en-us/library/x9afc042.aspx) и [этой статье](https://msdn.microsoft.com/en-us/library/x9afc042.aspx).


<a name="properties" />

### <a name="properties"></a>Свойства

В Java методы-мутаторы (методы задания) и методы-инспекторы (методы получения) часто используются для управления способами применения изменений к элементам класса со скрытием и защитой этих элементов от внешнего кода. Например, класс `TextView` Android предоставляет методы `getText` и `setText`. C# обеспечивает аналогичный, но более прямой механизм, известный как *свойства*.
Пользователи класса C# могут получить доступ к свойству так же, как они получают доступ к полю, но каждый доступ фактически приводит к вызову метода, который является прозрачным для вызывающего. Этот "неявный" метод может включать побочные эффекты, например установку других значений, выполнение преобразований или изменение состояния объекта.

Свойства часто используются для доступа к элементам объектов пользовательского интерфейса и их изменения. Пример:

```csharp
int width = rulerView.MeasuredWidth;
int height = rulerView.MeasuredHeight;
...
rulerView.DrawingCacheEnabled = true;
```

В этом примере значения ширины и высоты считываются из объекта `rulerView` путем доступа к его свойствам `MeasuredWidth` и `MeasuredHeight`. Когда эти свойства считываются, значения из их связанных (но скрытых) значений полей извлекаются в фоновом режиме и возвращаются вызывающему. В объекте `rulerView` значения ширины и высоты могут храниться в одной единице измерения (например, пикселях) и мгновенно преобразовываться в другие единицы измерения (например, миллиметры) при получении доступа к свойствам `MeasuredWidth` и `MeasuredHeight`.

У объекта `rulerView` также есть свойство с именем `DrawingCacheEnabled`. В примере кода этому свойству задается значение `true` для включения кэша документа в `rulerView`. В фоновом режиме связанное скрытое поле обновляется новым значением, и, возможно, изменяются другие аспекты состояния `rulerView`. Например, если свойству `DrawingCacheEnabled` задано значение `false`, представление `rulerView` может также удалить все сведения о кэше документа, накопленные в объекте.

Доступ к свойствам может предоставляться для чтения или записи, только для чтения или только для записи. Кроме того, вы можете использовать разные модификаторы доступа для чтения и записи. Например, вы можете определить свойство с открытым доступом на чтение, но частным доступом на запись.

Дополнительные сведения о свойствах C# см. в статье [Свойства (Руководство по программированию в C#)](https://msdn.microsoft.com/en-us/library/x9fsa0sw.aspx).


<a name="basemethods" />

### <a name="calling-base-class-methods"></a>Вызов методов базового класса

Чтобы вызвать конструктор базового класса в C#, нужно ввести двоеточие (`:`), затем добавить ключевое слово `base` и список инициализаторов. Этот вызов конструктора `base` будет следовать сразу после выходного списка его параметров. Конструктор базового класса вызывается в записи в производный конструктор. Компилятор вставляет вызов в базовый конструктор в начале текста метода. В следующем фрагменте кода показан базовый конструктор, вызванный из производного конструктора в приложении Xamarin.Android:

```csharp
public class PictureLayout : ViewGroup
{
    ...
    public class PictureLayout (Context context)
           : base (context)
    {
        ...
    }
    ...
}

```

В этом примере класс `PictureLayout` является производным от класса `ViewGroup`. Конструктор `PictureLayout`, показанный в этом примере, принимает аргумент `context` и передает его в конструктор `ViewGroup` через вызов `base(context)`.

Чтобы вызвать метод базового класса в C#, используйте ключевое слово `base`. Например, приложения Xamarin.Android часто вызывают базовые методы, как показано ниже:

```csharp
public class MainActivity : Activity
{
    ...
    protected override void OnCreate (Bundle bundle)
    {
        base.OnCreate (bundle);
```

В этом случае метод `OnCreate`, определенный производным классом (`MainActivity`), вызывает метод `OnCreate` базового класса (`Activity`).


<a name="accessmodifiers" />

### <a name="access-modifiers"></a>Модификаторы доступа

Java и C# поддерживают модификаторы доступа `public`, `private` и `protected`. Однако C# поддерживает два дополнительных модификатора доступа:

-   **`internal`** — элемент класса доступен только в текущей сборке.

-   **`protected internal`** — элемент класса доступен в определяющей сборке, определяющем классе и производных классах (внутренних и внешних производных классах, к которым у сборки есть доступ).

Дополнительные сведения о модификаторах доступа в C# см. в статье [Модификаторы доступа (Руководство по программированию в C#)](https://msdn.microsoft.com/en-us/library/ms173121.aspx).


<a name="virtualoverride" />

### <a name="virtual-and-override-methods"></a>Виртуальные методы и методы переопределения

Java и C# поддерживают *полиморфизм* — способность обрабатывать связанные объекты одинаковым образом. Для двух языков вы можете использовать ссылку базового класса для ссылки на объект производного класса, а методы производного класса могут переопределять методы базовых классов этого производного класса. Оба языка включают понятие *виртуального метода* — метода базового класса, который заменяется методом производного класса.
Как и Java, C# поддерживает классы и методы `abstract`.

Однако есть некоторые различия между Java и C#, а именно в объявлении виртуальных методов и их переопределении.

-   В C# методы по умолчанию не виртуальные. Родительские классы должны явно указывать, какие методы нужно переопределить с помощью ключевого слова `virtual`. И напротив, все методы в Java являются виртуальными методами по умолчанию.

-   В C#, чтобы предотвратить переопределение метода, вы просто не указываете ключевое слово `virtual`. В Java же для этого, напротив, нужно указать ключевое слово `final`.

-   В производных классах C# должно использоваться ключевое слово `override`, чтобы явно указать, что виртуальный метод базового класса переопределяется.

Дополнительные сведения о поддержке полиморфизма в C# см. в статье [Полиморфизм (Руководство по программированию на C#)](https://msdn.microsoft.com/en-us/library/ms173152.aspx).


<a name="lambdas" />

## <a name="lambda-expressions"></a>Лямбда-выражения

C# позволяет создавать *замыкания*: встроенные анонимные методы, с помощью которых можно получить доступ к состоянию метода, в который они вложены.
Используя лямбда-выражения, вы можете написать меньше строк кода для реализации функций, которые в Java требуют большого количества строк кода.

Лямбда-выражения позволяют пропустить дополнительный код подготовки, связанный с созданием одноразового или анонимного класса, который используется в Java. Вместо этого, вы можете просто написать бизнес-логику своего кода метода в строке. Кроме того, так как у лямбда-выражений есть доступ к переменным в окружающем методе, вам не нужно создавать длинный список параметров для передачи состояния в свой код метода.

В C# лямбда-выражения создаются с помощью оператора `=>`, как показано ниже:

```csharp
(arg1, arg2, ...) => {
    // implementation code
};
```

В Xamarin.Android лямбда-выражения часто используются для определения обработчиков событий. Пример:

```csharp
button.Click += (sender, args) => {
    clickCount += 1;    // access variable in surrounding code
    button.Text = string.Format ("Clicked {0} times.", clickCount);
};
```

В этом примере код лямбда-выражения (код в фигурных скобках) увеличивает количество щелчков и обновляет текст `button` для указания этого числа. Это лямбда-выражение регистрируется с помощью объекта `button` как обработчик событий щелчка, который будет вызываться каждый раз при нажатии кнопки. (Более подробные сведения об обработчиках событий приводятся ниже.) В этом простом примере параметры `sender` и `args` не используются кодом лямбда-выражения, но требуются этому выражению для удовлетворения требований к сигнатуре метода для регистрации событий. В сущности, компилятор C# преобразует лямбда-выражение в анонимный метод, который вызывается всякий раз при нажатии кнопки.

Дополнительные сведения о лямбда-выражениях C# см. в статье [Лямбда-выражения (Руководство по программированию в C#)](https://msdn.microsoft.com/en-us/library/bb397687.aspx).


<a name="events" />

## <a name="event-handling"></a>Обработка событий

*Событие* — это способ объекта уведомлять зарегистрированных подписчиков об интересных событиях, связанных с этим объектом. В отличие от Java, где подписчик обычно реализует интерфейс `Listener`, содержащий метод обратного вызова, C# обеспечивает поддержку на уровне языка для обработки событий через *делегаты*. *Делегат* подобен объектно-ориентированному указателю типобезопасной функции, который инкапсулирует ссылку на объект и маркер метода. Если клиентский объект хочет подписаться на событие, он создает делегат и передает его уведомляющему объекту.
Когда происходит событие, уведомляющий объект вызывает метод, представленный объектом делегата, уведомляя подписавшийся клиентский объект о событии. В C# обработчики событий — это по сути методы, вызываемые через делегаты.

Дополнительные сведения о делегатах см. в статье [Делегаты (Руководство по программированию на C#)](https://msdn.microsoft.com/en-us/library/ms173171.aspx).

В C# события являются *многоадресными*. Это означает, что о возникновении события могут быть уведомлены несколько прослушивателей. Это различие наблюдается при рассмотрении синтаксических отличий между регистрацией событий в Java и C#. В Java вы вызываете `SetXXXListener` для регистрации уведомлений о событиях. В C# вы используете оператор `+=` для регистрации уведомлений о событиях путем "добавления" своего делегата в список прослушивателей событий.
В Java для отмены регистрации вы вызываете `SetXXXListener`, а в C# вы используете оператор `-=`, чтобы вычесть делегат из списка прослушивателей.

В Xamarin.Android события часто используются для уведомления объектов, если пользователь применяет какие-либо действия к элементу управления пользовательского интерфейса. Обычно такой элемент управления содержит элементы, определенные с помощью ключевого слова `event`. Чтобы подписаться на события из этого элемента управления пользовательского интерфейса, нужно вложить свои делегаты в эти элементы.

Чтобы подписаться на событие, сделайте следующее:

1.  Создайте объект-делегат, который ссылается на метод, который должен вызываться при возникновении события.

2.  Используйте оператор `+=`, чтобы вложить делегат в событие, на которое вы подписываетесь.

В следующем примере определяется делегат (с явным использованием ключевого слова `delegate`) для подписки на событие нажатий кнопки.
Этот обработчик нажатия кнопки запускает новое действие:

```csharp
startActivityButton.Click += delegate {
    Intent intent = new Intent (this, typeof (MyActivity));
    StartActivity (intent);
};

```

Однако вы также можете использовать лямбда-выражение для регистрации событий, пропуская ключевое слово `delegate`. Пример:

```csharp
startActivityButton.Click += (sender, e) => {
    Intent intent = new Intent (this, typeof (MyActivity));
    StartActivity (intent);
};

```

В этом примере объект `startActivityButton` содержит событие, ожидающее делегат с определенной сигнатурой метода: делегат, который принимает аргументы отправителя и события и возвращает пустое значение. Однако, чтобы избежать явного определения такого делегата или его метода, мы объявляем сигнатуру метода с помощью `(sender, e)` и используем лямбда-выражение для реализации тела обработчика события.
Обратите внимание, что нам нужно объявить этот список параметров, даже если параметры `sender` и `e` не используются.

Важно помнить, что вы можете отказаться от подписки на делегат (через оператор `-=`), но не можете отказаться от подписки на лямбда-выражение. В противном случае это может привести к утечке памяти. Используйте лямбда-форму регистрации событий, только если обработчик не отменит подписку на событие.

Как правило, лямбда-выражения используются для объявления обработчиков событий в коде Xamarin.Android. Этот простой способ объявления обработчиков событий может показаться сначала непонятным, но он сокращает время написания и чтения кода. С постоянной практикой вы привыкнете распознавать этот шаблон (который часто встречается в коде Xamarin.Android), сможете уделить больше времени бизнес-логике своего приложения и сократить время изучения синтаксических операций.


<a name="async" />

## <a name="asynchronous-programming"></a>Асинхронное программирование

*Асинхронное программирование* дает возможность повысить общую скорость реагирования приложения. Функции асинхронного программирования позволяют продолжить выполнение оставшихся разделов кода приложения, в то время как часть приложения блокируется длительной операцией.
Доступ к Интернету, обработка изображений и чтение или запись файлов — примеры операций, которые могут привести к остановке приложения, если оно не написано с использованием асинхронного программирования.

C# обеспечивает поддержку (на уровне языка) асинхронного программирования с помощью ключевых слов `async` и `await`. Эти языковые функции позволяют легко писать код, который выполняет длительные задачи без блокирования основного потока приложения. Коротко говоря, вы используете в методе ключевое слово `async`, чтобы указать, что код в этом методе должен выполняться асинхронно, а не блокировать поток вызывающего. При вызове методов, помеченных `async`, будет использоваться ключевое слово `await`. Компилятор интерпретирует `await` как точку, в которой выполнение метода должно переместиться в фоновый поток (задача возвращается вызывающему). Когда эта задача завершается, выполнение кода возобновляется в потоке вызывающего в точке `await` кода, возвращая результаты вызова `async`. По правилам к именам методов, которые выполняются асинхронно, добавляется суффикс `Async`.

В приложениях Xamarin.Android `async` и `await` обычно используются, чтобы освободить поток пользовательского интерфейса для его реагирования на ввод данных пользователем (например, нажатие кнопки **Отмена**), в то время как длительная операция выполняется в фоновом задании.

В следующем примере обработчик события нажатия кнопки вызывает асинхронную операцию для загрузки изображения из Интернета:


```csharp
downloadButton.Click += downloadAsync;
...
async void downloadAsync(object sender, System.EventArgs e)
{
    webClient = new WebClient ();
    var url = new Uri ("http://photojournal.jpl.nasa.gov/jpeg/PIA15416.jpg");
    byte[] bytes = null;

    bytes = await webClient.DownloadDataTaskAsync(url);

    // display the downloaded image ...
```

В этом примере, когда пользователь щелкает элемент управления `downloadButton`, обработчик событий `downloadAsync` создает объекты `WebClient` и `Uri` для получения изображения из указанного URL-адреса. Затем с помощью этого URL-адреса он вызывает метод `DownloadDataTaskAsync` объекта `WebClient` для извлечения изображения.

Обратите внимание, что перед объявлением метода `downloadAsync` указывается ключевое слово `async` для обозначения асинхронного выполнения метода и возвращения задачи. Также обратите внимание, что вызову метода `DownloadDataTaskAsync` предшествует ключевое слово `await`. Приложение перемещает выполнение обработчика событий (начиная с точки, где появляется `await`) в фоновый поток до завершения и возвращения метода `DownloadDataTaskAsync`.
Между тем, поток пользовательского интерфейса приложения все еще может реагировать на ввод данных пользователем и запускать обработчики событий для других элементов управления. После завершения метода `DownloadDataTaskAsync` (что может занять несколько секунд) выполнение возобновляется, где переменной `bytes` задается результат вызова метода `DownloadDataTaskAsync`, а оставшаяся часть кода обработчика событий отображает загруженное изображение в потоке пользовательского интерфейса вызывающего.

Обзор `async`/`await` в C# см. в статье [Асинхронное программирование с использованием ключевых слов async и await (C# и Visual Basic)](https://msdn.microsoft.com/en-us/library/hh191443.aspx).
Дополнительные сведения о поддержке в Xamarin функций асинхронного программирования см. в [этой](~/cross-platform/platform/async.md) статье.


<a name="keywords" />

## <a name="keyword-differences"></a>Различия в ключевых словах

Многие ключевые слова, используемые в Java, также используются в C#. Имеется также ряд ключевых слов Java, которые имеют аналоги в C#, но с другими именами:

<table align="center" border="1" cellpadding="1" cellspacing="1">
  <thead>
    <th>
        <strong>Java</strong>
    </th>
    <th>
        <strong>C#</strong>
    </th>
    <th>
        <strong>Описание</strong>
    </th>
  </thead>
  <tbody>
    <tr>
      <td valign="top">
        <code>boolean</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/c8f5xwh7.aspx">bool</a>
      </td>
      <td valign="top">
Используется для объявления логических значений <code>true</code> и <code>false</code>.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>extends</code>
      </td>
      <td valign="top">
        <code>:</code>
      </td>
      <td valign="top">
Предшествует классу и интерфейсам наследования.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>implements</code>
      </td>
      <td valign="top">
        <code>:</code>
      </td>
      <td valign="top">
Предшествует классу и интерфейсам наследования.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>import</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/zhdeatwt.aspx">using</a>
      </td>
      <td valign="top">
Импортирует типы из пространства имен, также используется для создания псевдонима пространства имен.
      </td>
    </tr>
    <tr>
      <td valign="final">
        <code>final</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/88c54tsw.aspx">sealed</a>
      </td>
      <td valign="top">
Предотвращает наследование классов. Предотвращает переопределение методов и свойств в производных классах.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>instanceof</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/scekt9xw.aspx">is</a>
      </td>
      <td valign="top">
Определяет, совместим ли объект с указанным типом.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>native</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/e59b22c5.aspx">extern</a>
      </td>
      <td valign="top">
Объявляет метод, который реализуется извне.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>package</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/z2kcy19k.aspx">namespace</a>
      </td>
      <td valign="top">
Объявляет область для связанного набора объектов.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>T...</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/w5zay9db.aspx">params T[]</a>
      </td>
      <td valign="top">
Задает параметр метода, который принимает переменное количество аргументов.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <code>super</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/hfw7t1ce.aspx">base</a>
      </td>
      <td valign="top">
Используется для доступа к элементам родительского класса из производного класса.
      </td>
    </tr>
    <tr>
      <td valign="synchronized">
        <code>synchronized</code>
      </td>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/c5kehkcz.aspx">lock</a>
      </td>
      <td valign="top">
Заключает в оболочку критический раздел кода с применением и снятием блокировки.
      </td>
    </tr>
  </tbody>
</table>


Кроме того, есть много ключевых слов, уникальных для C# и не имеющих аналогов в Java. В коде Xamarin.Android часто используются следующие ключевые слова C# (эту таблицу можно использовать при чтении [примера кода](https://developer.xamarin.com/samples/android/all/) Xamarin.Android):


<table align="center" border="1" cellpadding="1" cellspacing="1">
  <thead>
    <th>
        <strong>C#</strong>
    </th>
    <th>
        <strong>Описание</strong>
    </th>
  </thead>
  <tbody>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/cscsdfbt.aspx">as</a>
      </td>
      <td valign="top">
Выполняет преобразования между совместимыми ссылочными типами или типами, допускающими значение null.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/hh156513.aspx">async</a>
      </td>
      <td valign="top">
Указывает, что метод или лямбда-выражение являются асинхронными.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/hh156528.aspx">await</a>
      </td>
      <td valign="top">
Приостанавливает выполнение метода до завершения задачи.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/5bdb6693.aspx">byte</a>
      </td>
      <td valign="top">
Тип 8-разрядного целого числа без знака.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/900fyy8e.aspx">delegate</a>
      </td>
      <td valign="top">
Используется для инкапсуляции метода или анонимного метода.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/sbbt4032.aspx">enum</a>
      </td>
      <td valign="top">
Объявляет перечисление, набор именованных констант.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/8627sbea.aspx">event</a>
      </td>
      <td valign="top">
Объявляет событие в классе издателя.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/f58wzh21.aspx">fixed</a>
      </td>
      <td valign="top">
Предотвращает перемещение переменной.
      </td>
    </tr>
    <tr>
      <td valign="top">
get </td>
      <td valign="top">
Определяет метод доступа, который извлекает значение свойства.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/dd469484.aspx">in</a>
      </td>
      <td valign="top">
Позволяет параметру принимать в универсальном интерфейсе тип с меньшей глубиной наследования.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/9kkx3h3c.aspx">object</a>
      </td>
      <td valign="top">
Псевдоним для типа <code>Object</code> в .NET Framework.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/t3c3bfhx.aspx">out</a>
      </td>
      <td valign="top">
Модификатор параметра или объявление параметра универсального типа.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/ebca9ah3.aspx">override</a>
      </td>
      <td valign="top">
Расширяет или изменяет реализацию наследованного элемента.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/6b0scde8.aspx">partial</a>
      </td>
      <td valign="top">
Объявляет определение, которое нужно разбить на несколько файлов, или отделяет определение метода от его реализации.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/acdd6hb7.aspx">readonly</a>
      </td>
      <td valign="top">
Объявляет, что элемент класса можно назначить только во время объявления или с помощью конструктора класса.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/14akc2c7.aspx">ref</a>
      </td>
      <td valign="top">
Используется для передачи аргумента по ссылке, а не по значению.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/ms228368.aspx">set</a>
      </td>
      <td valign="top">
Определяет метод доступа, который устанавливает значение свойства.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/362314fe.aspx">string</a>
      </td>
      <td valign="top">
Псевдоним для типа <code>String</code> в .NET Framework.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/ah19swz4.aspx">struct</a>
      </td>
      <td valign="top">
Тип значения, который инкапсулирует группу связанных переменных.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/58918ffs.aspx">typeof</a>
      </td>
      <td valign="top">
Получает тип объекта.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/bb383973.aspx">var</a>
      </td>
      <td valign="top">
Объявляет неявно типизированную локальную переменную.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/a1khb4f8.aspx">value</a>
      </td>
      <td valign="top">
Ссылается на значение, которое код клиента должен присвоить свойству.
      </td>
    </tr>
    <tr>
      <td valign="top">
        <a href="https://msdn.microsoft.com/en-us/library/9fkccyh4.aspx">virtual</a>
      </td>
      <td valign="top">
Позволяет переопределить метод в производном классе.
      </td>
    </tr>
  </tbody>
</table>


<a name="interop" />

## <a name="interoperating-with-existing-java-code"></a>Взаимодействие с имеющимся кодом Java

При наличии функций Java, которые вы не хотите преобразовывать в C#, вы можете повторно использовать имеющиеся библиотеки Java в приложениях Xamarin.Android с помощью двух методов.

-  **Создайте библиотеку привязок Java**. При применении этого подхода вы используете инструменты Xamarin для создания программ-оболочек C# вокруг типов Java. Эти программы-оболочки называются *привязками*. В результате с помощью вызова этих программ приложение Xamarin.Android может использовать *JAR*-файл.

-  **Используйте собственный интерфейс Java**. *Этот интерфейс (JNI)* является платформой, которая позволяет приложениям C# вызывать Java-код или реагировать на вызов, выполненный с помощью этого кода.

Дополнительные сведения об этих методах см. в статье [обзора интеграции Java](~/android/platform/java-integration/index.md).


<a name="further" />

## <a name="for-further-reading"></a>Дополнительные сведения

[Руководство по программированию C#](https://msdn.microsoft.com/en-us/library/67ef8sbd.aspx) MSDN содержит основные сведения о языке программирования C#, а [в справочнике по C#](https://msdn.microsoft.com/en-us/library/618ayhy6.aspx) вы сможете найти определенные функции.

В то время, как для изучения языка Java необходимо как минимум ознакомиться с библиотеками класса этого языка, практическая работа с C# требует предварительного знакомства с .NET Framework. Обучающий пакет Майкрософт, содержащий ресурсы о [переходе на C# и .NET Framework для Java-разработчиков](https://www.microsoft.com/en-us/download/details.aspx?id=6073), — оптимальный способ узнать больше о .NET Framework с точки зрения Java (при подробном изучении C#).

Когда вы будете готовы заняться своим первым проектом Xamarin.Android в C#, с помощью серии [Hello, Android](~/android/get-started/hello-android/index.md) вы сможете создать свое первое приложение Xamarin.Android и расширить знания основ разработки приложений Android с Xamarin.


<a name="summary" />

## <a name="summary"></a>Сводка

В этой статье содержатся общие сведения о среде программирования C# для Xamarin.Android с точки зрения разработчика Java, а также рассматриваются сходства и различия между C# и Java. В этой статье мы рассмотрели сборки и пространства имен, импорт внешних типов, а также ознакомились с обзором различий в модификаторах доступа, универсальными шаблонами, наследованием классов, вызовом методов базового класса, переопределением методов и обработкой событий. Из этого руководства мы узнали о таких функциях C#, недоступных в Java, как свойства, асинхронное программирование с ключевыми словами `async`/`await`, лямбда-выражения, делегаты C# и система обработки событий C#. Здесь также содержатся таблицы важных ключевых слов C#, приведены сведения о взаимодействии с имеющимися библиотеками Java и включены ссылки на связанную документацию для дальнейшего изучения.


## <a name="related-links"></a>Связанные ссылки

- [Java Integration Overview](~/android/platform/java-integration/index.md) (Обзор интеграции Java)
- [Руководство по программированию на C#](https://msdn.microsoft.com/en-us/library/67ef8sbd.aspx)
- [Справочник по C#](https://msdn.microsoft.com/en-us/library/618ayhy6.aspx)
- [Moving to C# and the .NET Framework, for Java Developers](https://www.microsoft.com/en-us/download/details.aspx?id=6073) (Переход на C# и .NET Framework для Java-разработчиков)
