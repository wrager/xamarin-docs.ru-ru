---
title: "Создание фрагмент"
ms.topic: article
ms.prod: xamarin
ms.assetid: F2997242-BC29-1440-7F1A-CFC447CD73FA
ms.technology: xamarin-android
author: mgmclemore
ms.author: mamcle
ms.date: 02/07/2018
ms.openlocfilehash: c1dd3495b0d7f76197126094cfd10e50d0ca760d
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="creating-a-fragment"></a>Создание фрагмент

Чтобы создать фрагмент, класс должен наследовать от `Android.App.Fragment` и затем переопределить `OnCreateView` метод. `OnCreateView` будет вызываться путем размещения действия время разместить фрагмент на экране, и вернет `View`. Типичный `OnCreateView` создаст это `View` дало бы ошибку файл макета и подключения его родительского контейнера. Характеристики контейнера важны как Android будет применять параметры макета родительского элемента к пользовательскому Интерфейсу фрагмента. Это показано в приведенном ниже примере.

```csharp
public override View OnCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
{
    return inflater.Inflate(Resource.Layout.Example_Fragment, container, false);
}
```

Приведенный выше код значительно увеличивают представление `Resource.Layout.Example_Fragment`и добавить его в качестве дочернего представления, чтобы `ViewGroup` контейнера.


> [!NOTE]
> **Примечание:** фрагмент вложенные классы должны иметь открытый стандартный конструктор без аргументов.

## <a name="adding-a-fragment-to-an-activity"></a>Добавление фрагмента в действие

Существует два способа, что фрагмент может размещаться внутри действия:

-   **Декларативно** &ndash; фрагменты можно использовать декларативно в `.axml` макет файлы с помощью `<Fragment>` тег.

-   **Программно** &ndash; фрагментов могут также создаваться динамически с помощью `FragmentManager` API-Интерфейс класса.

Программное использование через `FragmentManager` класс обсуждаются далее в этом руководстве.

### <a name="using-a-fragment-declaratively"></a>Декларативно с помощью фрагмента

Добавление фрагмента внутри макета, необходимо использовать `<fragment>` тег и затем определения фрагмента, предоставляя либо `class` атрибута или `android:name` атрибута. В следующем фрагменте показано, как использовать `class` атрибута для объявления `fragment`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<fragment class="com.xamarin.sample.fragments.TitlesFragment"
            android:id="@+id/titles_fragment"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent" />
```

Этот фрагмент Далее показано, как объявить `fragment` с помощью `android:name` атрибут для идентификации класса фрагмент:

```xml
<?xml version="1.0" encoding="utf-8"?>
<fragment android:name="com.xamarin.sample.fragments.TitlesFragment"
            android:id="@+id/titles_fragment"
            android:layout_width="fill_parent"
            android:layout_height="fill_parent" />
```

При создании действия Android создания экземпляра каждого фрагмента, указанный в файле макета и вставить представление, которое создается из `OnCreateView` вместо `Fragment` элемента.
Фрагменты, которые добавляются к действию декларативно являются статичными и будет оставаться в действии до удаления; не поддерживается для динамически замены или удаления такой фрагмент в течение времени существования действия, к которому он присоединен.

Необходимо назначить уникальный идентификатор каждому фрагменту:

-  **Android: id** &ndash; как и другие элементы пользовательского интерфейса в файл макета это уникальный идентификатор.

-  **Android: тег** &ndash; этот атрибут является уникальной строкой.

Если ни одно из предыдущих двух методов используется фрагмента предполагает идентификатор представления контейнера. В следующем примере там, где ни один `android:id` , ни `android:tag` предоставляется Android назначит идентификатор `fragment_container` на фрагмент:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:id="+@id/fragment_container"
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

        <fragment class="com.example.android.apis.app.TitlesFragment"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
</LinearLayout>
```

### <a name="package-name-case"></a>Регистр имен пакетов

Android не допускает прописные буквы в именах пакетов; она возникает исключение при попытке, которую требуется увеличить представление, если имя пакета содержит символ верхнего регистра. Однако Xamarin.Android более терпим и допускают символов верхнего регистра в пространстве имен.

Например обе следующие фрагменты будут работать с Xamarin.Android. Однако второй фрагмент приведет к `android.view.InflateException` исключение чисто Android приложение на языке Java.

```xml
<fragment class="com.example.DetailsFragment" android:id="@+id/fragment_content" android:layout_width="match_parent" android:layout_height="match_parent" />
```

OR

```xml
<fragment class="Com.Example.DetailsFragment" android:id="@+id/fragment_content" android:layout_width="match_parent" android:layout_height="match_parent" />
```


## <a name="fragment-lifecycle"></a>Фрагмент жизненного цикла

Фрагменты имеют свои собственные жизненного цикла, отчасти зависит от, но по-прежнему затрагиваемого, [жизненного цикла действия размещения](~/android/app-fundamentals/activity-lifecycle/index.md).
Например при приостановке действия, все его связанные фрагменты будут приостановлены. На следующей диаграмме показан жизненный цикл фрагмента.

[![Блок-схема, иллюстрирующая фрагмент жизненный цикл](creating-a-fragment-images/fragment-lifecycle.png)](creating-a-fragment-images/fragment-lifecycle.png)


### <a name="fragment-creation-lifecycle-methods"></a>Методы жизненного цикла создания фрагмента

В списке ниже показан поток различных обратных вызовов в жизненном цикле фрагмента, как она была создана:

-   **`OnInflate()`** &ndash; Вызывается, когда создается фрагмент в составе разметки представления. Это может вызываться сразу после декларативно создан фрагмент из файла разметки XML. Фрагмент еще не связана ни с его действием, но **действия**, **пакета**, и **AttributeSet** из представления иерархии, передаются в качестве параметров. Этот метод лучше всего использовать для синтаксического анализа **AttributeSet** и для сохранения атрибутов, который может использоваться позже фрагмент.

-   **`OnAttach()`** &ndash; Вызывается после фрагмент содержит связанных с действием. Это первый метод для запуска, когда фрагмент готов для использования. В целом фрагменты не реализует конструктор или переопределить конструктор по умолчанию. Все компоненты, которые требуются для фрагмента должен быть инициализирован в этом методе.

-   **`OnCreate()`** &ndash; Вызывается методом действия для создания фрагмента. При вызове этого метода, просмотреть иерархию размещения действия нельзя инициализировать полностью, поэтому фрагменте не следует полагаться на все части иерархии действия представления, пока не позднее в жизненном цикле фрагмента. Например не используйте этот метод для выполнения любой модификации или внести изменения в пользовательском Интерфейсе приложения. Это самое раннее время, по которому фрагмент может начать сбор данных, он должен. Этот фрагмент выполняется в потоке пользовательского интерфейса на этом этапе, таким образом избежать продолжительной обработки или выполнения, обработку в фоновом потоке. Этот метод можно пропустить, если **SetRetainInstance(true)** вызывается.
    Этот вариант будет описан более подробно ниже.

-   **`OnCreateView()`** &ndash; Создает представление фрагмента.
    Этот метод вызывается один раз действия **OnCreate()** завершении метода. На этом этапе можно безопасно взаимодействовать с иерархией представление действия. Этот метод должен возвращать представление, которое будет использоваться фрагмент.

-   **`OnActivityCreated()`** &ndash; Вызывается после **Activity.OnCreate** завершения путем размещения действия.
    Окончательные настройки интерфейса пользователя должно выполняться в данный момент.

-   **`OnStart()`** &ndash; Вызывается после возобновления работы содержащее действие. Это делает фрагмент, видимые пользователю. Во многих случаях этот фрагмент содержит код, который в противном случае будут находиться в **OnStart()** метода действия.

-   **`OnResume()`** &ndash; Это метод вызывается перед пользователь может взаимодействовать с данным фрагментом последним. Пример типа кода, которое должно выполняться в этом методе бы Включение возможности устройства, пользователь может взаимодействовать с, таких как камеры, служб обнаружения расположения. Службы, такие может привести к стока чрезмерного батареи, и приложение должно оптимизировать их использования для сохранения времени работы батареи.


### <a name="fragment-destruction-lifecycle-methods"></a>Методы жизненного цикла удаления фрагмента

Далее объяснены методов жизненного цикла, которые вызываются при уничтожении фрагмент:

-   **`OnPause()`** &ndash; Пользователь больше не может взаимодействовать с данным фрагментом. Такой ситуации существует, поскольку некоторые другие операции фрагментирования изменяет этот фрагмент или приостановки действия размещения. Это возможно, действия, размещение этого фрагмента по-прежнему могут быть видны, то есть действие находится в фокусе частично прозрачный или не занимает весь экран. Когда этот метод становится активным, это первое Указание, что пользователь покидает фрагмента. Фрагмент должен сохранить внесенные изменения.

-   **`OnStop()`** &ndash; Фрагмент больше не отображается. Узел действия может быть остановлен или операции фрагментирования изменяет его в действии. Этот обратный вызов выполняет те же функции, как **Activity.OnStop**.

-   **`OnDestroyView()`** &ndash; Этот метод вызывается, чтобы очистить ресурсы, связанные с представлением. Вызывается, если это представление, связанное с данным фрагментом был удален.

-   **`OnDestroy()`** &ndash; Этот метод вызывается, когда фрагмент больше не используется. Все еще связан с действием, но этот фрагмент не работает. Этот метод должен освободить все ресурсы, используемые фрагментом, таких как [ **SurfaceView** ](https://developer.xamarin.com/api/type/Android.Views.SurfaceView/) может использоваться для веб-камеры. Этот метод можно пропустить, если **SetRetainInstance(true)** вызывается. Этот вариант будет описан более подробно ниже.

-   **`OnDetach()`** &ndash; Этот метод вызывается непосредственно перед фрагмента больше не связана с действием. Просмотр иерархии фрагмента больше не существует, и на этом этапе необходимо освободить все ресурсы, используемые фрагментом.


### <a name="using-setretaininstance"></a>С помощью SetRetainInstance

Это возможно для фрагмента указать, что оно не должно быть уничтожено полностью, если действие повторно создается. `Fragment` Класс предоставляет метод `SetRetainInstance` для этой цели. Если `true` передается этому методу, при перезапуске действие будет использоваться один и тот же экземпляр фрагмента. Если это происходит, то все методы обратного вызова будет вызываться за исключением `OnCreate` и `OnDestroy` обратные вызовы жизненного цикла. Этот процесс показан на рисунке жизненного цикла (с зеленым пунктирными линиями).


## <a name="fragment-state-management"></a>Управление состоянием фрагмента

Фрагменты может сохранять и восстанавливать их состояние во время жизненного цикла фрагмента с помощью экземпляра `Bundle`. Пакет позволяет фрагмента сохранить данные в виде пар "ключ значение" и полезна для простых данных, который не требует большого объема памяти. Фрагмент может сохранять свое состояние с помощью вызова `OnSaveInstanceState`:

```csharp
public override void OnSaveInstanceState(Bundle outState)
{
    base.OnSaveInstanceState(outState);
    outState.PutInt("current_choice", _currentCheckPosition);
}
```

При создании нового экземпляра фрагмента состоянием, сохраненным в `Bundle` получают доступ к новому экземпляру через `OnCreate`, `OnCreateView`, и `OnActivityCreated` методы нового экземпляра.
В следующем образце показано, как получить значение `current_choice` из `Bundle`:

```csharp
public override void OnActivityCreated(Bundle savedInstanceState)
{
    base.OnActivityCreated(savedInstanceState);
    if (savedInstanceState != null)
    {
        _currentCheckPosition = savedInstanceState.GetInt("current_choice", 0);
    }
}
```

Переопределение `OnSaveInstanceState` имеет соответствующий механизм для сохранения временных данных в фрагменте через ориентации изменения, такие как `current_choice` значение в приведенном выше примере. Однако реализация по умолчанию `OnSaveInstanceState` отвечает за сохранение временных данных в пользовательском Интерфейсе для каждого представления, присвоен идентификатор. Например, рассмотрим приложение, имеющее `EditText` элемент, определенный в формате XML следующим образом:

```xml
<EditText android:id="@+id/myText"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"/>
```

Поскольку `EditText` управления имеет `id` назначено, этот фрагмент автоматически сохраняет данные в мини-приложении при `OnSaveInstanceState` вызывается.


### <a name="bundle-limitations"></a>Ограничения пакета

Хотя использование `OnSaveInstanceState` делает его легко сохраните временных данных, используйте этот метод имеет некоторые ограничения:

-  Если этот стек не добавляется этот фрагмент, то его состояние не будут восстановлены, когда пользователь нажимает **обратно** кнопки.

-  При использовании пакета для сохранения данных сериализуется этих данных. Это может привести к задержки.


## <a name="contributing-to-the-menu"></a>Дополнение к меню

Фрагментов может привести элементов меню их размещения действия.
Действие сначала обрабатывает пунктов меню. Если действие не имеет обработчика, затем событие будет передан фрагмента, который затем будет обрабатывать.

Добавление элементов в меню "действие", фрагмент необходимо выполнить два действия.
Во-первых, этот фрагмент необходимо реализовать метод `OnCreateOptionsMenu` и поместите его элементов в меню, как показано в следующем коде:

```csharp
public override void OnCreateOptionsMenu(IMenu menu, MenuInflater menuInflater)
{
    menuInflater.Inflate(Resource.Menu.menu_fragment_vehicle_list, menu);
    base.OnCreateOptionsMenu(menu, menuInflater);
}
```

В приведенном выше фрагменте кода меню увеличивается из следующий XML-код, который находится в файле `menu_fragment_vehicle_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
  <item android:id="@+id/add_vehicle"
        android:icon="@drawable/ic_menu_add_data"
        android:title="@string/add_vehicle" />
</menu>
```

После этого необходимо вызвать фрагмент `SetHasOptionsMenu(true)`. Вызов этого метода сообщает Android, что фрагмент имеет пункты меню для пополнения параметр меню. Том случае, если вызов этого метода, пункты меню для фрагмента не добавить параметр меню действия. Обычно это делается в методе жизненного цикла `OnCreate()`, как показано в следующем фрагменте кода:

```csharp
public override void OnCreate(Bundle savedState)
{
    base.OnCreate(savedState);
    SetHasOptionsMenu(true);
}
```

На следующем рисунке показано, как будет выглядеть это меню:

[![Снимок экрана примера приложения My приема-передачи, отображение пунктов меню](creating-a-fragment-images/fragment-menu-example.png)](creating-a-fragment-images/fragment-menu-example.png)
