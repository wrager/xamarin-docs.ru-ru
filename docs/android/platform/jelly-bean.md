---
title: Функции быть, с ягодами jelly
description: 'В этом документе предоставит общий обзор новых возможностей для разработчиков, которые впервые появились в Android 4.1. Эти возможности включают: расширенный уведомления, обновления для Android луч для совместного использования больших файлов мультимедиа, одноранговая сеть сетевого обнаружения, анимацию, новые разрешения обновлений.'
ms.prod: xamarin
ms.assetid: 23F57634-2EF9-5C15-C710-B3E19A5AF7E1
ms.technology: xamarin-android
author: mgmclemore
ms.author: mamcle
ms.date: 03/01/2018
ms.openlocfilehash: 1d8068ccfc8d0f159a88704370261ec5f20d8b7c
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="jelly-bean-features"></a>Функции быть, с ягодами jelly

_В этом документе предоставит общий обзор новых возможностей для разработчиков, которые впервые появились в Android 4.1. Эти возможности включают: расширенный уведомления, обновления для Android луч для совместного использования больших файлов мультимедиа, одноранговая сеть сетевого обнаружения, анимацию, новые разрешения обновлений._



## <a name="overview"></a>Обзор

Android 4.1 (уровень API 16), также известный как «Jelly быть, с ягодами», был 9 июля 2012 г. Это статье приводятся вводные сведения верхнего уровня в некоторые новые возможности в Android 4.1 для разработчиков, использующих Xamarin.Android. Некоторые из этих новых функций, усовершенствования анимации для запуска действия, новые звуковые файлы для веб-камеры, а также улучшенную поддержку стек навигации приложения. Теперь возможна для вырезания и вставки с помощью целей.

Стабильность приложений Android повышается возможность изолировать зависимость от работает нестабильно поставщиков содержимого. Службы также могут быть изолированной, чтобы они были доступны только действием, их запуска.

Добавлена поддержка для обнаружения службы сети с помощью Bonjour UPnP и многоадресной рассылки DNS на основе служб. Теперь можно более подробная уведомлений, формат которых задан текст, кнопки и большие изображения.

Finally в Android 4.1 добавлены несколько новых разрешений.



## <a name="requirements"></a>Требования

Для разработки приложений Xamarin.Android использование Jelly быть, с ягодами требует Xamarin.Android 4.2.6 или более поздней версии и Android 4.1 (уровень API 16) быть установлены через диспетчер Android SDK, как показано на следующем снимке экрана:

[![Выбор в диспетчере Android SDK Android 4.1](jelly-bean-images/image1.png)](jelly-bean-images/image1.png#lightbox)



## <a name="whats-new"></a>Новые возможности



### <a name="animations"></a>Анимации

Действия можно запустить с помощью анимации масштаба или пользовательской анимации `ActivityOptions` класса. Для поддержки этих анимаций предусмотрены следующие новые методы:

-   `MakeScaleUpAnimation` — Это создаст анимации, которая масштабируется окно действия из начальное положение и размер на экране.
-   `MakeThumbnailScaleUpAnimation` — Это создаст анимации, которая масштабируется из эскиз из указанной позиции на экране.
-   `MakeCustomAnimation` — Это создает анимацию из ресурсов приложения. Имеется одна анимация для при открытии действия и другой для остановки действия.


Новый `TimeAnimator` класс предоставляет интерфейс `TimeAnimator.ITimeListener` , уведомлять приложение, каждый раз при изменении кадра анимации. Например, рассмотрим следующие реализации `TimeAnimator.ITimeListener`:

```csharp
class MyTimeListener : Java.Lang.Object,  TimeAnimator.ITimeListener
{
    public void OnTimeUpdate(TimeAnimator animation, long totalTime, long deltaTime)
    {
        Log.Debug("Activity1", "totalTime={0}, deltaTime={1}", totalTime, deltaTime);
    }
}
```

Теперь с помощью класса, экземпляр `TimeAnimator` создается, и задайте прослушиватель:

```csharp
var animator = new TimeAnimator();
animator.SetTimeListener(new MyTimeListener());
animator.Start();
```

Как `TimeAnimator` экземпляр запущен, он будет вызывать `ITimeAnimator.ITimeListener`, который затем следует войти как долго animator была запущена и как долго его как была со времени последнего метод был вызван.



### <a name="application-stack-navigation"></a>Стек навигации приложения

Стек навигации приложения, появившихся в Android 3.0 расширяет Android 4.1. Указав `ParentName` свойство `ActivityAttribute`, Android можно открыть правильную родительского действия, когда пользователь нажимает [кнопка](http://developer.android.com/design/patterns/navigation.html#up-vs-back) на панели действий - Android будет создавать действия, заданные `ParentName`свойство. Это позволяет приложениям сохранять иерархии действий, которые делают данной задачи.

Для установки большинства приложений `ParentName` в действии является достаточно сведений для Android для обеспечения правильного поведения для навигации в стек приложения; Android будет синтезировать необходимые стек путем создания ряда целей для каждого родительского действия. Тем не менее так как стек искусственный приложения, каждое действие искусственных не будет сохраненное состояние, естественным действие будет иметь. Для формирования сохраненное состояние искусственных родительскому действию, может переопределить действия `OnPrepareNavigationUpTaskStack` метод. Этот метод получает `TaskStackBuilder` экземпляр, который будет содержать набор целей объектов, Android будет использоваться для создания стека назад. Действие может изменять этих целей, чтобы при создании искусственной действия, он получит сведения правильное состояние.

Для более сложных сценариев существует новые методы в классе действия, которые могут использоваться для обработки поведения навигации и создания назад стека.

-   `OnNavigateUp` — Путем переопределения этого метода можно выполнять пользовательские действия при <span class="ui">копирование</span> нажатии кнопки.
-   `NavigateUpTo` — Вызов этого метода приводит к созданию приложения перехода от текущего действия к действию, определяемое заданной цели.
-   `ParentActivityIntent` — Используется для получения цели, которая будет открываться родительское действие текущего действия.
-   `ShouldUpRecreateTask` — Этот метод используется для запроса, если синтетические стек должны быть созданы перейти к родительским действием. Возвращает `true` Если синтетические стек должен быть создан. 
-   `FinishAffinity` — Вызов этого метода завершится текущее действие и все действия ниже в текущей задаче, имеют ту же территориальную задачи.
-   `OnCreateNavigateUpTaskStack` — Этот метод переопределяется, когда необходимо обеспечить полный контроль над созданием искусственного стека.




### <a name="camera"></a>Камера

Имеется новый интерфейс `Camera.IAutoFocusMoveCallback`, который может использоваться для обнаружения начала или остановить перемещение фокуса автоматически. Пример этого нового интерфейса можно увидеть в следующем фрагменте:

```csharp
public class AutoFocusCallbackActivity : Activity, Camera.IAutoFocusCallback
{
    public void OnAutoFocus(bool success, Camera camera)
    {
        // camera is an instance of the camera service object.

        if (success)
        {
            // Auto focus was successful - do something here.
        }
        else
        {
            // Auto focus didn't happen for some reason - react to that here.
        }
    }
}
```

Новый класс `MediaActionSound` предоставляет набор API-Интерфейсы для создания звуков для различных действий носителя. Существует несколько действий, которые могут возникнуть с камеры, они определяются перечислением `Android.Media.MediaActionSoundType`:

-   `MediaActionSoundType.FocusComplete` — Это звук воспроизводится при завершении сосредоточиться.
-   `MediaActionSoundType.ShutterClick` — Этот звук воспроизводится при переводе снимка изображения.
-   `MediaActionSoundType.StartVideoRecording` — Этот звук используется указывают на начало записи видео.
-   `MediaActionSoundType.StopVideoRecording` — Для указания на конец записи видео воспроизводится звук этот.


Пример использования `MediaActionSound` класса можно увидеть в следующем фрагменте кода:

```csharp
var mediaActionPlayer = new MediaActionSound();

// Preload the sound for a shutter click.
mediaActionPlayer.Load(MediaActionSoundType.ShutterClick);
var button = FindViewById<Button>(Resource.Id.MyButton);

// Play the sound on a button click.
button.Click += (sender, args) => mediaActionPlayer.Play(MediaActionSoundType.ShutterClick);

// This releases the preloaded resources. Don’t make any calls on
// mediaActionPlayer after this.
mediaActionPlayer.Release();
```



### <a name="connectivity"></a>Подключение



#### <a name="android-beam"></a>Android луч.

Android луч — это технология на основе NFC, которая позволяет взаимодействовать друг с другом два Android устройства. Android 4.1 реализована Улучшенная поддержка для передачи больших файлов. При использовании нового метода `NfcAdapter.SetBeamPushUris()` Android будут переключаться между альтернативный транспортные механизмы (например, Bluetooth) для достижения скорости быстрой передачи.



#### <a name="network-services-discovery"></a>Сетевое обнаружение служб

Android 4.1 содержит новые API для обнаружения службы многоадресной рассылки на основе DNS.
Это позволяет приложению для обнаружения и подключения по Wi-Fi для других устройств, таких как принтеры, камеры и мультимедийных устройств. Эти новые API находятся в `Android.Net.Nsd` пакета.

Чтобы создать службу, которая может использоваться другими службами `NsdServiceInfo` класс используется для создания объекта, который будет определять свойства службы. Этот объект затем передается `NsdManager.RegisterService()` вместе с реализацией `NsdManager.ResolveListener`. Реализации `NsdManager.ResolveListener` используются сообщать об успешной регистрации и отмены регистрации службы.

Для обнаружения служб в сети и реализация `Nsd.DiscoveryListener` передаваемый `NsdManager.discoverServices()`.



#### <a name="network-usage"></a>Использование сети

Новый метод `ConnectivityManager.IsActiveNetworkMetered` позволяет проверить, если он подключен к сети отслеживаемой устройства. Этот метод можно использовать для управления использованием данных, точно информирования пользователей о том, что может быть ресурсоемким расходов для операций с данными.



#### <a name="wifi-direct-service-discovery"></a>Обнаружение службы Wi-Fi Direct

`WifiP2pManager` Класс впервые появился в Android 4.0 для поддержки *zeroconf*. Zeroconf (ноль конфигурации сеть) — это набор методов, позволяющий устройства (компьютеры, принтеры, телефоны) автоматически, подключаться к сетям вмешательства человека сетевых операторов или особые конфигурации серверов.

В быть, с ягодами Jelly `WifiP2pManager` можно поиск ближайших устройств с помощью либо *Bonjour* или *Upnp*. Bonjour — реализация Apple zeroconf. Это набор сетевых протоколов, которые также поддерживает zeroconf UPnP. Добавлены следующие методы `WiFiP2pManager` для поддержки обнаружения службы Wi-Fi:

-   `AddLocalService()` — Этот метод используется сообщить о том, как служба приложения по Wi-Fi для обнаружения узлами.
-   `AddServiceRequest(` ) — Этого метода отправляется запрос обнаружения службы для платформы. Он используется для инициализации службы обнаружения Wi-Fi.
-   `SetDnsSdResponseListeners()` — Этот метод используется для регистрации обратных вызовов, вызываемый при получении ответа на запросы обнаружения от Bonjour.
-   `SetUpnpServiceResponseListener()` — Этот метод используется для регистрации обратных вызовов, вызываемый при получении ответа на запросы обнаружения Upnp.




### <a name="content-providers"></a>Поставщики содержимого

`ContentResolver` Класс получил новый метод `AcquireUnstableContentProvider`. Этот метод позволяет приложению получить поставщик содержимого «нестабильной». Как правило когда приложение получает поставщика содержимого и аварийно завершает работу, поставщика содержимого, поэтому будет приложение. Для вызова этого метода приложение не произойдет сбой в случае отказа поставщика содержимого. Вместо этого `Android.OS.DeadObjectionException` будет создано из вызовов для поставщика содержимого для оповещения приложения, которое поставщик содержимого исчезла. Поставщик содержимого «нестабильной» полезно при взаимодействии с поставщиками содержимого из других приложений — это менее вероятно, что дефектный код из другого приложения будет влиять на другое приложение.



### <a name="copy-and-paste-with-intents"></a>Копирование и вставку целей

`Intent` Класс теперь может иметь `ClipData` объект, связанный с ней через `Intent.ClipData` свойство. Этот метод позволяет дополнительные данные из буфера обмена для передачи с целью. Экземпляр `ClipData` может содержать один или несколько `ClipData.Item`. `ClipData.Item`элемента являются элементами из следующих типов:

-   **Текст** — это любая строка текста, либо HTML или распространяется на любую строку, формат которого поддерживается Android встроенный стиль.
-  **Назначение** — любое `Intent` объекта.
-   **URI** — это может быть любой URI, таких как HTTP закладки или URI для поставщика содержимого.




### <a name="isolated-services"></a>Изолированное служб

Изолированной службы является служба, которая выполняется в собственном процессе специальные и не имеет разрешений свои собственные. Только связь со службой, когда запуске службы и привязка к нему через API-Интерфейс службы. Можно объявить службу как изолированное, присвоив свойству `IsolatedProcess="true"` в `ServiceAttribute` , используемая для оформления класса службы.


### <a name="media"></a>Мультимедиа

Новый `Android.Media.MediaCodec` класс предоставляет API для кодеки низкоуровневые носителя. Приложения могут запрашивать системы, чтобы получить сведения о кодеках низкого уровня на устройстве.

Новый `Android.Media.Audiofx.AudioEffect` подклассов были добавлены для поддержки дополнительных аудио предварительной обработки на отслеживаемых аудио:

-   `Android.Media.Audiofx.AcousticEchoCanceler` – Этот класс используется для предварительной обработки аудио для удаления из удаленной стороной из записанных звуковых сигналов сигнала. Например удаление echo из приложения голосовой связи.
-   `Android.Media.Audiofx.AutomaticGainControl` – Этот класс используется для нормализации записанного сигнала повышение или понижение входного сигнала, чтобы выходной сигнал является константой.
-   `Android.Media.Audiofx.NoiseSuppressor` — Это класс приведет к удалению фоновых шумов из отслеживаемых сигнала.


Не все устройства поддерживают эти эффекты. Метод `AudioEffect.IsAvailable` должен вызываться приложением для того, поддерживается ли аудио рассматриваемой эффект на устройстве, работающим с приложением.

`MediaPlayer` Класс теперь поддерживает воспроизведение неперекрывающееся с `SetNextMediaPlayer()` метод. Это новый метод задает Далее MediaPlayer, чтобы запустить текущий проигрыватель по завершении его воспроизведения.

Ниже новых классов предоставляют стандартные механизмы и пользовательский Интерфейс для выбора, где воспроизводить мультимедиа:

-   `MediaRouter` – Этот класс позволяет приложениям для управления маршрутизацией мультимедиа каналы с любого устройства для внешние динамики и другие устройства.
-   `MediaRouterActionProvider` и `MediaRouteButton` — эти классы позволяют обеспечить согласованность пользовательского интерфейса при выборе и воспроизведение мультимедиа.




### <a name="notifications"></a>Уведомления

Android 4.1 позволяет приложениям, большую гибкость и элемент управления отображать уведомления. Приложения может отображать больше и лучше уведомления для пользователей. Новый метод `NotificationBuilder.SetStyle()` позволяет для одного из новых три новый стиль для уведомлений:

-   `Notification.BigPictureStyle` — Это вспомогательный класс, который будет создавать уведомления, которые будут иметь изображения в них. На рисунке показан пример уведомления с больших изображений.


 [![Снимок экрана примера BigPictureStyle уведомления](jelly-bean-images/image2.png)](jelly-bean-images/image2.png#lightbox)

-   `Notification.BigTextStyle` — Это вспомогательный класс, который будет создавать уведомления, которые будут иметь несколько строк текста, такие как электронная почта. На следующем снимке экрана можно увидеть пример стиля новый уведомления:


 [![Снимок экрана примера BigTextStyle уведомления](jelly-bean-images/image3.png)](jelly-bean-images/image3.png#lightbox)

-   `Notification.InboxStyle` — Это вспомогательный класс, который будет создавать уведомления, которые содержат список строк, таких как фрагменты из сообщения электронной почты, как показано на этом снимке экрана:


 [![Снимок экрана примера Notification.InboxStyle уведомления](jelly-bean-images/image4.png)](jelly-bean-images/image4.png#lightbox)

Это можно добавить кнопки до двух действий в нижней части сообщения уведомления, когда для уведомления используется стиль Обычный или больше.
Пример этого можно увидеть на следующем снимке экрана, где отображаются кнопки действий в нижней части уведомления:

 [![Снимок экрана примера действие кнопок, отображаемых ниже уведомление](jelly-bean-images/image5.png)](jelly-bean-images/image5.png#lightbox)

`Notification` Класс получил новый константы, которые позволяют разработчику указать одно из пяти уровней приоритета для уведомления. Они могут быть установлены для уведомления при помощи `Priority` свойство.



### <a name="permissions"></a>Разрешения

Были добавлены следующие новые разрешения:

-   `READ_EXTERNAL_STORAGE` -Приложению требуется доступом только для чтения во внешнее хранилище. В настоящее время все приложения имеют доступ на чтение по умолчанию, но требуют будущие выпуски Android приложения явно запросить доступ для чтения.
-   `READ_USER_DICTIONARY` -Разрешает доступ на чтение словарь пользователя.
-   `READ_CALL_LOG` -Позволяет приложению получить сведения о входящих и исходящих вызовов путем чтения журналов вызова.
-   `WRITE_CALL_LOG` -Позволяет приложению записывать в журнал вызовов на телефоне.
-   `WRITE_USER_DICTIONARY` -Позволяет приложению для записи в словарь пользователя.


Важные изменения в Обратите внимание `READ_EXTERNAL_STORAGE` — в настоящее время это разрешение предоставляется автоматически системой Android. Будущие версии Android потребуется приложения, чтобы запросить это разрешение, прежде чем предоставить разрешение.



## <a name="summary"></a>Сводка

В этой статье появился ряд новых API-Интерфейсов, которые доступны в Android 4.1 (уровень API 16). Он выделяются некоторые изменения для анимации и анимации запуска действия, а также появился новый API-Интерфейсов для обнаружения сетевых ресурсов других устройств, с помощью протоколов, таких как Bonjour или UPnP. Другие изменения в API были выделены цветом, такие как возможность вырезание и вставка данных с помощью целей, возможность использования изолированного служб или поставщиками содержимого в «нестабильной».

В этой статье затем пытался внести обновления на уведомления и рассматриваются некоторые новые разрешения, которые были введены с Android 4.1


## <a name="related-links"></a>Связанные ссылки

- [Пример анимации времени (пример)](https://developer.xamarin.com/samples/monodroid/PlatformFeatures/TimeAnimatorExample/)
- [Android 4.1 API-интерфейсы](http://developer.android.com/about/versions/android-4.1.html)
- [Задачи и стеки назад](http://developer.android.com/guide/components/tasks-and-back-stack.html)
- [Навигация назад и вверх](http://developer.android.com/design/patterns/navigation.html)
