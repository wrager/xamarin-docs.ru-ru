---
title: Архитектура Xamarin.Mac
description: В этом руководстве рассматриваются способы Xamarin.Mac и его связь для Objective-C на низком уровне. Здесь также описаны концепции, как компиляции, селекторы, регистраторов, запустить приложение и генератора.
ms.prod: xamarin
ms.assetid: 74D1FF57-4F2A-4646-8669-003DE99671D4
ms.technology: xamarin-mac
author: bradumbaugh
ms.author: brumbaug
ms.date: 04/12/2017
ms.openlocfilehash: d6d7557fed5ea0ca0719dcbddbda316340645320
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="xamarinmac-architecture"></a>Архитектура Xamarin.Mac

_В этом руководстве рассматриваются способы Xamarin.Mac и его связь для Objective-C на низком уровне. Здесь также описаны концепции, как компиляции, селекторы, регистраторов, запустить приложение и генератора._

## <a name="overview"></a>Обзор

Xamarin.Mac приложения выполняются в среде Mono и использовать Xamarin компилятора для компиляции до промежуточного языка (IL), который затем является только по требованию (JIT) скомпилированы в машинный код во время выполнения. Эта процедура выполняется side-by-side для среды выполнения C к цели деятельности организации. Обе эти среды выполнения работающие поверх ядра UNIX-подобные, в частности XNU и предоставлять различные интерфейсы API для пользовательского кода, благодаря чему разработчики могут получить доступ к базовой системы машинного или управляемого.

На схеме ниже показан общий обзор этой архитектуры:

[![Схема, показывающая общий обзор архитектуры](architecture-images/mac-arch.png "схема, показывающая общий обзор архитектуры")](architecture-images/mac-arch-large.png#lightbox)

### <a name="native-and-managed-code"></a>Машинного и управляемого кода

При разработке для Xamarin условия *собственного* и *управляемых* кода часто используются. Управляемый код — это код, выполнение под управлением .NET Framework Common Language Runtime или в случае Xamarin: Mono среды выполнения.

Машинный код является код, который будет запускать на конкретную платформу (например, Objective-C или даже AOT компилируются в код, на микросхеме ARM). В этом руководстве рассматривается механизм управляемый код компилируется в машинный код и объясняется, как работает приложение Xamarin.Mac, интенсивно использовать API-интерфейсы Mac Apple с помощью привязки, имея доступ к. В NET BCL и сложные языка, например C#.

## <a name="requirements"></a>Требования

Для разработки приложения macOS с помощью Xamarin.Mac macOS требуется следующее:

- Выполнение macOS Mac Сьерра (10.12) или более поздней.
- Последнюю версию Xcode (установить из [App Store](https://itunes.apple.com/us/app/xcode/id497799835?mt=12))
- Последнюю версию Visual Studio для Mac и Xamarin.Mac

Для запуска приложений Mac, созданных с помощью Xamarin.Mac, необходимо выполнить следующие системные требования:

- Mac под управлением Mac OS X 10,7 или выше.

## <a name="compilation"></a>.NET

При компиляции любого приложения платформа Xamarin компилятора моно C# (или F #) может работать и будет компиляции кода C# и F # в промежуточный язык Microsoft (MSIL или IL). Затем используется Xamarin.Mac *непосредственно в Time (JIT)* компилятора во время выполнения для компиляции машинного кода, позволяя выполнения для корректной архитектуры, при необходимости.

Это отличается от Xamarin.iOS, использующий AOT компиляции. При использовании компилятора AOT, все сборки, а также все методы в них компилируются во время построения. С помощью JIT-компилятора компиляция происходит по требованию только для методов, которые выполняются.

С приложениями Xamarin.Mac моно обычно встраивается в пакет приложения (и называется **внедренные моно**). При использовании классический API Xamarin.Mac, приложение может использовать вместо **моно системы**, однако это не поддерживается в единой API. Моно системы ссылается Mono, который был установлен в операционной системе. При запуске приложения Xamarin.Mac приложение будет использовать.

## <a name="selectors"></a>Селекторы

С помощью Xamarin, у нас есть два отдельных экосистемы .NET и Apple, что нам нужно перевести вместе, чтобы казаться как упрощенный, как можно точнее, чтобы убедиться, что конечная цель — для удобства пользователей. Мы видели в разделе выше способ связи двух сред выполнения и очень хорошо нередко термина «привязки», позволяющего собственных API Mac для использования в Xamarin. Привязки рассматриваются в глубину в [документации привязки Objective-C](~/mac/platform/binding.md), поэтому теперь давайте рассмотрим, как работает Xamarin.Mac за кулисами.

Во-первых есть ли способ предоставления Objective-C, в C#, который делается с помощью селектора. Список выбора — это сообщение, отправленных на объект или класс. С целью C это делается посредством [objc_msgSend](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html) функции. Дополнительные сведения об использовании селекторы посвящены iOS [Objective-C селекторы](~/ios/internals/objective-c-selectors.md) руководства. Также есть ли способ предоставления управляемого кода Objective-C, который намного сложнее тем, что Objective-C не знает, что-либо об управляемом коде. Чтобы обойти эту проблему, мы используем [регистратора](~/mac/internals/registrar.md). Это более подробно в следующем разделе.

## <a name="registrar"></a>регистратор

Как упоминалось выше, регистратор кода, предоставляет управляемому коду цель-C. Это делается путем создания списка любого управляемого класса, производного от NSObject:

- Для всех классов, которые не являются упаковки существующий класс Objective-C, он создает новый класс Objective-C с зеркального отображения все управляемые элементы, которые имеют члены Objective-C `[Export]` атрибута.
- В реализациях для каждого члена Objective-C код для вызова зеркальных управляемого элемента добавляется автоматически.

Ниже псевдокоде показан пример как это сделать:

**C# (управляемый код):**

```csharp
class MyViewController : UIViewController{
    [Export ("myFunc")]
    public void MyFunc ()
    {
    }
 }
 ```

**Objective-C (машинный код):**

```objc
@interface MyViewController : UIViewController
 - (void)myFunc;
@end 

@implementation MyViewController
- (void)myFunc {
    // Code to call the managed C# MyFunc method in MyViewController
}
@end
```

Управляемый код может содержать атрибуты `[Register]` и `[Export]`, использующий регистратора знать, что объект должен предоставляться цель-C. Атрибут [регистрация] используется для указания имени созданного класса Objective-C, в случае, если имя создаются по умолчанию не подходит. Все классы, производные от NSObject автоматически регистрируются с целью-C. Обязательный атрибут [экспорта] содержит строку, которая будет использовать в созданном классе Objective-C селектором.

Существует два типа используется в Xamarin.Mac — динамических и статических регистраторов:

- Динамические регистраторов — это регистратора по умолчанию для всех Xamarin.Mac построений. Динамические регистратора выполняет регистрацию всех типов в сборку во время выполнения. Это делается с помощью функций, предоставляемых средой выполнения Objective-C API. Таким образом, динамические регистратора имеет медленнее запуска, но более быстрое время сборки. При использовании динамического регистраторов, собственных функций (обычно в C), вызывается trampolines, используются в качестве реализации метода. Они отличаются в разных архитектур.
- Статические регистраторов — статический регистратора приводит к возникновению ошибки кода Objective-C во время построения, который затем компилируется в статическую библиотеку и связанных в исполняемый файл. Это позволяет для быстрого запуска, но занимает больше времени, во время построения.

## <a name="application-launch"></a>Запуск приложения

Логика запуска Xamarin.Mac будут отличаться в зависимости от ли внедренных или используется система Mono. Чтобы просмотреть код и шаги для запуска приложений Xamarin.Mac, обратитесь к [запуска заголовок](https://github.com/xamarin/xamarin-macios/blob/master/runtime/xamarin/launch.h) файл в репозитории открытого xamarin macios.

## <a name="generator"></a>Generator

Xamarin.Mac содержит определения для каждого Mac API. Можно выполнять поиск любого из этих элементов на [MaciOS в репозитории github](https://github.com/xamarin/xamarin-macios/tree/master/src). Эти определения содержат интерфейсов с помощью атрибутов, а также все необходимые методы и свойства. Например, следующий код является используется для определения NSBox в [AppKit имен](https://github.com/xamarin/xamarin-macios/blob/master/src/appkit.cs#L1465-L1526). Обратите внимание, что он является интерфейсом ряд методов и свойств:

```csharp
[BaseType (typeof (NSView))]
public interface NSBox {

        …

        [Export ("borderRect")]
        CGRect BorderRect { get; }

        [Export ("titleRect")]
        CGRect TitleRect { get; }

        [Export ("titleCell")]
        NSObject TitleCell { get; }

        [Export ("sizeToFit")]
        void SizeToFit ();

        [Export ("contentViewMargins")]
        CGSize ContentViewMargins { get; set; }

        [Export ("setFrameFromContentFrame:")]
        void SetFrameFromContentFrame (CGRect contentFrame);

        …

}
```

Генератор, вызывается `bmac` в Xamarin.Mac, принимает этих файлов определений и использует средства .NET, чтобы скомпилировать их во временную сборку. Тем не менее это временная сборка не используется для вызова кода Objective-C. Генератор затем считывает временную сборку и создается код C#, который может использоваться во время выполнения. Это почему, например, при добавлении случайных атрибут файл CS определение, он не будет отображаться в выходные файлов кода. Генератор не знает о нем и, следовательно, `bmac` не знает, следует искать его в временную сборку для вывода его.

Когда Xamarin.Mac.dll будет создана, упаковщик `mmp`, будут объединены все компоненты.

На высоком уровне это достигается путем выполнения следующих задач:

- Создайте структуру пакета приложения.
- Скопируйте управляемых сборок.
- Если включен связывания, запустите управляемого компоновщика для оптимизации сборок путем удаления неиспользуемых частей.
- Создание запуска приложения, в коде запуска затрагивали вместе с кодом registar в режиме статического связывания.

Это происходит, а затем выполнения в рамках пользователя процесса, который компилируется в сборку пользовательского кода Xamarin.Mac.dll этой ссылки и выполняется `mmp` вносить пакета

Дополнительные сведения о компоновщика и способах ее использования см. iOS [компоновщика](~/ios/deploy-test/linker.md) руководства.

## <a name="summary"></a>Сводка

В этом руководстве рассмотрены компиляция приложения Xamarin.Mac и изучать Xamarin.Mac и его связь с целью-C.
