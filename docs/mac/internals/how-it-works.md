---
title: "Как работает Xamarin.Mac"
description: "В этом документе описывается механизмах Xamarin.Mac. В частности он выполняет поиск конструкторов, управление памятью, опережает время компиляции и регистратора."
ms.topic: article
ms.prod: xamarin
ms.assetid: C2053ABB-6DBF-4233-AEEA-B72FC6A81FE1
ms.technology: xamarin-mac
author: bradumbaugh
ms.author: brumbaug
ms.date: 05/25/2017
ms.openlocfilehash: a1dbff32b113bd1c3a6b2058a34c73977c59c9e5
ms.sourcegitcommit: 73bd0c7e5f237f0a1be70a6c1384309bb26609d5
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2018
---
# <a name="how-xamarinmac-works"></a>Как работает Xamarin.Mac

В большинстве случаев разработчик никогда не беспокоиться о внутренней «magic» из Xamarin.Mac, однако наличие в грубого понять, как работает вещей за кулисами помогут в интерпретации существующей документации с линзы C# и отладки проблем при их возникновения.

В Xamarin.Mac, приложение связывает двух миров: отсутствует Objective-C на основе среды выполнения, содержащей экземпляры собственных классов (`NSString`, `NSApplication`и т. д) и выполнения C#, содержащий экземпляров управляемых классов (`System.String`, `HttpClient`и т. д). Между этих двух миров Xamarin.Mac создает мост двусторонним, поэтому приложение может вызывать методы (селекторы) в Objective-C (например, `NSApplication.Init`) и Objective-C может вызывать приложения C# методы обратно (например, методы делегата приложения). Как правило, вызовы Objective-C обрабатываются прозрачно через **P/Invoke** и некоторые Xamarin предоставляет кода во время выполнения.

<a name="exposing-classes" />

## <a name="exposing-c-classes--methods-to-objective-c"></a>C# классы и методы для Objective-c.

Однако для Objective-C обратный вызов приложения C# объекты, они должны предоставляться в результате которого было понятно, Objective-C. Это выполняется через `Register` и `Export` атрибуты. Рассмотрим следующий пример:

```csharp
[Register ("MyClass")]
public class MyClass : NSObject
{
   [Export ("init")]
   public MyClass ()
   {
   }

   [Export ("run")]
   public void Run ()
   {
   }
}
```

В этом примере среда выполнения Objective-C, теперь будут знать о класс с именем `MyClass` с именем селекторы `init` и `run`.

В большинстве случаев это реализации, разработчик может пропустить, поскольку большинство обратные вызовы, которые получает приложение может быть либо через переопределенные методы на `base` классы (такие как `AppDelegate`, `Delegates`, `DataSources`) или на  **Действия** переданные в API-интерфейсы. Во всех этих случаях `Export` атрибуты не требуются в коде C#.

## <a name="constructor-runthrough"></a>Обзор конструктора

Во многих случаях разработчик потребуется для предоставления приложения C# классы конструкции API среды выполнения c. цель, поэтому он может быть создан из мест например при вызове в раскадровку или XIB файлов. Ниже приведены пять наиболее распространенных конструкторы, используемые в приложениях Xamarin.Mac.

```csharp
// Called when created from unmanaged code
public CustomView (IntPtr handle) : base (handle)
{
   Initialize ();
}

// Called when created directly from a XIB file
[Export ("initWithCoder:")]
public CustomView (NSCoder coder) : base (coder)
{
   Initialize ();
}

// Called from C# to instance NSView with a Frame (initWithFrame)
public CustomView (CGRect frame) : base (frame)
{
}

// Called from C# to instance NSView without setting the frame (init)
public CustomView () : base ()
{
}

// This is a special case constructor that you call on a derived class when the derived called has an [Export] constructor.
// For example, if you call init on NSString then you don’t want to call init on NSObject.
public CustomView () : base (NSObjectFlag.Empty)
{
}
```

В общем случае следует оставить разработчик `IntPtr` и `NSCoder` конструкторы, которые создаются при создании некоторых типов, таких как пользовательские `NSViews` сама по себе. Если вы удалили Xamarin.Mac необходимо вызвать один из этих конструкторов в ответ на запрос Objective-C времени выполнения, произойдет сбой приложения в машинный код, и она может быть сложно понять, точно проблему.

## <a name="memory-management-and-cycles"></a>Управление памятью и циклы

Управление памятью в Xamarin.Mac — это во многом аналогично Xamarin.iOS. Это сложная тема, один выходит за рамки настоящего документа. Ознакомьтесь с [памяти и рекомендации по производительности](~/cross-platform/deploy-test/memory-perf-best-practices.md).

## <a name="ahead-of-time-compilation"></a>Преимущества времени компиляции

Как правило, при построении до машинного кода не компилировать приложения .NET, вместо этого они компилируются в промежуточный слой называется IL-код, который возвращает _непосредственно в момент_ (JIT) скомпилированные в машинный код при запуске приложения.

Время, затрачиваемое mono среды выполнения в JIT-компиляции этого кода может привести к снижению запуск приложения Xamarin.Mac до 20%, сколько потребуется времени для необходимый код компьютера должен быть создан.

Из-за ограничений, накладываемых Apple на iOS JIT-компиляция кода IL недоступна в Xamarin.iOS. В результате заполнены все приложения Xamarin.iOS _вперед времени_ (AOT) скомпилированные в машинный код во время цикла сборки.

Новое в Xamarin.Mac является возможность AOT IL-код во время цикла сборки приложения, так же, как можно Xamarin.iOS. Использует Xamarin.Mac _гибридных_ AOT подход, который компилирует большинство необходимых машинный код, но позволяет среде выполнения для компиляции необходимые trampolines и характеризуется гибкостью, продолжают поддерживать Reflection.Emit (и другие действия с приложениями, в настоящее время работает на Xamarin.Mac).

Существует два основных областей, где AOT могут помочь приложения Xamarin.Mac:

- **Более высокий уровень журналы аварийных «собственные»** — Если приложение Xamarin.Mac аварийно завершает работу в машинном коде — обычное дело при выполнении недопустимый вызовов в API-интерфейсы Cocoa (например, отправку `null` в метод, который не принимает её) машинный журналов с помощью JIT-компилятора сбоев фрагменты кода не анализировать трудно. Так как фреймы JIT Нет отладочной информации, будет несколько строк со смещениями шестнадцатеричные и не может понять, что происходит. AOT приводит к возникновению ошибки «real» именованный кадры и трассировки гораздо удобнее для чтения. Это также означает Xamarin.Mac приложения смогут лучше с собственных средств например **lldb** и **инструментов**.
- **Лучше запустить производительность во время** — для больших приложений Xamarin.Mac, с несколькими запуска повторно, JIT-компиляция весь код может занять значительное время. AOT выполняет эту работу заранее.

### <a name="enabling-aot-compilation"></a>Включение компиляции AOT

AOT включен в Xamarin.Mac, дважды щелкнув **имя проекта** в **обозревателе решений**, перехода по страницам **построения Mac** и добавление `--aot:[options]` для  **Mmp дополнительные аргументы:** поля (где `[options]` имеет один или несколько параметров для AOT типа элемента управления, см. ниже). Пример:

![Добавление дополнительных mmp аргументы AOT](how-it-works-images/aot01.png "Добавление AOT mmp дополнительные аргументы")

> [!IMPORTANT]
> Включение AOT компиляции значительно увеличивает время сборки, иногда до нескольких минут, но оно может улучшить время запуска приложения в среднем на 20%. В результате компиляции AOT должны включаться только на **выпуска** строит Xamarin.Mac приложения.

### <a name="aot-compilation-options"></a>Параметры компиляции AOT

Существует несколько различных параметров, которые можно настроить при включении AOT компиляцию для приложения Xamarin.Mac:

- `none` -Компиляция не AOT. Этот параметр используется по умолчанию.
- `all` -AOT компилирует каждой сборки в MonoBundle.
- `core` -Компилирует AOT `Xamarin.Mac`, `System` и `mscorlib` сборки.
- `sdk` -Компилирует AOT `Xamarin.Mac` и библиотеки базовых классов (BCL) сборки.
- `|hybrid` -Добавление это одно из перечисленных выше параметров позволяет гибридного AOT, что позволяет пропустить IL, но результат в больше будут компилироваться раз.
- `+` -Содержит одну для компиляции AOT.
- `-` — Удаляет один файл из AOT компиляции.

Например `--aot:all,-MyAssembly.dll` позволит компиляции AOT на все сборки в MonoBundle _за исключением_ `MyAssembly.dll` и `--aot:core|hybrid,+MyOtherAssembly.dll,-mscorlib.dll` позволит гибридного, включают код AOT `MyOtherAssembly.dll` и исключение `mscorlib.dll`.

## <a name="partial-static-registrar"></a>Частичное статических регистратора

При разработке приложения Xamarin.Mac, сводя к минимуму время между завершение изменения и его тестирование может стать важные собрания, крайние сроки разработки. Рекомендации по использованию модулей базы кода и модульные тесты могут помочь сократить время компиляции как сокращают количество раз, что приложение будет требоваться дорогих полное перестроение.

Кроме того новой Xamarin.Mac, _частичного статических регистратора_ (как первыми, Xamarin.iOS) значительно снижают время запуска приложения в Xamarin.Mac **отладки** конфигурации. Понимание того, как можно с помощью частичного статических регистратора сжато почти 5 x улучшения в запуска отладки будет требует определенных фоновый регистратор —, какова разница между статических и динамических и назначение этой версии «частичная static».

### <a name="about-the-registrar"></a>О регистратора

В механизме любой Xamarin.Mac приложение находится в framework Cocoa от Apple и среда выполнения C цель. Создание моста между этой «собственный world» и «управляемый world» C# является основную ответственность за Xamarin.Mac. В рамках этого задания обрабатывается регистратора, который выполняется внутри `NSApplication.Init ()` метод. Это одна из причин требуется при использовании API Cocoa в Xamarin.Mac `NSApplication.Init` вызывается первой.

Задание регистратора — для информирования о существовании приложения C# классы, производные от классов, таких как среда выполнения Objective-C `NSApplicationDelegate`, `NSView`, `NSWindow`, и `NSObject`. Это требует просмотра всех типов в приложении для определения, регистрации и то, какие элементы для каждого типа отчета.

Такая проверка может выполняться либо **динамически**, при запуске приложения с помощью отражения, или **статически**, как действие время сборки. При выборе типа регистрации разработчику следует иметь в виду следующее:

- Статические регистрации могут значительно снизить время запуска, но может замедлить раз сборок значительно (обычно более чем в два раза время построения отладки). Это будет по умолчанию для **выпуска** конфигурации построения.
- Динамическая регистрация откладывается до этой работы приложения запустите пропускает создания кода, но для дополнительной работы можно создать заметно паузу (по крайней мере две секунды) в запуске приложения. Это особенно заметно в отладочных построениях конфигурации, который по умолчанию для динамической регистрации и которого отражения снижается.

Частичное статических регистрации, впервые представленный в Xamarin.iOS 8.13 дает разработчику наиболее обоих вариантов. При вычислении сведения о регистрации каждого элемента в предварительно `Xamarin.Mac.dll` и доставкой эту информацию с Xamarin.Mac в статической библиотеке (который только должен быть связан с во время сборки), Microsoft удален в большинстве случаев отражения динамической Регистратор при не влияя на время построения.

### <a name="enabling-the-partial-static-registrar"></a>Включение частичного статических регистратора

Частичное статических регистратора включен в Xamarin.Mac, дважды щелкнув **имя проекта** в **обозревателе решений**, перехода по страницам **построения Mac** и добавление `--registrar:static` для **mmp дополнительные аргументы:** поля. Пример:

![Добавление частичного статических регистратора mmp дополнительные аргументы](how-it-works-images/psr01.png "Добавление частичного статических регистратора mmp дополнительные аргументы")

## <a name="additional-resources"></a>Дополнительные ресурсы

Ниже приведены некоторые подробные пояснения сведениями о работе внутренним образом.

- [Селекторы Objective c.](~/ios/internals/objective-c-selectors.md)
- [Регистратор](~/ios/internals/registrar.md)
- [Xamarin единой API для iOS и OS X](~/cross-platform/macios/unified/index.md)
- [Основы theading](~/ios/app-fundamentals/threading.md)
- [Делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [О `newrefcount`](~/ios/internals/newrefcount.md)

