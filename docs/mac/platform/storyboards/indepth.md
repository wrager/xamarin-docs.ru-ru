---
title: "Работа с раскадровки"
description: "Построение macOS пользовательских интерфейсов с помощью раскадровки с помощью Xcode."
ms.topic: article
ms.prod: xamarin
ms.assetid: DF4DF7C2-DDD7-4A32-B375-5C5446301EC5
ms.technology: xamarin-mac
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/14/2017
ms.openlocfilehash: 388744d48799e84587a4f554a4eb67cd677d8c9a
ms.sourcegitcommit: 30055c534d9caf5dffcfdeafd6f08e666fb870a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/09/2018
---
# <a name="storyboards"></a>Элементы Storyboard

Раскадровка определяет все пользовательского интерфейса для данного приложения, разбитый на режим работы Общие сведения о его просмотр контроллеров. В построителе интерфейса в Xcode каждый из этих контроллеров живет в свой собственный сцены.

[![](indepth-images/intro01.png "Раскадровка в построителе интерфейса в Xcode")](indepth-images/intro01.png#lightbox)

Раскадровка представляет собой файл ресурсов (с расширениями `.storyboard`), которые возвращает включены в набор приложений Xamarin.Mac при компиляции и поставляется. Определить начальный раскадровки для вашего приложения, можно изменить его `Info.plist` файла и выберите **главного интерфейса** из раскрывающегося списка: 

[![](indepth-images/sb01.png "Редактор Info.plist")](indepth-images/sb01.png#lightbox)

<a name="Loading-from-Code" />

## <a name="loading-from-code"></a>Загрузка из кода

Возможны ситуации, при необходимости загрузить определенные раскадровки из кода и вручную создать View Controller. Для выполнения этого действия можно использовать следующий код:

```csharp
// Get new window
var storyboard = NSStoryboard.FromName ("Main", null);
var controller = storyboard.InstantiateControllerWithIdentifier ("MainWindow") as NSWindowController;

// Display
controller.ShowWindow(this);
```

`FromName` Загружает файл раскадровки с заданным именем, которая была включена в пакет приложения. `InstantiateControllerWithIdentifier` Создает экземпляр контроллера представления с заданным идентификатором. При разработке пользовательского интерфейса в построителе интерфейс Xcode по установке удостоверения:

[![](indepth-images/sb02.png "Задание идентификатора раскадровки")](indepth-images/sb02.png#lightbox)

При необходимости можно использовать `InstantiateInitialController` метод для загрузки, имеющей начальной контроллера в интерфейс построителя контроллера представления:

[![](indepth-images/sb03.png "Задание начальной контроллера")](indepth-images/sb03.png#lightbox)

Он обозначен **точки входа раскадровки** и выше стрелку open завершен.

<a name="View-Controllers" />

## <a name="view-controllers"></a>Просмотр контроллеров

Просмотр контроллеров определяют связи между данного представления данных в приложении Mac и модели данных, которая предоставляет эту информацию. Каждая сцена верхнего уровня в раскадровке представляет одно представление-контроллер в коде приложения Xamarin.Mac.

<a name="The-View-Controller-Lifecycle" />

### <a name="the-view-controller-lifecycle"></a>Жизненный цикл контроллера представления

Новые методы были добавлены `NSViewController` класс для поддержки раскадровки в macOS. Самое главное — это использовать следующие методы для ответа на жизненного цикла представления контролируемого контроллером данного представления:

- `ViewDidLoad` -Этот метод вызывается при загрузке представления из файла раскадровки.
- `ViewWillAppear` -Этот метод вызывается непосредственно перед представление отображается на экране.
- `ViewDidAppear` — Этот метод вызывается непосредственно после представления, отображаемого на экране.
- `ViewWillDisappear` -Этот метод вызывается непосредственно перед удалением представление на экране.
- `ViewDidDisappear` — Этот метод вызывается непосредственно после удаления представления на экране.
- `UpdateViewConstraints` -Этот метод вызывается, когда ограничения, определение представления автоматически макета положение и размер необходимо обновить.
- `ViewWillLayout` -Этот метод вызывается непосредственно перед представлений этого представления располагаются на экране.
- `ViewDidLayout` — Этот метод вызывается непосредственно после представлений представления view располагаются на экране.

<a name="The-Responder-Chain" />

### <a name="the-responder-chain"></a>Цепочка сетевого ответчика

Кроме того `NSViewControllers` теперь являются частью окна _цепочки респондент_:

[![](indepth-images/vc01.png "Цепочка сетевого ответчика")](indepth-images/vc01.png#lightbox)

И по существу являются проводной доступ для получения и реагировать на события, например, Вырезать, копировать и вставить выбранные элементы меню. Это автоматическое View Controller проводной доступ возникает только для приложений, выполняющихся на macOS Сьерра (10.12) и более поздней версии.

<a name="Containment" />

### <a name="containment"></a>Вложение

В раскадровки, контроллеров представления (например, разбиение View Controller и вкладка View Controller) теперь можно реализовать _вложения_, таким образом, что они могут» содержать «другие sub контроллеров представления:

[![](indepth-images/vc02.png "Пример включения контроллера представления")](indepth-images/vc02.png#lightbox)

Контроллеры дочерние представления содержат методы и свойства, чтобы связать их обратно их контроллер представление родительского и работы с отображение и удаление представления на экране.

Все контроллеры представление контейнера, встроенные в macOS имеют определенного макета которой Apple предложит выполнить при создании собственных пользовательских контроллеров представления контейнера:

[![](indepth-images/vc03.png "Макет View Controller")](indepth-images/vc03.png#lightbox)

Контроллер представление коллекции содержит массив Просмотр элементов коллекции, каждый из которых содержит один или несколько контроллеров представления, содержащих свои собственные представления.

<a name="Segues" />

## <a name="segues"></a>Segues

Segues обеспечивают связи между всеми сцены, определения пользовательского интерфейса приложения. Если вы знакомы с работой в раскадровки в iOS, известно, что Segues для операций ввода-вывода обычно определяются переходы между представлениями полного экрана. Это отличается от macOS, когда Segues обычно определяют "[вложения](#Containment)», где один сцены является дочерним элементом родительского сцены.

В macOS большинство приложений, как правило, должны быть сгруппированы вместе в том же окне, с помощью элементов пользовательского интерфейса, таких как вкладки и представления с разделением их представления. В отличие от операций ввода-вывода, где представлений должны переноситься в и вне экрана, из-за ограниченной физической отображения пространства.

<a name="Presentation-Segues" />

### <a name="presentation-segues"></a>Segues презентации

Имея тенденциями macOS в сторону вложения, существуют ситуации, когда _Segues презентации_ используются, например модальных окон, представлениях листа и элементы Popover. Предоставляет встроенные перейти macOS типы:

- **Показать** -отображает объект Segue как немодальном окне. Например можно используйте этот тип Segue для представления другой экземпляр окна документа, в приложении.
- **Модальные** -представляется целевой Segue как модальное окно. Например можно используйте этот тип Segue для представления окно установки для приложения.
- **Лист** -представляется целевой Segue как подключенные лист родительского окна. Например, используйте этот тип перейти представляет найти и заменить листа.
- **Popover** -представляется как окно popover целевого объекта Segue. Например используйте этот тип Segue для предоставления параметров, при нажатии пользователем элемента пользовательского интерфейса.
- **Пользовательские** -представляется целевого объекта Segue, с помощью пользовательского типа перейти, определяемые разработчиком. В разделе [Создание настраиваемых Segues](#Creating-Custom-Segues) ниже, в разделе для получения дополнительных сведений.

При использовании Segues презентации, можно переопределить `PrepareForSegue` метод родительского представления контроллера для презентации для инициализации и переменных и предоставлять данные для представления контроллера представления.

<a name="Triggered-Segues" />

### <a name="triggered-segues"></a>Запустить Segues

Инициированные Segues позволяют указать именованный Segues (через их **идентификатор** свойство в интерфейс построителя) и их запуска, события, например когда пользователь нажимает кнопку или вызвав `PerformSegue` метода в коде:

```csharp
// Display the Scene defined by the given Segue ID
PerformSegue("MyNamedSegue", this);
``` 

Идентификатор перейти определяется внутри Xcode интерфейс построителя при размещении пользовательского интерфейса приложения:

[![](indepth-images/sg02.png "Введите имя перейти")](indepth-images/sg02.png#lightbox)

Представление-контроллер, выступающего в качестве источника Segue, должны переопределять `PrepareForSegue` метода и выполните инициализацию, необходимые перед выполнением Segue и указанный контроллер представление отображается:

```csharp
public override void PrepareForSegue (NSStoryboardSegue segue, NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    // Take action based on Segue ID
    switch (segue.Identifier) {
    case "MyNamedSegue":
        // Prepare for the segue to happen
        ...
        break;
    }
}
```

При необходимости можно переопределить `ShouldPerfromSegue` метод и управления ли Segue фактически выполняется посредством кода C#. Вручную представленному Просмотр контроллеров вызывать их `DismissController` метод для их удаления из изображения, когда они больше не нужны.

<a name="Creating-Custom-Segues" />

### <a name="creating-custom-segues"></a>Создание пользовательского Segues

Возможны ситуации, когда приложение требует Segue типа, не предоставляемые Segues в сборки, определенные в macOS. Если это так, можно создать настраиваемый перейти, которое может быть назначено в построителе интерфейс Xcode при создании макетов пользовательского интерфейса приложения.

Например чтобы создать новый тип Segue, который заменяет текущий контроллер представление внутри окна (а не целевой сцены Открытие в новом окне), можно использовать следующий код:

```csharp
using System;
using AppKit;
using Foundation;

namespace OnCardMac
{
    [Register("ReplaceViewSeque")]
    public class ReplaceViewSeque : NSStoryboardSegue
    {
        #region Constructors
        public ReplaceViewSeque() {

        }

        public ReplaceViewSeque (string identifier, NSObject sourceController, NSObject destinationController) : base(identifier,sourceController,destinationController) {

        }

        public ReplaceViewSeque (IntPtr handle) : base(handle) {
        }

        public ReplaceViewSeque (NSObjectFlag x) : base(x) {
        }
        #endregion

        #region Override Methods
        public override void Perform ()
        {
            // Cast the source and destination controllers
            var source = SourceController as NSViewController;
            var destination = DestinationController as NSViewController;

            // Swap the controllers
            source.View.Window.ContentViewController = destination;

            // Release memory
            source.RemoveFromParentViewController ();
        }
        #endregion

    }
        
}
```

Кое-что здесь необходимо обратить внимание:

- Мы используем `Register` атрибут, цель-C и macOS этого класса.
- Мы переопределении `Perform` метод для наших пользовательских Segue фактически действий.
- Вместо окна `ContentViewController` контроллер с определенным адресат Segue (назначение).
- Мы удаляем на исходный контроллер представление, чтобы освободить память, используя `RemoveFromParentViewController` метод.

Чтобы использовать этот новый тип Segue в построителе интерфейса в Xcode, необходимо скомпилировать приложение во-первых, а затем перейдите к Xcode и добавьте новый Segue между двумя сцены. Задать **стиль** для **пользовательские** и **перейти класс** для `ReplaceViewSegue` (имя нашем пользовательском классе Segue):

[![](indepth-images/sg01.png "Класс Segue параметров")](indepth-images/sg01.png#lightbox)

<a name="Triggered-Segues" />

## <a name="window-controllers"></a>Контроллеры окна

Окно контроллеры содержат и управляют разными типами окна, которые может создать приложение macOS. Для раскадровки они имеют следующие особенности:

1. Им необходимо предоставить содержимого представление-контроллер. Это будет один контроллер содержимого представления с дочернего окна.
2. `Storyboard` Раскадровки, загруженной контроллера окна, в противном случае будет содержать свойство `null` , если не загружен из раскадровки.
3. Можно вызвать `DismissController` метод, чтобы закрыть заданное окно и удалить его из представления.

Как просмотр контроллеров реализации контроллеров окна `PerformSegue`, `PrepareForSegue` и `ShouldPerfromSegue` методов и могут использоваться в качестве источника операции Segue.

Окно контроллера отвечают macOS приложения со следующими функциями:

- Они управляют конкретных окно.
- Они управляют строку заголовка окна и панели инструментов (если доступно).
- Они управляют содержимым контроллера представления для отображения содержимого окна.

<a name="Gesture-Recognizers" />

## <a name="gesture-recognizers"></a>Распознаватель жестов

Распознаватель жестов для macOS практически идентичны со своими аналогами в iOS и позволяют разработчикам возможность легко добавлять жесты (например, нажатие кнопки мыши) элементов пользовательского интерфейса приложения.

Тем не менее, где жестов в iOS определяются по разработке приложений (например, нажимая на экран с двумя пальцами), наиболее жестов в macOS определяются оборудования.

С помощью распознавателей жестов, может значительно снизить объем кода, необходимого для добавления пользовательского взаимодействия с элементом в пользовательском Интерфейсе. Как они могут автоматически определять между одинарные и двойные щелчки, щелкните и перетащите события и т. д.

Вместо переопределения `MouseDown` событий в контроллере представление следует использовать средство распознавания жестов для обработки события ввода пользователя при работе с раскадровками.

Доступны следующие распознавателей жестов macOS.

- `NSClickGestureRecognizer` -Register мыши вниз и вверх события.
- `NSPanGestureRecognizer` -Регистры кнопки мыши, перетащите и отпустите события.
- `NSPressGestureRecognizer` -Регистры, удерживая нажатой кнопку мыши через заданный промежуток времени событий.
- `NSMagnificationGestureRecognizer` — Регистрирует событие увеличения от оборудования сенсорной панели.
- `NSRotationGestureRecognizer` — Регистрирует событие поворота от оборудования сенсорной панели.

<a name="Using-Storyboard-References" />

## <a name="using-storyboard-references"></a>С помощью ссылки на раскадровки

Ссылки раскадровки позволяет использовать конструкцию раскадровки больших и сложных и разбить на более мелкие раскадровки, получение ссылки из исходного, таким образом удаление удаление сложности и принятия итоговый отдельных раскадровок проще для разработки и Ведение.

Кроме того, можно указать ссылку на раскадровку _привязки_ другой сцену в пределах того же раскадровки или конкретных сцены на другом.

<a name="Referencing-an-External-Storyboard" />

### <a name="referencing-an-external-storyboard"></a>Создание ссылок на внешние раскадровки

Чтобы добавить ссылку на внешний раскадровки, выполните следующее:

1. В **обозревателе решений**, щелкните правой кнопкой мыши имя проекта и выберите **добавить** > **новый файл...**   >  **Mac** > **раскадровки**. Введите **имя** новую раскадровку и нажмите кнопку **New** кнопки: 

    [![](indepth-images/ref01.png "Добавление нового раскадровки")](indepth-images/ref01.png#lightbox)
2. В **обозревателе решений**, дважды щелкните имя нового раскадровки, чтобы открыть его для редактирования в Xcode интерфейс построителя.
2. Разработка макета новая раскадровка сцен, как обычно и сохранить изменения: 

    [![](indepth-images/ref02.png "Проектирование интерфейса")](indepth-images/ref02.png#lightbox)
3. Переключитесь на раскадровку, нужно добавления ссылки на интерфейс построителя.
4. Перетащите **раскадровки ссылка** из **объекта библиотеки** на поверхность разработки: 

    [![](indepth-images/ref03.png "При выборе ссылки раскадровки в библиотеке")](indepth-images/ref03.png#lightbox)
5. В **инспектора атрибут**, выберите имя **раскадровки** созданной выше: 

    [![](indepth-images/ref04.png "Настройка ссылки")](indepth-images/ref04.png#lightbox)
6. Элемент управления, щелкните элемент пользовательского интерфейса (например, кнопка) на существующий сцены и создать новый Segue для **ссылки раскадровки** только что созданный.  В контекстном меню выберите **Показать** для завершения Segue: 

    [![](indepth-images/ref06.png "Segue тип параметра")](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровку.
9. Вернитесь в Visual Studio для Mac для синхронизации изменений.

Отображается при запуске приложения, и пользователь щелкает элемент пользовательского интерфейса, созданный Segue из начального окна контроллера из внешних раскадровки, указанный в ссылке раскадровки.

<a name="Referencing-a-Specific-Scene-in-an-External-Storyboard" />

### <a name="referencing-a-specific-scene-in-an-external-storyboard"></a>Создание ссылок на определенного кадра в внешних раскадровки

Добавление ссылки на определенные сцены внешних раскадровки (и не контроллером начального окна), выполните следующее:

1. В **обозревателе решений**, дважды щелкните внешних раскадровку, чтобы открыть его для редактирования в построителе интерфейса в Xcode.
2. Добавьте новую сцену и его макет обычным образом: 

    [![](indepth-images/ref07.png "Разработка макета в Xcode")](indepth-images/ref07.png#lightbox)
3. В **удостоверение инспектора**, введите **раскадровки идентификатор** для нового сцены окна контроллера: 

    [![](indepth-images/ref08.png "Задание идентификатора раскадровки")](indepth-images/ref08.png#lightbox)
3. Откройте раскадровку, нужно добавления ссылки в построителе интерфейса.
4. Перетащите **раскадровки ссылка** из **объекта библиотеки** на поверхность разработки: 

    [![](indepth-images/ref03.png "При выборе ссылки раскадровки из библиотеки")](indepth-images/ref03.png#lightbox)
5. В **удостоверение инспектора**, выберите имя **раскадровки** и **ссылка на идентификатор** (раскадровки ID) сцены, созданный выше: 

    [![](indepth-images/ref09.png "Задание идентификатора ссылки")](indepth-images/ref09.png#lightbox)
6. Элемент управления, щелкните элемент пользовательского интерфейса (например, кнопка) на существующий сцены и создать новый Segue для **ссылки раскадровки** только что созданный. В контекстном меню выберите **Показать** для завершения Segue: 

    [![](indepth-images/ref06.png "Segue тип параметра")](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровку.
9. Вернитесь в Visual Studio для Mac для синхронизации изменений.

Когда приложение будет выполнения и пользователь щелкает элемент пользовательского интерфейса, который вы создали Segue из сцены с заданной **раскадровки идентификатор** из внешних раскадровки, указанный в ссылке раскадровки будет отображаться.

<a name="Referencing-a-Specific-Scene-in-the-Same-Storyboard" />

### <a name="referencing-a-specific-scene-in-the-same-storyboard"></a>Ссылки на определенные сцены в одном раскадровки

Чтобы добавить ссылку на конкретных сцены же раскадровки, выполните следующее:

1. В **обозревателе решений**, дважды щелкните раскадровку, чтобы открыть его для редактирования.
2. Добавьте новую сцену и его макет обычным образом: 

    [![](indepth-images/ref11.png "Редактирование раскадровки в Xcode")](indepth-images/ref11.png#lightbox)
3. В **удостоверение инспектора**, введите **раскадровки идентификатор** для нового сцены окна контроллера: 

    [![](indepth-images/ref12.png "Задание идентификатора раскадровки")](indepth-images/ref12.png#lightbox)
3. Перетащите **раскадровки ссылка** из **элементов** на поверхность разработки: 

    [![](indepth-images/ref03.png "При выборе ссылки раскадровки из библиотеки")](indepth-images/ref03.png#lightbox)
5. В **инспектора атрибут**выберите **ссылка на идентификатор** (раскадровки ID) сцены, созданный выше: 

    [![](indepth-images/ref13.png "Задание идентификатора ссылки")](indepth-images/ref13.png#lightbox)
6. Элемент управления, щелкните элемент пользовательского интерфейса (например, кнопка) на существующий сцены и создать новый Segue для **ссылки раскадровки** только что созданный. В контекстном меню выберите **Показать** для завершения Segue: 

    [![](indepth-images/ref06.png "Выбор типа Segue")](indepth-images/ref06.png#lightbox) 
8. Сохраните изменения в раскадровку.
9. Вернитесь в Visual Studio для Mac для синхронизации изменений.

Когда приложение будет выполнения и пользователь щелкает элемент пользовательского интерфейса, который вы создали Segue из сцены с заданной **идентификатор раскадровки** в же раскадровки, указанный в ссылке раскадровки будет отображаться.

<a name="Complex-Storyboard-Example" />

## <a name="complex-storyboard-example"></a>Пример сложной раскадровки

Сложный пример работы с раскадровки в приложении Xamarin.Mac, см. в разделе [SourceWriter пример приложения](https://developer.xamarin.com/samples/mac/SourceWriter/). SourceWriter — это простой редактор исходного кода, который предоставляет поддержку для автозавершения и выделения простого синтаксиса.

Код SourceWriter полностью закомментирован, и там, где это возможно, предоставлены ссылки из основных технологий и методов на соответствующую информацию в документации по руководствам для Xamarin.Mac.

## <a name="related-links"></a>Связанные ссылки

- [MacStoryboard (пример)](https://developer.xamarin.com/samples/mac/MacStoryboard/)
- [Привет, Mac](~/mac/get-started/hello-mac.md)
- [Работа с окнами](~/mac/user-interface/window.md)
- [Рекомендации по работе с человеческим интерфейсом OS X](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/)
- [Введение в Windows](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/WinPanel/Introduction.html#//apple_ref/doc/uid/10000031-SW1)
