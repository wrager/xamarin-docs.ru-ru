---
title: Общие методы и стили в Xamarin.Mac
description: В этом документе описываются общие принципы проектирования, используемых при создании Xamarin.Mac приложений. Он описывает шаблон model-view-controller, закономерности в данных источника и делегата и протоколы.
ms.prod: xamarin
ms.assetid: BF0A3517-17D8-453D-87F7-C8A34BEA8FF5
ms.technology: xamarin-mac
author: bradumbaugh
ms.author: brumbaug
ms.date: 06/17/2016
ms.openlocfilehash: f6bba5575edf2dcbddbd354b590e03f9fed06291
ms.sourcegitcommit: ea1dc12a3c2d7322f234997daacbfdb6ad542507
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2018
ms.locfileid: "34791541"
---
# <a name="common-patterns-and-idioms-in-xamarinmac"></a>Общие методы и стили в Xamarin.Mac

На протяжении Apple интерфейсы API, предоставляемые через C# определенные стили и шаблоны возникающие снова и снова. Если у вас есть опыт работы с программирование с использованием Xamarin.iOS, они могут вам знакомы. Документации будет часто ссылаться на эти шаблоны и стили несколько раз, поэтому наличие хорошо понять их поможет вам наиболее понятном виде документации, которые можно найти.

## <a name="mvc---model-view-controller"></a>MVC — Model View Controller

Model View Controller и MVC для краткости, является весьма распространенный случай в масштабах всей Cocoa. Подробное рассмотрение выходит за рамки настоящего документа, но вкратце это способ структурирования приложения на компоненты:

- **Модель** объекты представляют базовых данных, для просмотра и управления (такие как адреса в адресной книге)
- **Представление** объектов обрабатывать рисования данного объекта на экране и обработки взаимодействия с пользователем (текстовое поле для отображения адреса на экране)
- **Контроллер** объектов обрабатывать взаимодействие между моделью и представления. Они отправьте изменения модели «до», чтобы обновить представление и отправить изменения «вниз» из представления, когда пользователи вносить изменения в пользовательском Интерфейсе.

Если вы знакомы с MVVM (Model View-ViewModel) от других библиотек, таких как WPF, контроллер действует аналогично ViewModel, но часто более тесно привязаны к определенным элементам пользовательского интерфейса.

Дополнительные сведения можно найти здесь:

- [Изучение MVC на веб-сайте Apple](https://developer.apple.com/library/ios/documentation/general/conceptual/devpedia-cocoacore/MVC.html)

- [Model View Controller в Objective c.](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html)
- [Работа с окнами](~/mac/user-interface/window.md)

## <a name="data-source--delegate--subclassing"></a>Источник данных, делегировать, создание подклассов

Другой очень распространенный шаблон в Cocoa обрабатывает предоставление данных к элементам пользовательского интерфейса и реагирует на взаимодействие с пользователем. С помощью `NSTableView` в качестве примера, вам нужно каким-либо образом предоставлять данные для каждой строки, некоторые набор элементов пользовательского интерфейса, представляющего эту строку, некоторые набор поведений реагировать на взаимодействие с пользователем и возможно некоторое время настройки. Шаблоны данных источника и делегат позволяют обрабатывать правило, не прибегая к использованию для создания подкласса `NSTableView` самостоятельно.

- `DataSource` Присваивается экземпляр пользовательскому подклассу `NSTableViewDataSource` называемый для заполнения таблицы с данными (через `GetRowCount` и `GetObjectValue`).

- `Delegate` Присваивается экземпляр пользовательскому подклассу `NSTableViewDelegate` для заданной модели объекта, который предоставляет представление (через `GetViewForItem`) и обрабатывает взаимодействие пользовательского интерфейса (через `DidClickTableColumn`, `MouseDownInHeaderOfTableColumn`и т. д).

В некоторых случаях может потребоваться настроить элемент управления таким образом за пределы обработчики, заданному в делегат или источник данных и можно создать подкласс представление напрямую. Следите за тем не менее, во многих случаях переопределение по умолчанию поведение затем нужно будет обрабатывать все это поведение (Настройка поведения выбора может потребоваться реализовать поведение выделения).

В Xamarin.iOS некоторых API-интерфейсов, таких как `UITableView` дополнены свойство, которое реализует делегата и источника данных (`UITableViewSource`). Это его для решения распространенных ограничения в один класс C# может иметь только один базовый класс и наши распределение результатов протоколов выполняется через базовые классы.

Дополнительные сведения о работе с представлениями таблицы в приложении Xamarin.Mac см. в разделе нашей [таблицы представления](~/mac/user-interface/table-view.md) документации.

## <a name="protocols"></a>Протоколы

Протоколы в Objective-C можно сравнить с интерфейсов в C# и во многих случаях используются в аналогичных ситуациях. Например `NSTableView` фактически протоколы, приведенном выше примере делегат и источником данных. Xamarin.Mac предоставляет их как базовые классы с виртуальными методами, которые могут быть изменены. Основное различие между интерфейсами C# и Objective-C протоколы является, некоторые методы протокол может быть необязательным для реализации. Вам придется искать в документации и/или определение API, чтобы определить, что является необязательным.

Дополнительные сведения см. в разделе нашей [делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md) документации.



## <a name="related-links"></a>Связанные ссылки

- [Представления таблиц](~/mac/user-interface/table-view.md)
- [Работа с окнами](~/mac/user-interface/window.md)
- [Делегаты, протоколы и события](~/ios/app-fundamentals/delegates-protocols-and-events.md)
- [Модель представление контроллер](https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html)
