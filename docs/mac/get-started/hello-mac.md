---
title: Привет, Mac
description: В этом руководстве описываются действия по созданию первого приложения Xamarin.Mac. В ходе процесса происходит знакомство с цепочкой инструментов разработки, включая Visual Studio для Mac, Xcode и конструктор интерфейсов Interface Builder. Здесь также содержатся общие сведения о переменных экземпляров и действиях, которые добавляют элементы управления пользовательского интерфейса в код, и, наконец, демонстрируется создание, запуск и тестирование приложения Xamarin.Mac.
ms.topic: quickstart
ms.prod: xamarin
ms.assetid: 37D0E9E6-979B-7069-B3BE-C5F0AF99BA72
ms.technology: xamarin-mac
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/23/2017
ms.openlocfilehash: e5d87d42765480c97da392cf07b6599108895321
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="hello-mac"></a>Привет, Mac

Xamarin.Mac позволяет разрабатывать полностью собственные приложения Mac на C# и .NET с помощью тех же библиотек и элементов управления интерфейса OS X, которые используются при разработке на *Objective-C* и *Xcode*. Поскольку Xamarin.Mac напрямую интегрируется с Xcode, можно использовать конструктор _Interface Builder_ для Xcode, чтобы создавать пользовательские интерфейсы приложений (или при необходимости создать их непосредственно в коде C#).

Кроме того, поскольку приложения Xamarin.Mac написаны на языке C# и .NET, основной серверный код может быть общим для мобильных приложений Xamarin.iOS и Xamarin.Android, при этом на каждой платформе формируется собственная среда взаимодействия.

В этой статье будут представлены основные понятия, необходимые для создания приложения Mac с помощью Xamarin.Mac, Visual Studio для Mac и конструктора Interface Builder Xcode. Они рассматриваются в ходе процесса построения простого приложения **Привет, Mac**, которое подсчитывает количество раз нажатия кнопки:

[![](hello-mac-images/run02.png "Пример запущенного приложения "Привет, Mac"")](hello-mac-images/run02.png#lightbox)

В статье затрагиваются следующие темы:

-  **Visual Studio для Mac**. Общие сведения о Visual Studio для Mac и использовании этой среды для создания приложений Xamarin.Mac.
-  **Компоненты приложения Xamarin.Mac**. Описание частей приложения Xamarin.Mac.
-  **Конструктор Interface Builder в Xcode**. Сведения об использовании конструктора Interface Builder в Xcode для определения пользовательского интерфейса приложения.
-  **Переменные экземпляров и действия**. Сведения об использовании переменных экземпляров и действий для привязывания элементов управления в пользовательском интерфейсе.
-  **Развертывание и тестирование**. Сведения о запуске и тестировании приложения Xamarin.Mac.


<a name="Requirements" />

## <a name="requirements"></a>Требования

Для разработки приложения macOS с помощью Xamarin.Mac macOS требуется следующее:

- компьютер Mac под управлением macOS Yosemite (10.10) или более поздней версии;
- Xcode 7 и более поздние версии (хотя рекомендуется установить последнюю стабильную версию из Магазина [App Store](https://itunes.apple.com/us/app/xcode/id497799835?mt=12));
- последняя версия Xamarin.Mac и Visual Studio для Mac.

Для запуска приложений Mac, созданных с помощью Xamarin.Mac, необходимо выполнить следующие системные требования:

- наличие компьютера Mac под управлением Mac OS X 10.7 или более поздней версии.

<a name="Starting_a_new_Xamarin.Mac_App_in_Xamarin_Studio" />

## <a name="starting-a-new-xamarinmac-app-in-visual-studio-for-mac"></a>Создание приложения Xamarin.Mac в Visual Studio для Mac

Как уже говорилось выше, в этом руководстве описываются действия по созданию приложения Mac `Hello_Mac`, которое добавляет одну кнопку и метку в главное окно. При нажатии кнопки метка будет отображать количество раз нажатия.

Чтобы начать работу, выполните следующие действия:

1. Запустите Visual Studio для Mac:

    [![](hello-mac-images/setup01.png "Основной интерфейс Visual Studio для Mac")](hello-mac-images/setup01.png#lightbox)

2. В верхнем левом углу экрана щелкните ссылку **Создать решение...**, чтобы открыть диалоговое окно **Новый проект**:

    [![](hello-mac-images/setup03.png "Создание решения в Visual Studio для Mac")](hello-mac-images/setup02.png#lightbox)

3. Выберите **Mac** > **Приложения** > **Приложение Cocoa** и нажмите кнопку **Далее**:

    [![](hello-mac-images/setup03.png "Выбор приложения Cocoa")](hello-mac-images/setup03.png#lightbox)

4. Введите `Hello_Mac` в поле **Имя приложения** и оставьте все остальные значения по умолчанию. Нажмите кнопку **Далее**:

    [![](hello-mac-images/setup05.png "Задание имени приложения")](hello-mac-images/setup05.png#lightbox)

4. При создании решения, содержащего несколько разных проектов, может потребоваться задать другое значение в поле **Имя решения**, но для данного примера оставим значение по умолчанию, совпадающее с указанным в поле **Имя проекта**:

    [![](hello-mac-images/setup04.png "Проверка сведений о новом решении")](hello-mac-images/setup04.png#lightbox)

5. Нажмите кнопку **Создать**.

В Visual Studio для Mac будет создано приложение Xamarin.Mac и отобразятся файлы по умолчанию, добавляемые в решение приложения:

 [![](hello-mac-images/project01.png "Представление по умолчанию для нового решения")](hello-mac-images/project01.png#lightbox)

Visual Studio для Mac использует **решения** и **проекты** точно так же, как Visual Studio. Решение представляет собой контейнер, который может содержать один или несколько проектов; проекты могут включать в себя приложения, вспомогательные библиотеки, тестовые приложения и т. д. В этом случае в Visual Studio для Mac решение и проект приложения были созданы автоматически.

При необходимости можно создать один или несколько проектов библиотек кода, содержащих общий код. Эти проекты библиотек могут использоваться в проекте приложения или быть общими для других проектов приложений Xamarin.Mac (или в зависимости от типа кода — для Xamarin.iOS и Xamarin.Android) так же, как стандартное приложение .NET.

<a name="The_Project" />

## <a name="anatomy-of-a-xamarinmac-application"></a>Структура приложения Xamarin.Mac

Если вы знакомы с iOS-программированием, вы обнаружите здесь много общего. По сути, iOS использует платформу CocoaTouch, облегченную версию Cocoa для Mac, поэтому многие основные понятия будут пересекаться.

Взгляните на файлы в проекте:

-   `Main.cs` — этот файл содержит основную точку входа приложения. При запуске приложения она содержит самый первый класс и выполняемый метод.
-   `AppDelegate.cs` — этот файл содержит основной класс приложения, который отвечает за прослушивание событий из операционной системы.
-   `Info.plist` — этот файл содержит свойства приложения, такие как имя приложения, значки и т. д.
-   `Entitlements.plist` — этот файл содержит назначения для приложения и позволяет обращаться к таким компонентам, как песочница и iCloud.
-  `Main.storyboard` — определяет пользовательский интерфейс (окна и меню) для приложения и выполняет компоновку внутренних соединений между Windows через Segues. Раскадровки представляют собой XML-файлы, которые содержат определение представлений (элементов пользовательского интерфейса). Этот файл создается и обслуживается с помощью конструктора Interface Builder в Xcode.
-   `ViewController.cs` — это контроллер для главного окна. Контроллеры будут подробно рассматриваться в другой статье, а в нашем случае он считается основным механизмом любого конкретного представления.
-   `ViewController.designer.cs` — этот файл содержит соединительный код, который позволяет выполнять интеграцию с пользовательским интерфейсом главного экрана.

Краткое описание некоторых файлов будет приведено в разделах ниже. Позже мы рассмотрим их более подробно, однако понять их основы следует именно сейчас.

<a name="Main_cs" />

### <a name="maincs"></a>Main.cs

Файл **Main.cs** очень прост. Он содержит статический метод `Main`, создающий экземпляр приложения Xamarin.Mac и передающий имя класса, который будет обрабатывать события операционной системы. В данном случае это класс `AppDelegate`:

```csharp
using System;
using System.Drawing;
using Foundation;
using AppKit;
using ObjCRuntime;

namespace Hello_Mac
{
        class MainClass
        {
                static void Main (string[] args)
                {
                        NSApplication.Init ();
                        NSApplication.Main (args);
                }
        }
}
```

<a name="AppDelegate_cs" />

### <a name="appdelegatecs"></a>AppDelegate.cs

Файл `AppDelegate.cs` содержит класс `AppDelegate`, который отвечает за создание окон и прослушивание событий операционной системы:

```csharp
using AppKit;
using Foundation;

namespace Hello_Mac
{
    [Register ("AppDelegate")]
    public class AppDelegate : NSApplicationDelegate
    {
        public AppDelegate ()
        {
        }

        public override void DidFinishLaunching (NSNotification notification)
        {
            // Insert code here to initialize your application
        }

        public override void WillTerminate (NSNotification notification)
        {
            // Insert code here to tear down your application
        }
    }
}
```

Возможно, этот код вам незнаком, если вы не создавали приложения iOS ранее, но он довольно прост.

Метод `DidFinishLaunching` выполняется после создания экземпляра приложения и отвечает за фактическое создание окна приложения и запуск процесса отображения представления в этом окне.

Метод `WillTerminate` вызывается после того, как пользователь или система инициировали завершение работы приложения. Этот метод следует использовать для завершения работы приложения перед его закрытием (например, сохранение настроек пользователя или размера и расположения окна).

<a name="ViewController_cs" />

### <a name="viewcontrollercs"></a>ViewController.cs

В Cocoa (и производной платформе CocoaTouch) используется шаблон *Model View Controller* (MVC). Объявление `ViewController` представляет объект для управления фактическим окном приложения. Как правило, для каждого созданного окна (и для многих других задач, выполняемых в окнах) существует контроллер, который отвечает за жизненный цикл окна, например за его отображение, добавление в него новых представлений (элементов управления) и т. д.

Класс `ViewController` является контроллером главного окна. Это означает, что он отвечает за жизненный цикл главного окна. Этот вопрос будет подробно рассматриваться позднее, а сейчас мы лишь быстро взглянем на этот класс:

```csharp
using System;

using AppKit;
using Foundation;

namespace Hello_Mac
{
    public partial class ViewController : NSViewController
    {
        public ViewController (IntPtr handle) : base (handle)
        {
        }

        public override void ViewDidLoad ()
        {
            base.ViewDidLoad ();

            // Do any additional setup after loading the view.
        }

        public override NSObject RepresentedObject {
            get {
                return base.RepresentedObject;
            }
            set {
                base.RepresentedObject = value;
                // Update the view, if already loaded.
            }
        }
    }
}
```

<a name="ViewController_Designer_cs" />

### <a name="viewcontrollerdesignercs"></a>ViewController.Designer.cs

Файл конструктора для класса главного окна сейчас пуст, но Visual Studio для Mac будет автоматически заполнять его в процессе создания пользовательского интерфейса с помощью конструктора Interface Builder в Xcode:

```csharp
// WARNING
//
// This file has been generated automatically by Visual Studio for Mac to store outlets and
// actions made in the UI designer. If it is removed, they will be lost.
// Manual changes to this file may not be handled correctly.
//
using Foundation;

namespace Hello_Mac
{
    [Register ("ViewController")]
    partial class ViewController
    {
        void ReleaseDesignerOutlets ()
        {
        }
    }
}
```

Разработчика обычно не интересуют файлы конструктора, так как ими автоматически управляет Visual Studio для Mac и они предоставляют требуемый соединительный код, обеспечивающий доступ к элементам управления, которые были добавлены в любое окно или представление в приложении.

Создав проект приложения Xamarin.Mac и получив основное представление о его компонентах, можно переключиться в Xcode для создания пользовательского интерфейса с помощью конструктора Interface Builder.

<a name="Info_plist" />

### <a name="infoplist"></a>Info.plist

Файл `Info.plist` содержит такие сведения о приложении Xamarin.Mac, как его **имя** и **идентификатор пакета**:

[![](hello-mac-images/infoplist01.png "Редактор plist в Visual Studio для Mac")](hello-mac-images/infoplist01.png#lightbox)

А также определяет _раскадровку_, которая будет использоваться для отображения пользовательского интерфейса приложения Xamarin.Mac в раскрывающемся списке **Главный интерфейс**. В приведенном выше примере `Main` в раскрывающемся списке относится к `Main.storyboard` в дереве исходного кода проекта в **обозревателе решений**. Он также определяет значки приложения, указывая содержащий их *каталог ресурсов* (в данном случае AppIcons).

### <a name="entitlementsplist"></a>Entitlements.plist

Файл `Entitlements.plist` приложения управляет назначениями в приложении Xamarin.Mac, такими как **песочница** и **iCloud**:

[![](hello-mac-images/entitlements01.png "Редактор назначений Visual Studio для Mac")](hello-mac-images/entitlements01.png#lightbox)

Для примера Hello World назначения не потребуются. В следующем разделе показывается использование Interface Builder в Xcode для изменения файла `Main.storyboard` и определения пользовательского интерфейса приложения Xamarin.Mac.

<a name="Introduction_to_Xcode_and_Interface_Builder" />

## <a name="introduction-to-xcode-and-interface-builder"></a>Общие сведения об Xcode и конструкторе интерфейсов Interface Builder

Компания Apple создала входящий в Xcode инструмент, который называется конструктором Interface Builder и позволяет визуально создавать пользовательский интерфейс в конструкторе. Xamarin.Mac свободно интегрируется с конструктором Interface Builder, поэтому для создания пользовательского интерфейса применяются те же средства, что и в Objective-C.

Чтобы приступить к работе, дважды щелкните файл `Main.storyboard` в **обозревателе решений**, чтобы открыть его для редактирования в Xcode и конструкторе Interface Builder:

[![](hello-mac-images/xcode01.png "Файл Main.storyboard в обозревателе решений")](hello-mac-images/xcode01.png#lightbox)

Запустится среда Xcode, которая будет выглядеть приблизительно так, как показано ниже:

[![](hello-mac-images/xcode02.png "Представление по умолчанию конструктора Interface Builder Xcode")](hello-mac-images/xcode02.png#lightbox)

Перед началом разработки интерфейса кратко ознакомьтесь с Xcode, чтобы получить представление об основных используемых компонентах.

> [!NOTE]
> Примечание. Вам не нужно использовать Xcode и конструктор Interface Builder, чтобы создать пользовательский интерфейс для приложения Xamarin.Mac. Это можно сделать непосредственно из кода C# (в статье это не описано). Для простоты в оставшейся части этого учебника будет использоваться конструктор Interface Builder.


<a name="Components_of_Xcode" />

### <a name="components-of-xcode"></a>Компоненты Xcode

Файл `.storyboard`, открытый в Xcode из Visual Studio для Mac, будет содержать **навигатор проекта** в левой части, **иерархию интерфейса** и **редактор интерфейса** в средней части и раздел **Свойства и служебные программы** в правой части:

[![](hello-mac-images/xcode03.png "Различные разделы конструктора Interface Builder в Xcode")](hello-mac-images/xcode03.png#lightbox)

В следующих разделах рассматриваются функции каждого компонента Xcode и их использование для создания интерфейса приложения Xamarin.Mac.

<a name="Project_Navigation" />

### <a name="project-navigation"></a>Навигация по проекту

При открытии файла `.storyboard` для редактирования в Xcode в Visual Studio для Mac в фоновом режиме создается *файл проекта Xcode* для передачи изменений между самой средой и Xcode. При возврате из Xcode в Visual Studio для Mac все изменения, внесенные в этот проект, синхронизируются с проектом Xamarin.Mac.

В разделе **Навигация по проекту** можно перемещаться между всеми файлами, составляющими _оболочку_ проекта Xcode. Как правило, в этом списке интерес представляют только файлы `.storyboard`, такие как `Main.storyboard`.

<a name="Interface_Hierarchy" />

### <a name="interface-hierarchy"></a>Иерархия интерфейса

В разделе **Иерархия интерфейса** можно легко получить доступ к нескольким ключевым группам пользовательского интерфейса, таким как **Заполнители** и главное **Окно**. Данный раздел можно использовать для обращения к отдельным элементам (представлениям), составляющим пользовательский интерфейс, и корректировки их вложенности путем перетаскивания в рамках иерархии.

<a name="Interface_Editor" />

### <a name="interface-editor"></a>Редактор интерфейса

В разделе **Редактор интерфейса** находится область для графического представления пользовательского интерфейса. Проект интерфейса создается путем перетаскивания элементов из раздела **Библиотека** в разделе **Свойства и служебные программы**. Элементы пользовательского интерфейса (представления), добавляемые в область конструктора, будут добавлены в раздел **Иерархия интерфейса** в том порядке, в котором они отображаются в разделе **Редактор интерфейса**.

<a name="Properties_Utilities" />

### <a name="properties--utilities"></a>Свойства и служебные программы

Раздел **Свойства и служебные программы** состоит из двух основных разделов — **Свойства** (также называемые инспекторами) и **Библиотека**:

[![](hello-mac-images/xcode04.png "Инспектор свойств")](hello-mac-images/xcode04.png#lightbox)

Изначально этот раздел практически пуст, однако если выбрать элемент в разделе **Редактор интерфейса** или в разделе **Иерархия интерфейса**, раздел **Свойства** будет заполняться сведениями о выбранном элементе и настраиваемыми свойствами.

В разделе **Свойства** находится восемь разных *вкладок инспекторов*, как показано на следующем рисунке:

[![](hello-mac-images/xcode05.png "Обзор всех инспекторов")](hello-mac-images/xcode05.png#lightbox)

<a name="Properties_Utility_Types" />

### <a name="properties--utility-types"></a>Типы свойств и служебных программ

Слева направо располагаются следующие вкладки:

-   **Инспектор файлов.** Инспектор файлов отображает сведения о файле, такие как имя файла и расположение редактируемого XIB-файла.
-   **Экспресс-справка.** На вкладке "Экспресс-справка" содержится контекстная справка по компоненту или функции, выбранной в Xcode.
-   **Инспектор удостоверений.** Инспектор удостоверений предоставляет сведения о выбранном элементе управления или представлении.
-   **Инспектор атрибутов.** Инспектор атрибутов позволяет настраивать различные атрибуты выбранного элемента управления или представления.
-   **Инспектор размеров.** Инспектор размеров позволяет управлять размером и поведением изменения размера выбранного элемента управления или представления.
-   **Инспектор подключений.** Инспектор подключений показывает подключения **переменной экземпляра** и **действия** выбранных элементов управления. Переменные экземпляров и действия будут подробно рассматриваться далее.
-   **Инспектор привязок.** Инспектор привязок позволяет настраивать элементы управления таким образом, чтобы их значения автоматически привязывались к моделям данных.
-   **Инспектор эффектов представления.** Инспектор эффектов представления позволяет указывать эффекты (например, анимации) в элементах управления.

Воспользуйтесь разделом **Библиотека** для поиска элементов управления и объектов, размещаемых в конструкторе для графического построения пользовательского интерфейса:

[![](hello-mac-images/xcode06.png "Инспектор библиотеки Xcode")](hello-mac-images/xcode06.png#lightbox)

<a name="Creating_the_Interface" />

## <a name="creating-the-interface"></a>Создание интерфейса

Ознакомившись с основными компонентами интегрированной среды разработки Xcode и конструктора Interface Builder, можно приступить к созданию пользовательского интерфейса для основного представления.

Выполните следующие действия:

1. В Xcode перетащите **нажимную кнопку**  из **раздела "Библиотека"**:

    [![](hello-mac-images/xcode07.png "Выбор NSButton в инспекторе библиотеки")](hello-mac-images/xcode07.png#lightbox)

2. Поместите кнопку в узел **Представление** (в разделе **Контроллер окна**) в **редакторе интерфейса**:

    [![](hello-mac-images/xcode08.png "Добавление кнопки в проект интерфейса")](hello-mac-images/xcode08.png#lightbox)

3. Щелкните свойство **Название** в **инспекторе атрибутов** и измените название кнопки на `Click Me`:

    [![](hello-mac-images/xcode09.png "Задание свойств кнопки")](hello-mac-images/xcode09.png#lightbox)

4. Перетащите **метку** из **раздела "Библиотека"**:

    [![](hello-mac-images/xcode10.png "Выбор метки в инспекторе библиотеки")](hello-mac-images/xcode10.png#lightbox)

5. Поместите метку в область **Окно** рядом с кнопкой в **редакторе интерфейса**:

    [![](hello-mac-images/xcode11.png "Добавление метки в проект интерфейса")](hello-mac-images/xcode11.png#lightbox)

6. Захватите правый маркер метки и перетаскивайте его до границы окна:

    [![](hello-mac-images/xcode12.png "Изменение размера метки")](hello-mac-images/xcode12.png#lightbox)

7. Выберите кнопку, только что добавленную в **редактор интерфейса**, и щелкните значок **редактора ограничений** в нижней части окна:

    [![](hello-mac-images/xcode13.png "Добавление ограничений к кнопке")](hello-mac-images/xcode13.png#lightbox)

8. В верхней части редактора щелкните **красные I-образные указатели**, направленные вверх и влево. После изменения размера окна кнопка останется в том же расположении в левом верхнем углу экрана.

9. Затем установите флажки **Высота** и **Ширина**, чтобы использовать размеры по умолчанию. При изменении размера окна кнопка сохранит свой размер.

10. Нажмите кнопку **Добавить 4 ограничения**, чтобы добавить ограничения и закрыть редактор.

11. Выделите элемент "Метка" и еще раз щелкните значок **Редактор ограничений**:

    [![](hello-mac-images/xcode14.png "Добавление ограничений к метке")](hello-mac-images/xcode14.png#lightbox)

12. При щелчке **красных I-образных указателей**, направленных вверх, вправо и влево в **редакторе ограничений**, метка закрепляется в заданных позициях X и Y и увеличивается и уменьшается при изменении размера окна в запущенном приложении.

13. Снова установите флажок **Высота** и примите значение по умолчанию, а затем нажмите кнопку **Добавить 4 ограничения**, чтобы добавить ограничения и закрыть редактор.

14. Сохраните изменения пользовательского интерфейса.

При изменении размера и перемещении элементов управления обратите внимание на полезные подсказки конструктора Interface Builder, основанные на [рекомендациях по работе с человеческим интерфейсом OS X](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/). Эти рекомендации помогут создавать высококачественные приложения, которые будут иметь внешний вид и интерфейс, знакомый пользователям Mac.

Взгляните на раздел **Иерархия интерфейса**, чтобы увидеть компоновку и иерархию элементов, составляющих пользовательский интерфейс:

[![](hello-mac-images/xcode15.png "Выбор элемента в иерархии интерфейса")](hello-mac-images/xcode15.png#lightbox)

Здесь можно выбирать элементы для редактирования или перетаскивать элементы для изменения их порядка. Например, если элемент пользовательского интерфейса перекрыт другим элементом, его можно перетащить в нижнюю часть списка, чтобы сделать самым верхним элементом в окне.

После создания пользовательского интерфейса потребуется предоставить доступ к его элементам, чтобы Xamarin.Mac мог обращаться к ним и взаимодействовать с ними в коде C#. Эта задача будет рассматриваться в следующем разделе о **переменных экземпляров и действиях**.

<a name="Outlets_and_Actions" />

### <a name="outlets-and-actions"></a>Переменные экземпляров и действия

Что такое **переменные экземпляров** и **действия**? В традиционном программировании пользовательского интерфейса .NET добавляемый элемент управления в пользовательском интерфейсе автоматически предоставляется как свойство. В Mac это работает по-другому — простое добавление элемента управления в представление не делает его доступным для кода. Необходимо явно предоставить элемент пользовательского интерфейса в код. Для этого Apple предлагает два указанных далее варианта:

-   **Переменные экземпляров.** Они аналогичны свойствам. Если элемент управления привязывается к переменной экземпляра, она предоставляется в код через свойство, поэтому можно выполнять такие действия, как присоединять обработчики событий, вызывать методы и т. д.
-   **Действия.** Они аналогичны командам в WPF. Например, при выполнении действия в элементе управления (например, нажатие кнопки) элемент управления автоматически вызовет метод в коде. Действия являются мощным и удобным механизмом, поскольку позволяют привязывать много элементов управления к одному действию.

В Xcode **переменные экземпляров** и **действия** добавляются непосредственно в код путем *нажатия клавиши CTRL и перетаскиванием*. Это означает, что для создания **переменной экземпляра** или **действия** следует выбрать элемент управления, к которому нужно добавить **переменную экземпляра** или **действие**, и, удерживая нажатой клавишу **CTRL** на клавиатуре, перетащить этот элемент управления непосредственно в код.

Для разработчиков Xamarin.Mac это означает, что элемент управления будет перетаскиваться в файлы заглушки Objective-C, которые соответствуют файлу C#, где нужно создать **переменную экземпляра** или **действие**. В Visual Studio для Mac создан файл `ViewController.h` как часть проекта оболочки Xcode, сгенерированного для использования конструктора Interface Builder:

[![](hello-mac-images/xcode16.png "Просмотр исходного кода в Xcode")](hello-mac-images/xcode16.png#lightbox)

Этот файл заглушки `.h` соответствует `ViewController.designer.cs`, который автоматически добавляется в проект Xamarin.Mac при создании `NSWindow`. Этот файл будет использоваться для синхронизации изменений, внесенных конструктором Interface Builder. Кроме того, в нем создаются **переменные экземпляров** и **действия** для предоставления элементов пользовательского интерфейса в код C#.

<a name="Adding_an_Outlet" />

#### <a name="adding-an-outlet"></a>Добавление переменной экземпляра

Получив общее представление о **переменных экземпляров** и **действиях**, можно создать **переменную экземпляра** для предоставления созданной метки в код C#.

Выполните следующие действия:

1. В Xcode в правом верхнем углу экрана нажмите кнопку с изображением **двойного круга**, чтобы открыть **вспомогательный редактор**:

    [![](hello-mac-images/outlet01.png "Отображение вспомогательного редактора")](hello-mac-images/outlet01.png#lightbox)

2. Xcode переключится в комбинированный режим, где в одной стороне находится **редактор интерфейса**, а в другой — **редактор кода**.

3. Обратите внимание, что в Xcode в **редакторе кода** автоматически выбран файл **ViewController.m**, который нам не нужен. Принимая во внимание приведенные выше сведения о **переменных экземпляров** и **действиях**, необходимо выбрать файл **ViewController.h**.

4. В верхней части **редактора кода** щелкните **автоматическую ссылку** и выберите файл `ViewController.h`:

    [![](hello-mac-images/outlet02.png "Выбор нужного файла")](hello-mac-images/outlet02.png#lightbox)

5. Теперь в Xcode должен быть выбран правильный файл:

    [![](hello-mac-images/outlet03.png "Просмотр файла ViewController.h")](hello-mac-images/outlet03.png#lightbox)

6. **Последнее действие было очень важным!** Если выбрать неправильный файл, будет невозможно создать **переменные экземпляров** и **действия** либо они будут предоставлены в неправильный класс на C#!

7. Перейдите в **редактор интерфейса** и, удерживая нажатой клавишу **CTPL** на клавиатуре, щелкните и перетащите созданную метку в редактор кода сразу же под код `@interface ViewController : NSViewController {}`:

    [![](hello-mac-images/outlet04.png "Перетаскивание для создания переменной экземпляра")](hello-mac-images/outlet04.png#lightbox)

8. Откроется диалоговое окно. Оставьте в поле **Подключение** значение **Переменная экземпляра** и введите `ClickedLabel` в поле **Имя**:

    [![](hello-mac-images/outlet05.png "Определение переменной экземпляра")](hello-mac-images/outlet05.png#lightbox)

9. Нажмите кнопку **Подключить**, чтобы создать **переменную экземпляра**:

    [![](hello-mac-images/outlet06.png "Просмотр итоговой переменной экземпляра")](hello-mac-images/outlet06.png#lightbox)

10. Сохраните изменения в файле.

<a name="Adding_an_Action" />

#### <a name="adding-an-action"></a>Добавление действия

Далее следует предоставить кнопку в код C#. Так же, как и метку выше, к **переменной экземпляра** можно привязать кнопку. Поскольку нам необходимо реагировать на нажимаемую кнопку, необходимо воспользоваться **действием**.

Выполните следующие действия:

1. Убедитесь, что Xcode по-прежнему находится во **вспомогательном редакторе**, а в **редакторе кода** отображается файл **ViewController.h**.
2. Перейдите в **редактор интерфейса** и, удерживая нажатой клавишу **CTPL** на клавиатуре, щелкните и перетащите созданную кнопку в редактор кода сразу же под код `@property (assign) IBOutlet NSTextField *ClickedLabel;`:

    [![](hello-mac-images/action01.png "Перетаскивание для создания действия")](hello-mac-images/action01.png#lightbox)

3. Задайте параметру **Подключение** значение **Действие**:

    [![](hello-mac-images/action02.png "Определение действия")](hello-mac-images/action02.png#lightbox)

4. Введите `ClickedButton` в поле **Имя**:

    [![](hello-mac-images/action03.png "Именование нового действия")](hello-mac-images/action03.png#lightbox)

5. Нажмите кнопку **Подключить**, чтобы создать **действие**:

    [![](hello-mac-images/action04.png "Просмотр итогового действия")](hello-mac-images/action04.png#lightbox)

6. Сохраните изменения в файле.

Привязав пользовательский интерфейс и предоставив его в код C#, переключитесь в Visual Studio для Mac и позвольте среде синхронизировать изменения, внесенные в Xcode и конструктор Interface Builder.

> [!NOTE]
> Создание пользовательского интерфейса и **переменных экземпляров** и **действий** может занимать много времени и усилий. Но все это компенсируется получением новых знаний. После небольшой практики и работы с конструктором Interface Builder вы сможете создавать подобные интерфейсы и все **переменные экземпляров** и **действия** буквально за пару минут.

<a name="Synchronizing_Changes_with_Xcode" />

### <a name="synchronizing-changes-with-xcode"></a>Синхронизация изменений с Xcode

При возврате из Xcode в Visual Studio для Mac все изменения, внесенные в Xcode, автоматически синхронизируются с проектом Xamarin.Mac.

Выберите файл **ViewController.designer.cs** в **обозревателе решений**, чтобы увидеть, как **переменная экземпляра** и **действия** привязаны в коде C #:

[![](hello-mac-images/sync01.png "Синхронизация изменений с Xcode")](hello-mac-images/sync01.png#lightbox)

Обратите внимание, как два определения в файле **ViewController.designer.cs**

```csharp
[Outlet]
AppKit.NSTextField ClickedLabel { get; set; }

[Action ("ClickedButton:")]
partial void ClickedButton (Foundation.NSObject sender);
```

соответствуют определениям в файле `ViewController.h` в Xcode:

```csharp
@property (assign) IBOutlet NSTextField *ClickedLabel;
- (IBAction)ClickedButton:(id)sender;
```

Visual Studio для Mac прослушивает изменения файла **.h**, а затем автоматически синхронизирует их в соответствующем файле **.designer.cs** для предоставления в приложение. Обратите внимание, что **ViewController.designer.cs** является разделяемым классом, поэтому в Visual Studio для Mac не нужно изменять файл **ViewController.cs**, который перезапишет любые изменения, внесенные в класс.

Как правило, открывать файл **ViewController.designer.cs** никогда не потребуется. Он был представлен здесь только в целях обучения.

> [!NOTE]
> В большинстве случаев Visual Studio для Mac автоматически видит изменения, внесенные в Xcode, и синхронизирует их с проектом Xamarin.Mac. В ситуации, если синхронизация не выполняется автоматически, вернитесь в Xcode и затем обратно в Visual Studio для Mac. Обычно эти действия запускают цикл синхронизации.

<a name="Writing_the_Code" />

## <a name="writing-the-code"></a>Написание кода

Создав пользовательский интерфейс и предоставив его элементы в код с помощью **переменных экземпляров** и **действий**, можно написать код для реализации приложения.

В этом примере приложения при каждом нажатии кнопки метка будет обновляться для отображения количества раз нажатия. Для этого откройте файл `ViewController.cs` для редактирования, дважды щелкнув его в **обозревателе решений**:

[![](hello-mac-images/code01.png "Просмотр файла ViewController.cs в Visual Studio для Mac")](hello-mac-images/code01.png#lightbox)

Сначала создайте переменную уровня класса в классе `ViewController`, чтобы отслеживать количество сделанных нажатий. Измените определение класса и придайте ему следующий вид:

```csharp
namespace Hello_Mac
{
    public partial class ViewController : NSViewController
    {
        private int numberOfTimesClicked = 0;
        ...
```

Далее в этом же классе (`ViewController`) переопределите метод `ViewDidLoad` и добавьте код для задания начального сообщения для метки:

```csharp
public override void ViewDidLoad ()
{
    base.AwakeFromNib ();

    // Set the initial value for the label
    ClickedLabel.StringValue = "Button has not been clicked yet.";
}
```

Используйте `ViewDidLoad` вместо другого метода (например, `Initialize`), так как метод `ViewDidLoad` вызывается *после* того, как ОС загрузит и создаст пользовательский интерфейс из файла **.storyboard**. При попытке получить доступ к элементу управления метки до полной загрузки и создания файла **.storyboard** возникнет ошибка `NullReferenceException`, так как элемент управления метки еще не существует.

Затем добавьте код для реагирования на нажатие кнопки пользователем. В класс `ViewController` добавьте следующий разделяемый метод:

```csharp
partial void ClickedButton (Foundation.NSObject sender) {

    // Update counter and label
    ClickedLabel.StringValue = string.Format("The button has been clicked {0} time{1}.",++numberOfTimesClicked, (numberOfTimesClicked < 2) ? "" : "s");
}
```

Этот код присоединяется к **действию**, созданному в Xcode и конструкторе Interface Builder, и будет вызываться при каждом нажатии кнопки пользователем.

<a name="Testing_the_Application" />

## <a name="testing-the-application"></a>Тестирование приложения

Пришло время собрать и запустить приложение, чтобы убедиться, что оно работает должным образом. Сборку и запуск можно выполнить за один шаг либо собрать приложение, не запуская его.

При построении приложения можно выбрать тип сборки:

-   **Отладка.** Сборка отладки компилируется в **APP**-файл с множеством дополнительных метаданных, позволяющих проводить отладку во время выполнения приложения.
-   **Выпуск.** Сборка выпуска также создает **APP**-файл, но он не содержит отладочную информацию, поэтому он меньше и выполняется быстрее.

Тип сборки можно выбрать в **селекторе конфигурации** в верхнем левом углу экрана Visual Studio для Mac:

[![](hello-mac-images/run01.png "Выбор отладочной сборки")](hello-mac-images/run01.png#lightbox)

<a name="Building_the_Application" />

## <a name="building-the-application"></a>Построение приложения

В этом примере нам нужна сборка отладки, поэтому выберите тип **Отладка**. Сначала выполните сборку приложения — нажмите **⌘B** или в меню **Сборка** выберите пункт **Собрать все**.

Если ошибок нет, в строке Visual Studio для Mac появится сообщение **Сборка успешно завершена**. Если возникли ошибки, просмотрите проект и убедитесь, что описанные выше действия были выполнены правильно. Сначала убедитесь, что код (как в Xcode, так и в Visual Studio для Mac) соответствует коду в этом учебнике.

<a name="Running_the_Application" />

## <a name="running-the-application"></a>Запуск приложения

Существует три способа запуска приложения:

-  Нажмите сочетание клавиш **⌘ + ВВОД**.
-  В меню **Запуск** выберите **Отладка**.
-  На панели инструментов Visual Studio для Mac нажмите кнопку **Воспроизведение** (сразу над **обозревателем решений**).

Приложение будет собрано (если это еще не было сделано), запущено в режиме отладки и отобразит главное окно интерфейса:

[![](hello-mac-images/run02.png "Запуск приложения")](hello-mac-images/run02.png#lightbox)

Если кнопка была нажата несколько раз, метка должна обновиться и отобразит количество раз нажатия:

[![](hello-mac-images/run03.png "Отображение результатов нажатия кнопки")](hello-mac-images/run03.png#lightbox)

<a name="Where_to_Next" />

## <a name="where-to-next"></a>Дальнейшие действия

Изучив основы работы с приложением Xamarin.Mac, просмотрите следующие документы, чтобы получить более глубокие знания:

- [Введение в раскадровки](~/mac/platform/storyboards/index.md). В этой статье приводятся общие сведения о работе с раскадровками в приложении Xamarin.Mac. В ней описывается создание и обслуживание пользовательского интерфейса приложения с помощью раскадровок и конструктора Interface Builder.
- [Окна](~/mac/user-interface/window.md). В этой статье рассматривается работа с окнами и панелями в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании окон и панелей в Xcode и конструкторе Interface Builder, загрузка окон и панелей из XIB-файлов, использование окон и реагирование на окна в коде C#.
- [Диалоговые окна](~/mac/user-interface/dialog.md). В этой статье рассматривается работа с диалоговыми и модальными окнами в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании модальных окон в Xcode и конструкторе Interface Builder, работа со стандартными диалоговыми окнами, отображение окон и реагирование на них в коде C#.
- [Оповещения](~/mac/user-interface/alert.md). В этой статье рассматривается работа с оповещениями в приложении Xamarin.Mac. В ней содержатся сведения о создании и отображении оповещений из кода C# и реагирование на оповещения.
- [Меню](~/mac/user-interface/menu.md). Меню используются в различных частях пользовательского интерфейса приложения Mac. Доступен целый ряд меню — от главного меню приложения в верхней части экрана до всплывающих и контекстных меню, которые могут отображаться в любом месте окна. Меню являются неотъемлемой частью пользовательского интерфейса приложения Mac. В этой статье рассматривается работа с меню Cocoa в приложении Xamarin.Mac.
- [Панели инструментов](~/mac/user-interface/toolbar.md). В этой статье рассматривается работа с панелями инструментов в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании панелей инструментов в Xcode и конструкторе Interface Builder, предоставлении элементов панелей инструментов в код с помощью переменных экземпляров и действий, включении и отключении элементов панелей инструментов и реагировании на элементы панелей инструментов в коде C#.
- [Представления таблиц](~/mac/user-interface/table-view.md). В этой статье рассматривается работа с представлениями таблиц в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании представлений таблиц в Xcode и конструкторе Interface Builder, предоставлении элементов представлений таблиц в код с помощью переменных экземпляров и действий, заполнении элементов таблиц и реагировании на элементы представлений таблиц в коде C#.
- [Представления структур](~/mac/user-interface/outline-view.md). В этой статье рассматривается работа с представлениями структур в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании представлений структур в Xcode и конструкторе Interface Builder, предоставлении элементов представлений структур в код с помощью переменных экземпляров и действий, заполнении элементов структур и реагировании на элементы представлений структур в коде C#.
- [Списки источников](~/mac/user-interface/source-list.md). В этой статье рассматривается работа со списками источников в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании списков источников в Xcode и конструкторе Interface Builder, предоставлении элементов списков источников в код с помощью переменных экземпляров и действий, заполнении элементов списков источников и реагировании на элементы списков источников в коде C#.
- [Представления коллекций](~/mac/user-interface/collection-view.md). В этой статье рассматривается работа с представлениями коллекций в приложении Xamarin.Mac. В ней содержатся сведения о создании и обслуживании представлений коллекций в Xcode и конструкторе Interface Builder, предоставлении элементов представлений коллекций в код с помощью переменных экземпляров и действий, заполнении представлений коллекций и реагировании на представления коллекций в коде C#.
- [Работа с изображениями](~/mac/app-fundamentals/image.md). В этой статье рассматривается работа с изображениями и значками в приложении Xamarin.Mac. Здесь рассматривается создание и обслуживание изображений, необходимых для создания значка приложения, и использование изображений в коде C# и конструкторе Interface Builder для Xcode.

Рекомендуется также обратиться к [коллекции примеров Mac](https://developer.xamarin.com/samples/mac/all/), содержащей большой объем готового к использованию кода, который может помочь разработчику быстро создать с нуля проект Xamarin.Mac.

Пример законченного приложения Xamarin.Mac с множеством функций, характерных для стандартного приложения Mac, см. на странице [с примером приложения SourceWriter](https://developer.xamarin.com/samples/mac/SourceWriter/). SourceWriter — это простой редактор исходного кода, который предоставляет поддержку для автозавершения и выделения простого синтаксиса.

Код SourceWriter полностью закомментирован, и там, где это возможно, предоставлены ссылки из основных технологий и методов на соответствующую информацию в документации по руководствам для Xamarin.Mac.

## <a name="summary"></a>Сводка

В этой статье рассматривались основы стандартного приложения Xamarin.Mac. Здесь приводились сведения о создании приложения в Visual Studio для Mac, разработке пользовательского интерфейса в Xcode и конструкторе Interface Builder, предоставлении элементов пользовательского интерфейса в код C# с помощью **переменных экземпляров**  и **действий**, добавлении кода для работы с элементами пользовательского интерфейса и, наконец, о сборке и тестировании приложения Xamarin.Mac.

## <a name="related-links"></a>Связанные ссылки

- ["Привет, Mac" (пример)](https://developer.xamarin.com/samples/mac/Hello_Mac/)
- [Рекомендации по работе с человеческим интерфейсом OS X](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/OSXHIGuidelines/)
