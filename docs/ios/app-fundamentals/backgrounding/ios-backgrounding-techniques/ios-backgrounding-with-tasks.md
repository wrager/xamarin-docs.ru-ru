---
title: iOS Backgrounding с задачами
description: В этом документе описывается использование фоновых задач для выполнения длительных задач после помещения приложения в фоновом режиме.
ms.prod: xamarin
ms.assetid: 205D230E-C618-4D69-96EE-4B91D7819121
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.openlocfilehash: a95ca128bc6de7b2adc75511a581f5d2779d9c06
ms.sourcegitcommit: ea1dc12a3c2d7322f234997daacbfdb6ad542507
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/05/2018
ms.locfileid: "34784359"
---
# <a name="ios-backgrounding-with-tasks"></a>iOS Backgrounding с задачами

Самый простой способ выполнения backgrounding на iOS является разбиение backgrounding требований, задач и запускать задачи в фоновом режиме. Задачи находятся в строгом ограничение по времени и обычно получают около 600 секунд (10 минут) время обработки после приложения была перемещена в фоновом режиме в iOS 6 и не более 10 минут на iOS 7 +.

Фоновые задачи можно выделить на три категории:

1.  **Типизированный фоновой задачи** — вызывается в любом месте приложения, где имеется задача необходимо исключить из прерванной приложения следует ввести фона.
1.  **Задачи DidEnterBackground** — вызывается во время `DidEnterBackground` метода жизненного цикла приложений для очистки и сохранения состояния.
1.  **Фоновые передачи (iOS 7 +)** -это особый тип фоновая задача, используемая для выполнения объема сетевого трафика в iOS 7. В отличие от обычных задач фоновой передачи нет предопределенного предела времени.


Фон safe и `DidEnterBackground` задачи являются безопасными для использования на iOS 6 и iOS 7, с незначительными различиями. Давайте изучить эти два типа задач более подробно.

## <a name="creating-background-safe-tasks"></a>Создание безопасной фоновой задачи

Некоторые приложения содержат задачи, которые не должны быть прерваны iOS приложения следует изменить состояние. Чтобы зарегистрировать их в iOS как длительно выполняемых задач является одним из способов защиты от постороннего эти задачи. Можно использовать этот шаблон в любом месте в приложении где вы не хотите, что задача выполняется прерывание следует put пользователя приложения в фоновом режиме. Отличным кандидатом на этот шаблон будет задач, таких как сведения о регистрации нового пользователя отправки на сервер или проверка сведений об имени входа.

В следующем фрагменте кода демонстрируется регистрация задачу, которая будет выполняться в фоновом режиме:

```csharp
nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});

//runs on main or background thread
FinishLongRunningTask(taskID);

UIApplication.SharedApplication.EndBackgroundTask(taskID);
```

Процесс регистрации пары задач с уникальным идентификатором, `taskID`и заключает в оболочку в сопоставлении `BeginBackgroundTask` и `EndBackgroundTask` вызовов. Чтобы создать идентификатор, мы предоставим вызов `BeginBackgroundTask` метод `UIApplication` объекта, а затем запустить длительную задачу, обычно в новом потоке. По завершении задачи мы называем `EndBackgroundTask` и передайте тот же идентификатор. Это важно, поскольку iOS будет завершить работу приложения, если `BeginBackgroundTask` вызов не имеет соответствующего `EndBackgroundTask`.

> [!IMPORTANT]
> Типизированный фоновой задачи можно запускать на основной поток или в фоновом потоке, в зависимости от потребностей приложения.


## <a name="performing-tasks-during-didenterbackground"></a>Выполнение задач, во время DidEnterBackground

Помимо внесения фона safe длительную задачу, регистрации можно использовать для запуска задачи как приложение помещается в фоновом режиме. iOS предоставляет метод событий в *AppDelegate* класс с именем `DidEnterBackground` , можно использовать для сохранения состояния приложения, сохранить данные пользователя и шифровать конфиденциальное содержимое, прежде чем приложение перейдет в фоновом режиме. Приложение имеет приблизительно пять секунд до возврата из этого метода или получение завершается. Таким образом, задачи очистки, которые может занять более чем пяти секунд может быть вызвана внутри `DidEnterBackground` метод. Эти задачи следует вызвать в отдельном потоке.

Процесс практически идентичен регистрации длительную задачу. Это показано в следующем фрагменте кода в действии:

```csharp
public override void DidEnterBackground (UIApplication application) {
  nint taskID = UIApplication.SharedApplication.BeginBackgroundTask( () => {});
  new Task ( () => {
    DoWork();
    UIApplication.SharedApplication.EndBackgroundTask(taskID);
  }).Start();
}
```

Мы начинаем путем переопределения `DidEnterBackground` метод в `AppDelegate`, где необходимо зарегистрировать Наша задача через `BeginBackgroundTask` как это делалось в предыдущем примере. Затем мы создать новый поток и выполнять наши длительную задачу. Обратите внимание, что `EndBackgroundTask` теперь вызов из внутри длительную задачу, поскольку `DidEnterBackground` метод будет уже возвращена.

> [!IMPORTANT]
> операций ввода-вывода использует [контрольный механизм](http://developer.apple.com/library/ios/qa/qa1693/_index.html) для обеспечения быстрого реагирования пользовательского интерфейса приложения. Приложение слишком много времени, которое он затрачивает `DidEnterBackground` перестает отвечать в пользовательском Интерфейсе. В самом начале запуска заданий в фоновом режиме позволяет `DidEnterBackground` для возврата своевременно, обеспечении реагирования пользовательского интерфейса и предотвращать контрольного уничтожении приложения.


## <a name="handling-background-task-time-limits"></a>Ограничения по времени задач фоновой обработки

iOS устанавливает строгого ограничения как долго фоновую задачу можно запустить и если `EndBackgroundTask` вызов не выполняется за отведенное время, приложение будет завершено. Отслеживая остальных backgrounding времени и с помощью обработчиков истечение срока действия при необходимости, можно избежать завершения работы приложения iOS.

### <a name="accessing-background-time-remaining"></a>Доступ к оставшееся время фона

Если приложение с зарегистрированные задачи возвращает перемещаются в фоновом режиме, зарегистрированные задачи получит около 600 секунд для выполнения. Можно проверить, сколько времени может задачи для выполнения с помощью статического `BackgroundTimeRemaining` свойство `UIApplication` класса. Следующий код даст нам время в секундах, которое вышел из наших фоновой задачи:

```csharp
double timeRemaining = UIApplication.SharedApplication.BackgroundTimeRemaining;
```

### <a name="avoiding-app-termination-with-expiration-handlers"></a>Предотвращение завершение приложения с обработчиками истечение срока действия

Кроме того, что доступ к `BackgroundTimeRemaining` свойство, iOS предоставляет удобный способ обработки фона время истечение срока действия через **обработчик истечение срока действия**. Это необязательный блок кода, который будет выполняться при время, выделенное для задачи с истекающим сроком действия. Код в обработчике истечение срока действия вызывает `EndBackgroundTask` и передает идентификатор задачи, который указывает, что приложение работает хорошо и предотвращает завершение работы приложения, даже если задача не хватает времени операций ввода-вывода. `EndBackgroundTask` должен вызываться в обработчике истечение срока действия, а также в обычном режиме выполнения. 

Истечение срока действия обработчика выражается как анонимная функция, с помощью лямбда-выражения, как показано ниже:

```csharp
Task.Factory.StartNew( () => {

    //expirationHandler only called if background time allowed exceeded
    var taskId = UIApplication.SharedApplication.BeginBackgroundTask(() => {
        Console.WriteLine("Exhausted time");
        UIApplication.SharedApplication.EndBackgroundTask(taskId); 
    });
    while(myFlag == true)
    {
        Console.WriteLine(UIApplication.SharedApplication.TimeRemaining);
        myFlag = SomeCalculationNeedsMoreTime();
    }
    //Only called if loop terminated due to myFlag and not expiration of time
    UIApplication.SharedApplication.EndBackgroundTask(taskId);
});
```

Пока обработчики истечение срока действия не требуются для выполнения кода, следует всегда использовать обработчик истечение срока действия фоновых задач.

 <a name="background_tasks_in_iOS_7" />

## <a name="background-tasks-in-ios-7"></a>Фоновые задачи в iOS 7 +

Наиболее значительное изменение iOS 7 по отношению к фоновых задач является не задачи реализацией, но во время выполнения.

Помните, что перед iOS 7, задаче, в фоновом режиме были 600 секунд для завершения. Один это ограничение обусловлено тем, задачи в фоновом режиме будет хранить устройство переходит в спящий режим на время выполнения задачи:

 [![](ios-backgrounding-with-tasks-images/ios6.png "График задачи поддержание приложения переходит в спящий режим предварительного iOS 7")](ios-backgrounding-with-tasks-images/ios6.png#lightbox)

Фоновая обработка iOS 7 оптимизирован аккумулятора. В iOS 7 backgrounding становится нежестких: вместо сохранения устройство переходит в спящий режим, задачи при уважать устройство переходит в спящий режим и вместо этого выполнять их обработки в виде фрагментов, когда устройство выходит из спящего режима для обработки телефонных вызовов, уведомления, входящих сообщений электронной почты и другие Общие перерывы в работе. Следующая схема содержит представление о том, как задача может быть нарушена копии:

 [![](ios-backgrounding-with-tasks-images/ios7.png "График задачи разбивается на отдельные фрагменты после iOS 7")](ios-backgrounding-with-tasks-images/ios7.png#lightbox)

Так как время выполнения задачи не больше непрерывно, задач, выполняющих передачу по сети должны обрабатываться по-разному в iOS 7. Разработчики могут использовать `NSURlSession` API для обработки объема сетевого трафика. Следующий раздел содержит обзор фоновой передачи данных.

 <a name="background-transfers" />

## <a name="background-transfers"></a>Фоновая передача

Основа фоновой передачи в iOS 7 обновился `NSURLSession` API. `NSURLSession` позволяет создавать задачи для:

1.  Перенесите содержимое через перерывы в работе сети и устройства.
1.  Отправка и загрузка больших файлов ( *фоновая служба передачи* ).


Давайте рассмотрим это более подробно, как это работает.

### <a name="nsurlsession-api"></a>NSURLSession API

 `NSURLSession` — Это мощный API для передачи содержимого по сети. Она предоставляет набор средств для обработки переноса данных с помощью перерывы в работе сети и изменения состояния приложения.

`NSURLSession` API создает один или несколько сеансов, которые в свою очередь создать задачи для списка выбора блоки связанных данных по сети. Задачи выполняются асинхронно передавать данные быстро и надежно. Поскольку `NSURLSession` является асинхронным, каждый сеанс требует блок обработчика завершения, чтобы позволить системы и приложения о завершении передачи.

Чтобы выполнить передачу по сети, допустимые для предварительной iOS 7 и после iOS 7, проверьте, если `NSURLSession` доступен для постановки в очередь передачи и использовать регулярные фоновую задачу для передачи, если это не:

```csharp
if ([NSURLSession class]) {
  // Create a background session and enqueue transfers
}
else {
  // Start a background task and transfer directly
  // Do NOT make calls to update the UI here!
}
```

> [!IMPORTANT]
> Избегайте вызовов для обновления пользовательского интерфейса из фона в iOS 6-совместимого кода, iOS 6 не поддерживает обновления пользовательского интерфейса в фоновом режиме, а будет завершить приложение.


`NSURLSession` API-Интерфейс включает широкий набор функций для выполнения проверки подлинности, управления неудачных передач и отчеты об ошибках клиентские - но не серверные -. Это поможет моста перерывы в задаче запуска время, которые появились в iOS 7 и также обеспечивает поддержку для быстрой и надежной, передача больших файлов. Ниже более подробно рассматривается Эта вторая функция.

### <a name="background-transfer-service"></a>Фоновая служба передачи

До iOS 7 передачей или загрузкой файлов в фоновом режиме были недостоверными. Фоновые задачи получить ограниченное время для запуска, но время, необходимое для передачи файла зависит от сети и размера файла. В iOS 7, можно использовать `NSURLSession` успешно отправка и загрузка больших файлов. Конкретный `NSURLSession` тип сеанса, который обрабатывает сети передачи больших файлов в фоновом режиме, называется *фоновая служба передачи*.

Передача инициирована фоновой службы передачи данных под управлением операционной системы и предоставляет API для обработки ошибок и проверки подлинности. Поскольку передачи не связаны с произвольной предел времени, их можно использовать для отправки или загрузки больших файлов, автоматическое обновление содержимого в фоновом режиме и многое другое. Ссылаться на [фоновой передачи руководстве](~/ios/app-fundamentals/backgrounding/ios-backgrounding-walkthroughs/background-transfer-walkthrough.md) подробные сведения о реализации службы.

Фоновая служба передачи часто сопровождается выборки фона или удаленного уведомления для приложения обновить содержимое в фоновом режиме. В следующих двух разделах мы представляем концепцию регистрации всей приложениям выполняться в фоновом режиме на iOS 6 и iOS 7.

