---
title: "Touch в iOS"
ms.topic: article
ms.prod: xamarin
ms.assetid: DA666DC9-446E-4CD1-B5A0-C6FFBC7E53AD
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/18/2017
ms.openlocfilehash: 4e640979305a568649c59f6c75033296153b99de
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="touch-in-ios"></a>Touch в iOS

Важно понять события касания и touch API-интерфейсы в приложении iOS, как они имеют большое значение для всех физических взаимодействий с устройством. Включать все взаимодействия touch `UITouch` объекта. В этой статье будет показано, как использовать `UITouch` класс и его API-интерфейсы для поддержки касания. Более поздней версии мы расширим наших знаний, чтобы узнать, как поддержка жестов.

## <a name="enabling-touch"></a>Включение сенсорного ввода

Элементы управления в `UIKit` — этих подклассов из UIControl — зависят от так, что и жестов, встроенной в UIKit взаимодействие с пользователем, и поэтому не нужно включить касания. Уже включен.

Тем не менее многие из представления в `UIKit` имеют сенсорный ввод включен по умолчанию. Существует два способа включить касания элемента управления. Первый способ — флажок Включить взаимодействие пользователя в панели свойств iOS конструктора, как показано на следующем снимке экрана:

 [ ![](touch-in-ios-images/image1.png "Установите флажок Включить взаимодействие пользователя в панели свойств конструктора iOS")](touch-in-ios-images/image1.png)

Контроллер также можно использовать для задания `UserInteractionEnabled` свойство значение true в `UIView` класса. Это необходимо, если в коде создается пользовательский Интерфейс.

Следующая строка кода приведен пример:

```csharp
imgTouchMe.UserInteractionEnabled = true;
```

## <a name="touch-events"></a>События касания

Существует три этапа касаний, которые возникают, когда пользователь касается экрана перемещает пальцев и удаляет пальцев. Эти методы определяются в `UIResponder`, который является базовым классом для UIView. операций ввода-вывода будет переопределить соответствующие методы на `UIView` и `UIViewController` для обработки сенсорный ввод:

-  `TouchesBegan` — Вызывается, если сначала обрабатывается экрана.
-  `TouchesMoved` — Вызывается, если расположение изменения сенсорный ввод имени пользователя скользит их пальца по экрану.
-  `TouchesEnded` или `TouchesCancelled` — `TouchesEnded` вызывается, когда пальцы пользователя будут сняты с экрана.  `TouchesCancelled` Возвращает вызывается, если iOS отменяет сенсорного ввода — например, если пользователь слайды свой пальцем от отменить нажатие кнопки.


Touch рекурсивно движения события по стеку UIViews проверить событий сенсорного ввода в границах объекта представления. Это часто называется _попадания_. Они первый раз вызываться на самый верхний `UIView` или `UIViewController` и затем будут вызываться в `UIView` и `UIViewControllers` ниже их в иерархии представления.

Объект `UITouch` каждый раз, пользователь касается экрана будет создан объект. `UITouch` Объект включает в себя данные о сенсорного ввода, например сенсорный возникновения, где она произошла, если сенсорный считывание, и т. д. К событиям касания передается свойство штрихи — `NSSet` содержащий один или несколько штрихов. Мы это свойство используется для получения ссылки на сенсорном и определения ответа приложения.

Классы, переопределяющие одно из событий сенсорного ввода следует сначала вызвать базовую реализацию, а затем получите `UITouch` объекта, связанного с событием. Чтобы получить ссылку на первый сенсорный ввод, вызовите `AnyObject` свойство и приведите его как `UITouch` как показано в следующем примере:

```csharp
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    base.TouchesBegan (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    if (touch != null)
    {
        //code here to handle touch
    }
}
```

автоматически распознает iOS последовательными быстром касается на экране и собрать их все как одну tap в одном `UITouch` объекта. Это делает поиск двойного касания так же легко, как проверка `TapCount` свойства, как показано в следующем коде:

```csharp
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    base.TouchesBegan (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    if (touch != null)
    {
        if (touch.TapCount == 2)
        {
            // do something with the double touch.
        }
    }
}
```

## <a name="multi-touch"></a>Мультисенсорные

Мультисенсорные не включен по умолчанию для элементов управления. Мультисенсорные можно включить в конструкторе, iOS, как показано на следующем снимке экрана:

 [ ![](touch-in-ios-images/image2.png "Мультисенсорные включена в конструкторе iOS")](touch-in-ios-images/image2.png)

Также возможна установка мультисенсорные программным способом, задав `MultipleTouchEnabled` свойства, как показано в следующей строке кода:

```csharp
imgTouchMe.MultipleTouchEnabled = true;
```

Чтобы определить, сколько пальцами затронутых экрана, используйте `Count` свойство `UITouch` свойство:

```csharp
public override void TouchesBegan (NSSet touches, UIEvent evt)
{
    base.TouchesBegan (touches, evt);
    lblNumberOfFingers.Text = "Number of fingers: " + touches.Count.ToString();
}
```

## <a name="determining-touch-location"></a>Определение расположения сенсорного ввода

Метод `UITouch.LocationInView` возвращает CGPoint объект, содержащий координаты касания внутри данного представления. Кроме того, можно проверить является ли это расположение в элементе управления путем вызова метода `Frame.Contains`. В следующем фрагменте кода показан пример этого.

```csharp
if (this.imgTouchMe.Frame.Contains (touch.LocationInView (this.View)))
{
    // the touch event happened inside the UIView imgTouchMe.
}
```

Теперь, когда у нас есть представление событий сенсорного экрана операций ввода-вывода, давайте изучение распознавателей жестов.

## <a name="gesture-recognizers"></a>Распознаватель жестов

Распознаватель жестов можно значительно упростить и усилия при программировании для поддержки сенсорного ввода в приложении. распознаватель жестов iOS статистической обработки последовательность событий сенсорного ввода в событие, одним нажатием.

Xamarin.iOS предоставляет класс `UIGestureRecognizer` как базовый класс для следующих распознавателей жестов встроенных:

-  *UITapGesturesRecognizer* — это необходимо для одного или нескольких касания.
-  *UIPinchGestureRecognizer* — Pinching и распространение пальцы друг от друга.
-  *UIPanGestureRecognizer* — панорамирования или перетаскивания.
-  *UISwipeGestureRecognizer* — считывания в любом направлении.
-  *UIRotationGestureRecognizer* — поворот двух пальцев на ходу по часовой стрелке или против часовой стрелки.
-  *UILongPressGestureRecognizer* — нажатие и удерживание, иногда называют клавишу долго или щелчком долго.


Далее представлен базовый шаблон с помощью распознавателя.

1.  **Создать экземпляр распознаватель жестов** — сначала создать экземпляр `UIGestureRecognizer` подкласс. Объект, экземпляр которого создается будут связаны с помощью представления и будет собирать как мусор при удалении представления из. Создать это представление в виде переменной уровня класса необязательно.
1.  **Настройте параметры жестов** — следующий шаг — Настройка распознаватель жестов. Обратитесь к документации по Xamarin на `UIGestureRecognizer` и его подклассов список свойств, которые могут быть установлены для управления поведением `UIGestureRecognizer` экземпляра.
1.  **Настройка целевого объекта** — из-за его наследия Objective-C Xamarin.iOS не вызывают события, когда средство распознавания жестов соответствует жест.  `UIGestureRecognizer` метод — `AddTarget` —, которые могут принимать анонимного делегата или селектора Objective-C на код для выполнения при распознаватель жестов делает совпадение.
1.  **Включить средство распознавания жестов** — как и с событиями сенсорного ввода, жесты воспринимаются только при включении функции взаимодействия сенсорный ввод.
1.  **Добавить к представлению распознаватель жестов** — последним шагом является добавление жест в представление, вызвав `View.AddGestureRecognizer` и передачи ему объекта распознаватель жестов.

Ссылаться на [образцы распознаватель жестов](~/ios/app-fundamentals/touch/ios-touch-walkthrough.md#Gesture_Recognizer_Samples) Дополнительные сведения о том, как их реализации в коде.

При вызове целевой жестов, он будет передана ссылка жестов, возникшей. Это позволяет целевой жестов для получения сведений о жесте происхождения. Объем информации, доступной зависит от типа распознаватель жестов, который был использован. См. в разделе документации по Xamarin Дополнительные сведения о данных, доступных для каждого `UIGestureRecognizer` подкласс.

Важно помнить, что после добавления распознаватель жестов в представление представление (и какие-либо представления, расположенные под ней) не будут получать любые события касания. Чтобы разрешить события касания одновременно с помощью жестов, `CancelsTouchesInView` свойству необходимо присвоить значение false, как показано в следующем примере кода:

```csharp
_tapGesture.Recognizer.CancelsTouchesInView = false;
```

Каждый `UIGestureRecognizer` имеет состояние свойства, которое предоставляет важные сведения о состоянии распознаватель жестов. При каждом изменении значения данного свойства iOS вызовет подписки метод, задав для него обновления. Если пользовательского распознавателя никогда не обновляет свойство State, подписчика никогда не вызывается, подготовки к просмотру распознаватель жестов бесполезен.

Жестов можно интерпретировать как один из двух типов:

1.  *Дискретные* — эти жесты пожара первый тогда они распознаются.
1.  *Непрерывные* — эти жесты по-прежнему срабатывают до тех пор, пока они распознаются.


Распознавателей жестов находится в одном из следующих состояний:

-  *Возможные* — это начальное состояние распознавателей жестов. Это значение по умолчанию свойства State.
-  *Began* — при совпадении непрерывного жест Began присваивается состояние. Это позволяет различать при запуске распознавания жестов, и при изменении подписывается.
-  *Изменено* — после непрерывного жест было начато, но еще не завершен, состояние будет присвоено Changed каждый раз касание перемещается или изменяется, пока он по-прежнему в ожидаемом жеста.
-  *Отменено* — это состояние будет задано, если распознаватель учились Began изменены, а затем штрихи, больше не изменено таким образом, как для соответствия шаблону жеста.
-  *Распознается* — состояние будет установлено, если средство распознавания жестов соответствует набору штрихов и о подписчике об окончании жест.
-  *Завершен* — это псевдоним для состояния распознаны.
-  *Не удалось* — когда распознаватель жестов больше не может соответствовать штрихи, он прослушивает, состояние будет изменен на сбой.


Эти значения в представляет Xamarin.iOS `UIGestureRecognizerState` перечисления.

## <a name="working-with-multiple-gestures"></a>Работа с несколькими жесты

По умолчанию операций ввода-вывода не разрешают можно одновременно запускать с помощью жестов по умолчанию. Вместо этого каждый распознаватель жестов получит события касания недетерминированным образом. В следующем фрагменте кода показано, как заставить одновременно запустить средство распознавания жестов:

```csharp
gesture.ShouldRecognizeSimultaneously += (UIGestureRecognizer r) => { return true; };
```

Можно также отключить жестов в iOS. Существует два делегата свойства, позволяющие распознаватель жестов для изучения состояния приложения и текущих событий сенсорного ввода, чтобы принять решения о том, как и при должен распознаваться жест. Доступны следующие два события.

1.  *ShouldReceiveTouch* — этот делегат вызывается непосредственно перед распознаватель жестов передается событий сенсорного ввода и предоставляет возможность проверить изменения и решить, какие изменения будут обрабатываться распознаватель жестов.
1.  *ShouldBegin* — вызывается, когда распознаватель пытается изменить состояние из потенциальных на другое состояние. Возвращение значения false приведет к состояние меняется на сбой распознавания.


Можно переопределить эти методы со строгой типизацией `UIGestureRecognizerDelegate`, слабый делегат или привязку через синтаксис обработчика событий, как показано в следующем фрагменте кода:

```csharp
gesture.ShouldReceiveTouch += (UIGestureRecognizer r, UITouch t) => { return true; };
```

Наконец существует возможность очередь распознаватель жестов, так что он будет успешным, только если другое средство распознавания жестов завершается ошибкой. Например распознаватель жестов одним касанием должна выполняться только при сбое распознавателя двойного касания. В следующем фрагменте кода приведен пример этого.

```csharp
singleTapGesture.RequireGestureRecognizerToFail(doubleTapGesture);
```

## <a name="creating-a-custom-gesture"></a>Создание пользовательских жестов

Несмотря на то, что iOS предоставляет некоторые по умолчанию распознавателей жестов, может потребоваться создать распознаватели пользовательских жестов в определенных случаях. Создание пользовательского распознавателя включает в себя следующие шаги:

1.  Подкласс `UIGestureRecognizer` .
1.  Переопределите методы событий соответствующий сенсорный ввод.
1.  Всплывать распознавания состояние с помощью свойства State базового класса.


Практический пример будет рассматриваться в [iOS с помощью прикосновения](ios-touch-walkthrough.md) Пошаговое руководство.
