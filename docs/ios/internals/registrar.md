---
title: Тип регистратора
ms.prod: xamarin
ms.assetid: 610A0834-1141-4D09-A05E-B7ADF99462C5
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.openlocfilehash: 2504ab36ed9d387cdfccd5ac4d01c85d9bec7cf3
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/04/2018
---
# <a name="type-registrar"></a>Тип регистратора

Этот документ описывает регистрации система типов, используемых Xamarin.iOS.

## <a name="registration-of-managed-classes-and-methods"></a>Регистрация управляемых классов и методов

Во время запуска зарегистрирует Xamarin.iOS:

  - Классы с [[регистрация]](https://developer.xamarin.com/api/type/Foundation.RegisterAttribute/) атрибут в качестве цели C-классы.
  - Классы с [[категория]](https://developer.xamarin.com/api/type/CRuntime.CategoryAttribute) атрибут как Objective-C категорий.
  - Интерфейсы с [[Protocol]](https://developer.xamarin.com/api/type/Foundation.ProtocolAttribute/) атрибут как Objective-C протоколов.

и в каждой случаев члены с [[экспортировать]](https://developer.xamarin.com/api/type/Foundation.ExportAttribute/) атрибут экспортируются в цель-C. Это позволяет управляемых классов для создания управляемых методов, вызываемых из Objective-C и связанные методы и свойства между миром C# и Objective-C один способ.

Один очень простой пример является класс AppDelegate, который имеет каждое приложение. Можно увидеть, что управляемый метод Main есть строка такого рода:

    UIApplication.Main (args, null, "AppDelegate");

Это заставляет среду выполнения Objective-C для создания типа, называется «AppDelegate» как класс делегата приложения.  Для Objective-C среды выполнения о том, как создать экземпляр класса «AppDelegate», написанный на языке C# этот класс должен регистрироваться.

Среда выполнения Xamarin.iOS берет на себя регистрации, внутренне, регистрация может выполняться только во время выполнения (динамическая регистрация) или может выполняться во время компиляции (статические регистрация).  При таком динамическом подходе включает в себя с помощью отражения во время запуска, чтобы найти все классы и методы для регистрации и передайте их в среду выполнения Objective-C.  Статический подход проверка сборок, используемых приложением во время компиляции.  Он определяет классы и методы для регистрации в Objective-C и создает карту, которая будет включена в двоичный файл.  Затем во время запуска, необходимо зарегистрировать карты с Objective-C среды выполнения.

### <a name="categories"></a>Категории

Начиная с Xamarin.iOS 8.10 его будет невозможно создавать категории Objective-C с использованием синтаксиса C#.

Это делается с помощью атрибута [категория], указав тип для расширения в качестве аргумента для атрибута.
Следующий пример для экземпляра распространит NSString:

    [Category (typeof (NSString))]

Каждый метод категории использует стандартный механизм для экспорта методов в Objective-C с помощью атрибута [экспорта]:

    [Export ("today")]
    public static string Today ()
    {
        return "Today";
    }

Все методы управляемого расширения должны быть статическими, но можно создать методы экземпляра Objective-C, используя стандартный синтаксис для методов расширения в C#:

    [Export ("toUpper")]
    public static string ToUpper (this NSString self)
    {
        return self.ToString ().ToUpper ();
    }

и первый аргумент для метода расширения экземпляр, для которого был вызван метод.

Полный пример:

    [Category (typeof (NSString))]
    public static class MyStringCategory
    {
        [Export ("toUpper")]
        static string ToUpper (this NSString self)
        {
            return self.ToString ().ToUpper ();
        }
    }

Этот пример добавляет метод экземпляра собственного toUpper класс NSString, который может быть вызвана из цели-C.

    [Category (typeof (UIViewController))]
    public static class MyViewControllerCategory
    {
        [Export ("shouldAutoRotate")]
        static bool GlobalRotate ()
        {
            return true;
        }
    }

### <a name="protocols"></a>Протоколы

Начиная с Xamarin.iOS 8.10 интерфейсов с помощью атрибута [Protocol] будут экспортированы в Objective-C как протоколы.

Пример

    [Protocol ("MyProtocol")]
    interface IMyProtocol
    {
        [Export ("method")]
        void Method ();
    }

    class MyClass : IMyProtocol
    {
        void Method ()
        {
        }
    }

Это будут экспортированы в Objective-C, как протокол (MyProtocol) и класс (MyClass), который реализует протокол.

 **Динамическая регистрация**

используется для построения симулятор, как он ускоряется цикла сборки и отладки.  Это результат устраняя действия приводит к возникновению ошибки сопоставление классов и компиляция в этой таблице карты в запуска вашего приложения при каждом запуске приложения, и вместо запуска общего назначения используется каждый раз.  Компьютер имеет достаточно мощности для выполнения среды выполнения сканирования классов быстро, поэтому производительность не играет.

 **Статические регистрации**

предназначен для построений устройства, как мобильные устройства работают медленнее, чем настольных компьютеров и времени выполнения сканирования выполняется медленно.  Поскольку строит устройства всегда нужно будет создать новые двоичные файлы, сборки и отладки цикла не зависит от создания регистрации сопоставлении.

## <a name="new-registration-system"></a>Новая система регистрации

Начиная с 6.2.6 стабильной версии и версии бета-версии 6.3.4, мы добавили новый статический регистратора. В 7.2.1 версии мы внесли новый регистратор по умолчанию.

Это новая система регистрации предлагает следующие новые функции:

- Скомпилируйте время обнаружения ошибки программиста.
    - Два класса, который регистрируется с тем же именем.
    - Более одного метода экспорта реагировать на тот же селектор



- Можно удалить неиспользуемые машинного кода
    - В новой системе регистрации добавит строгих ссылок на код, используемый в статических библиотек, позволяя собственного компоновщику удалить неиспользуемые машинного кода из выходной двоичный файл.
      Для привязок образец Xamarin большинство приложений становятся менее 300k меньшего размера.

- Поддержка универсальных подклассов NSObject. В разделе [NSObject универсальных типов](~/ios/internals/api-design/nsobject-generics.md) Дополнительные сведения. Кроме того в новой системе регистрации будет перехватывать неподдерживаемые универсального конструкции, которые ранее могло привести непредвиденному поведению во время выполнения.

Далее представлено несколько примеров перехвачено новый registar ошибок:

Экспорт и тот же селектор более одного раза в том же классе.

```csharp
[Register]
class MyDemo : NSObject {
    [Export ("foo:")]
    void Foo (NSString str);
    [Export ("foo:")]
    void Foo (string str)
}
```

Экспорт нескольких управляемый класс с тем же именем Objective-C.

```csharp
[Register ("Class")]
class MyClass : NSObject {}

[Register ("Class")]
class YourClass : NSObject {}
```

Экспорт универсальных методов.

```csharp
[Register]
class MyDemo : NSObject {
    [Export ("foo")]
    void Foo<T> () {}
}
```



Необходимо иметь в виду новый регистратор следующее:
- Некоторые сторонние библиотеки должны быть обновлены для работы с новой системы регистрации, см. в разделе [необходимые изменения ниже](#required_modifications) для получения дополнительных сведений.
- Недостаток Краткосрочные также является что Clang следует использовать, если используется платформа учетных записей (это так, как только заголовок accounts.h Apple можно скомпилировать с Clang). Добавить <code>--compiler:clang</code> для mtouch дополнительные аргументы, используемые Clang, если ваш используете Xcode 4.6 или более ранней версии (Xamarin.iOS будут автоматически выбраны Clang Xcode 5.0 или более поздней версии).

    <li>Если Xcode 4.6 (или более ранней версии) используется GCC / G ++ должны быть выбраны, если экспортированный тип имена содержат недопустимые знаки (это, поскольку версии Clang поставляется с Xcode 4.6 не поддерживает отличные от ascii символы внутри идентификаторы в коде Objective-C). Добавить <code>--compiler:gcc</code> для mtouch дополнительные аргументы, используемые GCC.


## <a name="selecting-a-registrar"></a>Выбор регистратора

Можно выбрать другого регистратора, добавив один из следующих вариантов mtouch дополнительные аргументы в проект iOS параметры построения:

-  `--registrar:static` : по умолчанию для сборок устройств
-  `--registrar:dynamic` : по умолчанию для сборок в симуляторе
-  `--registrar:legacystatic` : по умолчанию для сборок устройств до Xamarin.iOS 7.2.1
-  `--registrar:legacydynamic` : по умолчанию для сборок симулятор до Xamarin.iOS 7.2.1


## <a name="shortcomings-in-the-old-registration-system"></a>Недостатки в старую систему регистрации

Старая система регистрации имеет следующие недостатки:

-  Возникла не (собственной) статическую ссылку на Objective-C классов и методов в собственные библиотеки сторонних разработчиков, которые означает, что мы не удалось запрашивать собственный компоновщику удаление сторонних разработчиков машинного кода, который не был использован фактически (так как все данные будут удалены). Это является причиной «-force_load libNative.a» в каждой привязке сторонних потребовалось выполнить (или эквивалентный ForceLoad = true в атрибуте [LinkWith]).
-  Можно экспортировать два управляемых типов, с тем же именем Objective-C без предупреждения. Чтобы завершить работу с двумя классами AppDelegate (в разных пространствах имен) был редко. Во время выполнения было бы полностью случайных какой из них подобранного (на самом деле, которую он разнообразными между запусками, даже не был перестроен - приложения, который сделан для более очень puzzling и утомительным отладки).
-  Можно экспортировать двух методов с такой же сигнатурой C к цели деятельности организации. До сих пор какой из них будет вызываться из Objective-C была случайных (но эта проблема не так часто, как и предыдущий, главным образом, так как был единственным способом фактически возникновении этой ошибки для переопределения unlucky управляемого метода).
-  Набор методов, которые были экспортированы была немного отличается между сборками динамических и статических.
-  Он не работает при экспорте универсальные классы (какие точное универсальную реализацию выполняется во время выполнения будет случайным образом эффективно в результате чего поведение не определено).


 <a name="required_modifications" />


## <a name="new-registrar-required-changes-to-bindings"></a>Новый регистратор: Изменения, необходимые для привязки


Существующие привязки Objective-C может потребоваться обновить для работы с новой registar.

Ниже приведен список изменений, которые необходимо выполнить.

### <a name="protocols-must-have-the-protocol-attribute"></a>Протоколы должен иметь атрибут [Protocol]

Протоколы реализации должна иметь атрибут [Protocol], применяемый к ним.  Если этого не сделать, вы будете Ошибка компоновщика собственного такого рода:

```csharp
Undefined symbols for architecture i386: "_OBJC_CLASS_$_ProtocolName", referenced from: ...
```

### <a name="selectors-must-have-a-valid-number-of-parameters"></a>Селекторы должен иметь допустимое число параметров

Все селекторы необходимо правильно указать число параметров.  Ранее эти ошибки были пропущены и может привести к проблемам среды выполнения.

Иными словами число двоеточий должен соответствует числу параметров.

Пример:

-  Без параметров: «foo»
-  Один параметр: "foo:"
-  Два параметра: "foo:parameterName2:"


Ниже приведены неправильное использование.

```csharp
// Invalid: export takes no arguments, but function expects one
[Export ("apply")]
void Apply (NSObject target);

// Invalid: exported as taking an argument, but the managed version does not have one:
[Export ("display:")]
void Display ();
```

### <a name="use-isvariadic-parameter-in-export"></a>Используйте параметр IsVariadic в файле экспорта

Функции с переменным числом аргументов должен настроены таким образом, в атрибуте экспорта (поскольку селектор ошибиться количество аргументов, т. е. пункт 2. ранее при нарушении):

```csharp
[Export ("variadicMethod:", IsVariadic = true)]
void VariadicMethod (NSObject first, IntPtr subsequent);
```

### <a name="must-link-to-existing-symbols"></a>Необходимо связать существующие символы

Это невозможно выполнить привязку классы, которые не существуют в собственной библиотеки.

Вы получите сообщение об ошибке компоновщика собственного при попытке привязать несуществующий классы.

Обычно это происходит, когда привязки выступает в течение некоторого времени, машинный код был изменен в течение этого времени, чтобы определенного собственного класса были удалены или переименованы во время привязки не были обновлены.

