---
title: "Архитектура iOS"
description: "Изучение Xamarin.iOS на низком уровне"
ms.topic: article
ms.prod: xamarin
ms.assetid: F40F2275-17DA-4B4D-9678-618FF25C6803
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/21/2017
ms.openlocfilehash: bf9d292acf43bbbe3e4ba76b5a264a11288b7225
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="ios-architecture"></a>Архитектура iOS

Xamarin.iOS приложения выполняются в среде Mono и использовать полной компиляции вперед от времени (AOT) для компиляции кода C# для языка ассемблера ARM. Эта процедура выполняется side-by-side с [Objective-C времени выполнения](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/). Обе эти среды выполнения работающие поверх ядро UNIX-подобные, в частности [XNU](https://en.wikipedia.org/wiki/XNU)и предоставляют различные интерфейсы API для пользовательского кода, благодаря чему разработчики могут получить доступ к базовой системы машинного или управляемого.

На схеме ниже показан общий обзор этой архитектуры:

[ ![](architecture-images/ios-arch-small.png "На этой диаграмме показаны общий обзор архитектуры компиляции вперед от времени (AOT)")](architecture-images/ios-arch.png)

## <a name="native-and-managed-code-an-explanation"></a>Машинного и управляемого кода: описание

При разработке для Xamarin условия *машинного и управляемого* кода часто используются. [Управляемый код](https://blogs.msdn.microsoft.com/brada/2004/01/09/what-is-managed-code/) — это код, выполнение управляется [.NET Framework Common Language Runtime](https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx), или в случае Xamarin: Mono среды выполнения. Это так называемый промежуточного языка.

Машинный код является код, который будет запускать на конкретную платформу (например, Objective-C или даже AOT компилируются в код, на микросхеме ARM). В этом руководстве рассматриваются как AOT компилирует управляемого кода в машинный код и объясняется, как работает приложение Xamarin.iOS, интенсивно использовать API-интерфейсы iOS Apple с помощью привязки, сохранив доступ к. В NET BCL и сложные языка, например C#.


## <a name="aot"></a>AOT

При компиляции любого приложения платформа Xamarin компилятора моно C# (или F #) будет выполнен и компиляции кода C# и F # в Майкрософт промежуточного языка MSIL. Если вы используете Xamarin.Android, приложение Xamarin.Mac или даже Xamarin.iOS приложения в имитаторе, [.NET Common Language Runtime (CLR)](https://msdn.microsoft.com/en-us/library/8bs2ecf4(v=vs.110).aspx) компиляции MSIL с помощью непосредственно в компиляторе Time (JIT). Во время выполнения это компилируется в машинный код, который можно запустить на правильной архитектуры для вашего приложения.

Однако есть ограничения безопасности на iOS, заданные Apple, который запрещает выполнение динамически создаваемый код на устройстве.
Чтобы убедиться, что придерживаться эти протоколы безопасности, Xamarin.iOS вместо использует вперед от времени АОТ компилятора для компиляции управляемого кода. В результате получается машинным кодом iOS двоичных данных, при необходимости оптимизирован с LLVM для устройств, которые могут быть развернуты на процессоре ARM под управлением Apple. Ниже показана грубой схемы как это сочетается друг с другом.

[ ![](architecture-images/aot.png "Как это сочетается друг с другом грубой схемы")](architecture-images/aot-large.png)

Использование AOT имеет ряд ограничений, которые подробно описаны в [ограничения](~/ios/internals/limitations.md) руководства. Он также предоставляет ряд улучшений за JIT через уменьшение времени запуска и различные оптимизации производительности

Теперь, когда мы изучили, как компиляции кода из источника в машинный код, давайте взглянем за кулисами, чтобы увидеть, каким образом Xamarin.iOS позволяет писать приложения, полностью машинным кодом iOS

## <a name="selectors"></a>Селекторы

С помощью Xamarin, у нас есть два отдельных экосистемы .NET и Apple, что нам нужно перевести вместе, чтобы казаться как упрощенный, как можно точнее, чтобы убедиться, что конечная цель — для удобства пользователей. Мы видели в разделе выше способ связи двух сред выполнения и очень хорошо нередко термина «привязки», позволяющего машинным кодом iOS API-интерфейсов для использования в Xamarin. Привязки рассматриваются в глубину, в нашей [привязки Objective-C](~/cross-platform/macios/binding/overview.md) документации, поэтому теперь давайте рассмотрим работу операций ввода-вывода за кулисами.

Во-первых есть ли способ предоставления Objective-C, в C#, который делается с помощью селектора. Список выбора — это сообщение, отправленных на объект или класс. С целью C это делается посредством [objc_msgSend](~/cross-platform/macios/binding/overview.md) функции.
Дополнительные сведения об использовании селекторы посвящены [селекторы Objective-C](~/ios/internals/objective-c-selectors.md) руководства. Также есть ли способ предоставления управляемого кода Objective-C, который намного сложнее тем, что Objective-C не знает, что-либо об управляемом коде. Чтобы обойти эту проблему, мы используем *регистраторов*. Это описано в следующем разделе более подробно.

## <a name="registrars"></a>Регистраторы

Как упоминалось выше, регистратор кода, предоставляет управляемому коду цель-C. Это делается путем создания списка любого управляемого класса, производного от NSObject:

- Для всех классов, которые не являются упаковки существующий класс Objective-C, он создает новый класс Objective-C с зеркального отображения все управляемые элементы, которые имеют члены Objective-C [`Export`] атрибута.

- В реализациях для каждого члена Objective-C код для вызова зеркальных управляемого элемента добавляется автоматически.

Ниже псевдокоде показан пример как это сделать:

**C# (управляемый код)**

```

 class MyViewController : UIViewController{
    [Export ("myFunc")]
    public void MyFunc ()
    {
    }
 }


```

**Objective-C:**

```csharp
@interface MyViewController : UIViewController { }

    -(void)myFunc;
@end @implementation

    MyViewController {}
    -(void) myFunc
    {
    /* code to call the managed MyViewController.MyFunc method */
    }
@end

```

Управляемый код может содержать атрибуты `[Register]` и `[Export]`, использующий регистратора знать, что объект должен предоставляться цель-C.
`[Register]` Атрибут используется для указания имени созданного класса Objective-C, в случае, если имя создаются по умолчанию не подходит. Все классы, производные от NSObject автоматически регистрируются с целью-C.
Необходимая `[Export]` атрибут содержит строку, которая будет использовать в созданном классе Objective-C селектором.

Существует два типа используется в Xamarin.iOS — динамических и статических регистраторов:


- **Динамические регистраторов** — динамический регистратора регистрации всех типов в сборку во время выполнения. Это делается с помощью функции, предоставляемые [API среды выполнения Objective-C](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/). Таким образом, динамические регистратора имеет медленнее запуска, но более быстрое время сборки. Это значение по умолчанию для симулятора iOS. При использовании динамического регистраторов, собственных функций (обычно в C), вызывается trampolines, используются в качестве реализации метода. Они отличаются в разных архитектур.

- **Статические регистраторов** — статический регистратора приводит к возникновению ошибки кода Objective-C во время построения, который затем компилируется в статическую библиотеку и связанных в исполняемый файл. Это позволяет для быстрого запуска, но занимает больше времени, во время построения. Используется по умолчанию для сборок устройств. Статические регистратора может использоваться с iOS simulator, передав `--registrar:static` как `mtouch` атрибута в параметры сборки проекта, как показано ниже:

    [ ![](architecture-images/image1.png "Настройка дополнительных mtouch аргументов")](architecture-images/image1.png)

Дополнительные сведения об особенностях iOS регистрация типа системы, используемой Xamarin.iOS посвящены [тип регистратора](~/ios/internals/registrar.md) руководства.

## <a name="application-launch"></a>Запуск приложения

Функция, вызываемая обеспечивается точку входа для всех исполняемых файлов Xamarin.iOS `xamarin_main`, который инициализирует mono.

В зависимости от типа проекта выполняется следующее:

- Для обычных операций ввода-вывода и tvOS приложений называется управляемого метода Main, предоставляемые приложение Xamarin. Это управляемый метод Main затем вызывает метод `UIApplication.Main`, который является точкой входа для цели-C. UIApplication.Main представляет собой привязку, для Objective-C `UIApplicationMain` метод.
- Для расширений собственной функции — `NSExtensionMain` или (`NSExtensionmain` для расширений WatchOS) — предоставленный компанией Apple называется библиотеки. Поскольку эти проекты библиотеки классов и не исполняемые проекты, нет других управляемых методов Main, для выполнения.

Все это последовательность запуска компилируется в статическую библиотеку, то связан в конечный исполняемый файл, приложение знает, как выйти нуля.

На этом этапе запуска нашего приложения, выполняется Mono, мы в управляемом коде и мы знаем, как вызывать машинный код и обеспечить возможность обратного вызова. Далее, что необходимо сделать — фактически начать добавлять элементы управления и обеспечивающие интерактивные приложения.


## <a name="generator"></a>Generator

Xamarin.iOS содержит определения для каждого один API iOS. Можно выполнять поиск любого из этих элементов на [MaciOS в репозитории github](https://github.com/xamarin/xamarin-macios/tree/master/src). Эти определения содержат интерфейсов с помощью атрибутов, а также все необходимые методы и свойства. Например, следующий код является используется для определения UIToolbar в UIKit [пространства имен](https://github.com/xamarin/xamarin-macios/blob/master/src/uikit.cs#L11277-L11327). Обратите внимание, что он является интерфейсом ряд методов и свойств:

```csharp
[BaseType (typeof (UIView))]
public interface UIToolbar : UIBarPositioning {
    [Export ("initWithFrame:")]
    IntPtr Constructor (CGRect frame);

    [Export ("barStyle")]
    UIBarStyle BarStyle { get; set; }

    [Export ("items", ArgumentSemantic.Copy)][NullAllowed]
    UIBarButtonItem [] Items { get; set; }

    [Export ("translucent", ArgumentSemantic.Assign)]
    bool Translucent { [Bind ("isTranslucent")] get; set; }

    // done manually so we can keep this "in sync" with 'Items' property
    //[Export ("setItems:animated:")][PostGet ("Items")]
    //void SetItems (UIBarButtonItem [] items, bool animated);

    [Since (5,0)]
    [Export ("setBackgroundImage:forToolbarPosition:barMetrics:")]
    [Appearance]
    void SetBackgroundImage ([NullAllowed] UIImage backgroundImage, UIToolbarPosition position, UIBarMetrics barMetrics);

    [Since (5,0)]
    [Export ("backgroundImageForToolbarPosition:barMetrics:")]
    [Appearance]
    UIImage GetBackgroundImage (UIToolbarPosition position, UIBarMetrics barMetrics);

    ...
}
```

Генератор, вызывается [ `btouch` ](https://github.com/xamarin/xamarin-macios/blob/master/src/btouch.cs) в Xamarin.iOS, принимают этих файлов определений и использует .NET, позволяющих [скомпилировать их во временную сборку](https://github.com/xamarin/xamarin-macios/blob/master/src/btouch.cs#L318). Тем не менее это временная сборка не используется для вызова кода Objective-C. Генератор затем считывает временную сборку и создается код C#, который может использоваться во время выполнения.
Это почему, например, при добавлении случайных атрибут файл CS определение, он не будет отображаться в выходные файлов кода. Генератор не знает о нем и поэтому `btouch` не знает, следует искать его в временную сборку для вывода его.

После создания Xamarin.iOS.dll mtouch будут объединены все компоненты.

На высоком уровне это достигается путем выполнения следующих задач:

-   Создайте структуру пакета приложения.
-   Скопируйте управляемых сборок.
-   Если включен связывания, запустите управляемого компоновщика для оптимизации сборок путем копирования неиспользуемых частей.
-   AOT компиляции.
-   Создание собственного исполняемого файла, который выводит ряд статических библиотек (по одному для каждой сборки), связанных с собственного исполняемого файла, так, что исполняемый файл машинного кода состоит из кода запуска регистратора код (если это статический) и все выходные данные AOT компилятор


Дополнительные сведения о компоновщика и способах ее использования см. [компоновщика](~/ios/deploy-test/linker.md) руководства.

## <a name="summary"></a>Сводка

В этом руководстве рассматривали AOT компиляции приложения Xamarin.iOS и изучать Xamarin.iOS и его связь с Objective-C в глубину.

## <a name="related-links"></a>Связанные ссылки

- [Ограничения](~/ios/internals/limitations.md)
- [Привязка Objective c.](~/cross-platform/macios/binding/overview.md)
- [Селекторы Objective c.](~/ios/internals/objective-c-selectors.md)
- [Тип регистратора](~/ios/internals/registrar.md)
- [Linker](~/ios/deploy-test/linker.md)
