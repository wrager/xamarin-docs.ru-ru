---
title: "Работа с представлением с накоплением"
description: "В этой статье описывается проектирование и работа с представлением с накоплением внутри приложения Xamarin.tvOS."
ms.topic: article
ms.prod: xamarin
ms.assetid: 00B07F85-F30B-4DD4-8664-A61D0A1CDB0E
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/16/2017
ms.openlocfilehash: c40e9291e81770435535de7b0c83d6c865cbed58
ms.sourcegitcommit: 30055c534d9caf5dffcfdeafd6f08e666fb870a8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/09/2018
---
# <a name="working-with-stacked-view"></a>Работа с представлением с накоплением

_В этой статье описывается проектирование и работа с представлением с накоплением внутри приложения Xamarin.tvOS._


Элемент управления View стека (`UIStackView`) использует возможности автоматический макет и размер классы для управления стек представлений, горизонтально или вертикально, который динамически реагирует на изменения содержимого и размера экрана устройства Apple TV.

В зависимости от разработчика определенные свойства, такие как оси, распространение, выравнивание и интервал управляются макет всех представлений прикреплено к представлению стека:

[![](stacked-views-images/stacked01.png "Макет вложенное представление схемы")](stacked-views-images/stacked01.png#lightbox)

При использовании `UIStackView` в приложении Xamarin.tvOS, разработчик может определить либо представлений, либо внутри раскадровки в iOS конструктора или путем добавления и удаления представлений в коде C#.

## <a name="about-stacked-view-controls"></a>Сведения об элементах управления представления с накоплением 

`UIStackView` Разработана как представление контейнера без отрисовки и таким образом, он не рисуется на холст, как и другие подклассы `UIView`. Установка свойств, таких как `BackgroundColor` или переопределение `DrawRect` не будет действовать visual.

Существует несколько свойств, определяющих, как представление стека организует свою коллекцию представлений:

- **Оси** — определяет, если представление стека упорядочивает представлений либо **по горизонтали** или **по вертикали**.
- **Выравнивание** — управляет выравниванием представлений в представление стека.
- **Распределение** — определяет способ изменения размеров представлений в представление стека.
- **Интервал между** — определяет минимальное расстояние между каждой вложенное представление в представление стека.
- **Относительно базовой линии** — Если `true`, вертикальный интервал каждого вложенное представление будет производным от базового плана ее.
- **Макет полей относительного** — помещает представлений относительно стандартного поля.

Обычно для размещения небольшое количество представлений используется представление стека. Более сложные пользовательские интерфейсы могут создаваться путем вложения одно или несколько представлений стека друг в друга.

Дальнейшей выполнить тонкую настройку внешнего вида пользовательских интерфейсов, добавив дополнительные ограничения для представлений (например, для управления высота или ширина). Однако следует соблюдать осторожность не должен включать конфликтующими ограничениями теми, представленный представление стека сам.

<a name="Auto-Layout-and-Size-Classes" />

## <a name="auto-layout-and-size-classes"></a>Автоматический макет и размер-классы

При добавлении в представление стека вложенное представление макета полностью контролируется представление стека с помощью автоматический макет и размер классов позиция и размер представления, упорядоченные по.

Представление стека будет _ПИН-код_ вложенное представление первым и последним в коллекции для **верхней** и **нижней** границ для представлений вертикальный стек или **слева**и **право** границ для горизонтальной представлений стека. Если задать `LayoutMarginsRelativeArrangement` свойства `true`, то представление прикрепляет представлений для соответствующих полей вместо границе.

Вложенное представление использует представление стека `IntrinsicContentSize` свойство при вычислении размера представлений вдоль определенного `Axis` (за исключением `FillEqually Distribution`). `FillEqually Distribution` Размера всех представлений, чтобы они имеют один и тот же размер, тем самым заполнения представление стека вдоль `Axis`.

За исключением элемента `Fill Alignment`, представление стека использует вложенное представление `IntrinsicContentSize` свойства для вычисления размера представления перпендикулярно данного `Axis`. Для `Fill Alignment`, размер всех представлений, чтобы они полностью перпендикулярно представление стека данного `Axis`.

<a name="Positioning-and-Sizing-the-Stack-View" />

## <a name="positioning-and-sizing-the-stack-view"></a>Позиционирование и изменение размеров представление стека

Хотя представление стека имеет полный контроль над макетом любой вложенное представление (зависимости от свойств, таких как `Axis` и `Distribution`), все равно необходимо разместить представление стека (`UIStackView`) в рамках его родительского представления с помощью автоматический макет и размер классов.

Как правило это означает, по крайней мере два края представление стека, чтобы развернуть или свернуть, определяя таким образом его положение закрепления. Без любые дополнительные ограничения представление стека автоматически изменяться уместить все его представлений следующим образом:

* Размер вдоль ее `Axis` будет представлять собой сумму размеров всех вложенное представление, а также все пространство, который был определен между каждой вложенное представление.
* Если `LayoutMarginsRelativeArrangement` свойство `true`, размер стека представления также будет содержать место для поля.
* Размер перпендикулярно `Axis` будет присвоено наибольшее вложенное представление в коллекции.

Кроме того, можно задать ограничения для представление стека **высота** и **ширина**. В этом случае представлений будет располагаться (размер) для заполнения всего пространства, определяется представление стека, что определяется `Distribution` и `Alignment` свойства.

Если `BaselineRelativeArrangement` свойство `true`, представлений будет располагаться в зависимости от базовой первой или последней вложенное представление элемента, вместо использования **верхней**, **нижней** или **Center* -  **Y** позиции. Они вычисляются на содержимое представления стека следующим образом:

* Возвращает вертикальное представление стека первый вложенное представление для первого базового и последнего за последние. Если любой из этих представлений, сами представления стека, то будет использоваться первый или последний базовому плану.
* Горизонтальное представление стека будет использовать его высотой вложенное представление для первой и последней базовой линии. Если высотой представление является также представление стека, он будет использоваться его высотой вложенное представление в качестве базового.

> [!IMPORTANT]
> **Примечание:** выравнивание по базовому плану работает на вложенное представление растяжением или сжатый размер базовых будут вычисляться в неправильной позиции. Выравнивание базового плана, убедитесь, что вложенное представление **высота** соответствует встроенный содержимого представления **высота**.




<a name="Common-Stack-View-Uses" />

## <a name="common-stack-view-uses"></a>Распространенные варианты представление стека

Существует несколько типов макета, которые работают с элементами управления представление стека. В соответствии с Apple Вот несколько наиболее распространенных вариантов.

- **Определить размер вдоль оси** — путем закрепления обоих краев вдоль представление стека `Axis` и один из соседних краев, чтобы установить позицию стека, представление будет увеличиваться на оси в соответствии с интервалом, определяется его представлений.
*  **Определить вложенное представление позиции** — путем закрепления смежные границам представление стека представление родительского представление стека будет увеличиваться в обоих измерений в соответствии с содержащего представлений.
- **Определить размер и положение стека** — путем закрепления всех четырех краев представление стека родительскому представлению, представление стека упорядочивает представлений, зависит от используемого пространства, определенные в представление стека.
*  **Определить размер перпендикулярной осью** — путем закрепления обоих краев перпендикулярно представление стека `Axis` и одним границ вдоль оси, чтобы установить позицию стека, представление будет увеличиваться Перпендикулярные оси в соответствии с интервалом, определяется его представлений.

<a name="Stack-Views-and-Storyboards" />

## <a name="stack-views-and-storyboards"></a>Представления стека и раскадровки

Для работы с представлениями стека в приложении Xamarin.tvOS проще всего добавить их с помощью iOS конструктор пользовательского интерфейса приложения.

# <a name="visual-studio-for-mactabvsmac"></a>[Visual Studio для Mac](#tab/vsmac)

1. В **Pad решения**, дважды щелкните `Main.storyboard` и откройте его для редактирования.
1. Разработка макета на отдельные элементы, которые планируется добавить в представление стека: 

    [![](stacked-views-images/layout01.png "Пример макета элемента")](stacked-views-images/layout01.png#lightbox)
1. Добавьте все необходимые ограничения для элементов, чтобы убедиться, что они правильно масштабируются. Этот шаг важен, если элемент добавляется в представление стека.
1. Внесите необходимое количество копий (четыре в данном случае). 

    [![](stacked-views-images/layout02.png "Необходимое количество копий")](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **элементов** и поместите его в представлении: 

    [![](stacked-views-images/layout03.png "Представление стека")](stacked-views-images/layout03.png#lightbox)
1. Выберите представление стека, в **вкладку графического** из **панель свойств** выберите **заполнения** для **выравнивание**, **заполнения Столь же** для **распространения** и введите `25` для **интервалы**: 

    [![](stacked-views-images/layout04.png "Вкладка мини-приложения")](stacked-views-images/layout04.png#lightbox)
1. Поместите представление стека на экране, где он и добавить ограничения, чтобы сохранить ее в требуемом месте.
1. Выберите отдельные элементы и перетащите их в представление стека: 

    [![](stacked-views-images/layout05.png "Отдельные элементы в представление стека")](stacked-views-images/layout05.png#lightbox)
1. Макет будет изменена, а элементы будут отсортированы в представление стека, исходя из атрибутов, задать выше.
1. Назначьте **имена** в **вкладку графического** из **свойства обозревателя** для работы с элементами управления пользовательского интерфейса в коде C#.
1. Сохраните изменения.

# <a name="visual-studiotabvswin"></a>[Visual Studio](#tab/vswin)

1. В **обозревателе решений**, дважды щелкните `Main.storyboard` и откройте его для редактирования.
1. Разработка макета на отдельные элементы, которые планируется добавить в представление стека: 

    [![](stacked-views-images/layout01.png "Пример макета элемента")](stacked-views-images/layout01.png#lightbox)
1. Добавьте все необходимые ограничения для элементов, чтобы убедиться, что они правильно масштабируются. Этот шаг важен, если элемент добавляется в представление стека.
1. Внесите необходимое количество копий (четыре в данном случае). 

    [![](stacked-views-images/layout02.png "Необходимое количество копий")](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **элементов** и поместите его в представлении: 

    [![](stacked-views-images/layout03-vs.png "Представление стека")](stacked-views-images/layout03-vs.png#lightbox)
1. Выберите представление стека, в **вкладку графического** из **свойства обозревателя** выберите **заполнения** для **выравнивание**, **заполнения Столь же** для **распространения** и введите `25` для **интервалы**: 

    [![](stacked-views-images/layout04-vs.png "Вкладка мини-приложения")](stacked-views-images/layout04-vs.png#lightbox)
1. Поместите представление стека на экране, где он и добавить ограничения, чтобы сохранить ее в требуемом месте.
1. Выберите отдельные элементы и перетащите их в представление стека: 

    [![](stacked-views-images/layout05-vs.png "Отдельные элементы в представление стека")](stacked-views-images/layout05-vs.png#lightbox)
1. Макет будет изменена, а элементы будут отсортированы в представление стека, исходя из атрибутов, задать выше.
1. Назначьте **имена** в **вкладку графического** из **свойства обозревателя** для работы с элементами управления пользовательского интерфейса в коде C#.
1. Сохраните изменения.

-----

> [!IMPORTANT]
> **Примечание:** Примечание: хотя и существует возможность назначить действий, таких как `TouchUpInside` элемент пользовательского интерфейса (например `UIButton`) в конструктор при создании обработчика событий iOS, он не будет вызван так как для Apple TV нет сенсорного экрана или в службу поддержки сенсорного ввода события. Следует всегда использовать значение по умолчанию `Action Type` при создании действий для tvOS элементов пользовательского интерфейса.

Дополнительные сведения о работе с помощью раскадровки см. в разделе нашей [Hello, tvOS краткое руководство по](~/ios/tvos/get-started/hello-tvos.md).

В случае в нашем примере мы предоставляются розетки и действия для элемента управления сегмента и выхода для каждого» проигрывателя карты». В коде мы скрыть и Показать проигрывателя на основе текущего сегмента. Пример:

```csharp
partial void PlayerCountChanged (Foundation.NSObject sender) {

    // Take Action based on the segment
    switch(PlayerCount.SelectedSegment) {
    case 0:
        Player1.Hidden = false;
        Player2.Hidden = true;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 1:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 2:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = true;
        break;
    case 3:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = false;
        break;
    }
}
```

При запуске приложения, четыре элемента равномерно распределяются в нашем представление стека:

[![](stacked-views-images/layout06.png "При запуске приложения, четыре элемента равномерно распределяются в нашем представление стека")](stacked-views-images/layout06.png#lightbox)

Если количество игроков снижается, неиспользуемого представления скрыты и представление стека настройки макета в соответствии с:

[![](stacked-views-images/layout07.png "Если количество игроков снижается, неиспользуемые представления скрыты, и представление стека настройки макета в соответствии с")](stacked-views-images/layout07.png#lightbox)

<a name="Populate-a-Stack-View-from-Code" />

### <a name="populate-a-stack-view-from-code"></a>Заполнить представление стека из кода

Кроме определения полностью содержимое и макет представление стека iOS конструктор можно создать и удалить динамически из кода C#.

Рассмотрим следующий пример, использующий представление стека для обработки «звезды» при проверке (от 1 до 5):

```csharp
public int Rating { get; set;} = 0;
...

partial void IncreaseRating (Foundation.NSObject sender) {

    // Maximum of 5 "stars"
    if (++Rating > 5 ) {
        // Abort
        Rating = 5;
        return;
    }

    // Create new rating icon and add it to stack
    var icon = new UIImageView (new UIImage("icon.png"));
    icon.ContentMode = UIViewContentMode.ScaleAspectFit;
    RatingView.AddArrangedSubview(icon);

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });

}

partial void DecreaseRating (Foundation.NSObject sender) {

    // Minimum of zero "stars"
    if (--Rating < 0) {
        // Abort
        Rating =0;
        return;
    }

    // Get the last subview added
    var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];

    // Remove from stack and screen
    RatingView.RemoveArrangedSubview(icon);
    icon.RemoveFromSuperview();

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });
}
```

Давайте подробно рассмотрим несколько фрагментов кода. Во-первых, мы используем `if` инструкции, чтобы проверить, что не более пяти «звезды» или меньше нуля.

Добавление нового «звезда» мы загрузить его изображение и задать его **режиме содержимого** для **размеру аспект шкалы**:

```csharp
var icon = new UIImageView (new UIImage("icon.png"));
icon.ContentMode = UIViewContentMode.ScaleAspectFit;
```

Это предотвращает значок «звезда» искажен при ее добавлении в представление стека.

Далее добавим новый значок «звезда» представление стека коллекцию представлений:

```csharp
RatingView.AddArrangedSubview(icon);
```

Вы заметите, что мы добавили `UIImageView` для `UIStackView` `ArrangedSubviews` свойство и не `SubView`. Любое представление, нужно добавить представление стека для управления его макет должен быть добавлен `ArrangedSubviews` свойство.

Сначала удалить вложенное представление из представления в виде стека, мы получаем вложенное представление для удаления:

```csharp
var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];
```

Затем необходимо удалить его из обоих `ArrangedSubviews` сбор и просмотр Super:

```csharp
// Remove from stack and screen
RatingView.RemoveArrangedSubview(icon);
icon.RemoveFromSuperview();
```

Удаление вложенное представление с только что `ArrangedSubviews` коллекции принимает его в систему управления представление стека, но не удалить с экрана.

<a name="Dynamically-Changing-Content" />

## <a name="dynamically-changing-content"></a>Динамическое изменение содержимого

Представление стека автоматически изменяется макет представлений всякий раз, когда вложенное представление добавлены, удалены или скрыты. Макет будет впоследствии также скорректирована если корректируется представление стека любого свойства (такие как его `Axis`).

Изменения макета могут быть анимированы, поместив их в блок анимации, например:

```csharp
// Animate stack
UIView.Animate(0.25, ()=>{
    // Adjust stack view
    RatingView.LayoutIfNeeded();
});
```

Многие свойства представление стека указываются с помощью классов размер в раскадровку. Эти свойства будут автоматически анимации — ответ на изменения размерами или ориентацией.

<a name="Summary" />

## <a name="summary"></a>Сводка

В этой статье был проиллюстрирован разработки и работы с представлением с накоплением внутри приложения Xamarin.tvOS.



## <a name="related-links"></a>Связанные ссылки

- [Примеры tvOS](https://developer.xamarin.com/samples/tvos/all/)
- [tvOS](https://developer.apple.com/tvos/)
- [tvOS человека направляющие интерфейса](https://developer.apple.com/tvos/human-interface-guidelines/)
- [Приложение руководство по программированию для tvOS](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/)
