---
title: "Транзакции и проверки"
ms.topic: article
ms.prod: xamarin
ms.assetid: 84EDD2B9-3FAA-B3C7-F5E8-C1E5645B7C77
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/18/2017
ms.openlocfilehash: 332ce13b08f3d021553be5747b21b05d62aba6ea
ms.sourcegitcommit: 6cd40d190abe38edd50fc74331be15324a845a28
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/27/2018
---
# <a name="transactions-and-verification"></a>Транзакции и проверки

## <a name="restoring-past-transactions"></a>Восстановление предыдущих транзакций

Если приложение поддерживает типы продуктов, которые могут быть восстановлены, необходимо включить некоторые элементы пользовательского интерфейса, чтобы пользователи могли восстановить эти покупки.
Эта функция позволяет клиенту продукта Добавление дополнительных устройств или восстановление продукта для одного устройства после стирание памяти очистки или удаления и переустановки приложения. Ниже приведены следующие типы продукта могут быть восстановлены.

-  Продукты не потребляемых
-  Автоматически обновляемый подписок
-  Бесплатная подписка


Процесс восстановления должен обновить записи сохранить на устройстве для удовлетворения ваших продуктов. Клиента можно восстанавливать в любое время на всех устройствах. Процесс восстановления повторно отправляет все предыдущие транзакции для этого пользователя. код приложения затем необходимо определить, какое действие необходимо выполнить с этой информацией (например, проверку Если уже существует запись эту покупку на устройстве, а если нет, создается запись покупки и включение продукта для пользователя).

### <a name="implementing-restore"></a>Реализация восстановления

Пользовательский интерфейс **восстановить** кнопка вызывает следующий метод, который запускает RestoreCompletedTransactions `SKPaymentQueue`.

```csharp
public void Restore()
{
   // theObserver will be notified of when the restored transactions start arriving <- AppStore
   SKPaymentQueue.DefaultQueue.RestoreCompletedTransactions();
}
```

StoreKit отправит запрос на восстановление серверы Apple асинхронно.   
   
   
   
 Поскольку `CustomPaymentObserver` регистрируется как наблюдателя транзакции, он будет получать сообщения при Apple серверы отвечают. Ответ будет содержать все транзакции, которые когда-либо выполняли этого пользователя в этом приложении (на всех своих устройствах). Этот код обрабатывает в цикле каждая транзакция обнаруживает состояние восстановленные и вызовы `UpdatedTransactions` метод для его обработки, как показано ниже:

```csharp
// called when the transaction status is updated
public override void UpdatedTransactions (SKPaymentQueue queue, SKPaymentTransaction[] transactions)
{
   foreach (SKPaymentTransaction transaction in transactions)
   {
       switch (transaction.TransactionState)
       {
       case SKPaymentTransactionState.Purchased:
          theManager.CompleteTransaction(transaction);
           break;
       case SKPaymentTransactionState.Failed:
          theManager.FailedTransaction(transaction);
           break;
       case SKPaymentTransactionState.Restored:
           theManager.RestoreTransaction(transaction);
           break;
default:
           break;
       }
   }
}
```

Если нет ни одного продукта могут быть восстановлены для пользователя, `UpdatedTransactions` не вызывается.   
   
   
   
 Те же действия, как при покупки выполняется, за исключением того, что делает простой возможных код для восстановления данной транзакции в образце `OriginalTransaction` свойство используется для доступа к идентификатор продукта:

```csharp
public void RestoreTransaction (SKPaymentTransaction transaction)
{
   // Restored Transactions always have an 'original transaction' attached
   var productId = transaction.OriginalTransaction.Payment.ProductIdentifier;
   // Register the purchase, so it is remembered for next time
   PhotoFilterManager.Purchase(productId); // it's as though it was purchased again
   FinishTransaction(transaction, true);
}
```

Более сложные реализации могут проверить другие `transaction.OriginalTransaction` свойства, такие как исходный номер даты и приемки. Эти сведения будут полезны для некоторых типов продукта (например, подписки).

#### <a name="restore-completion"></a>Завершение восстановления

`CustomPaymentObserver` Имеет две дополнительные методы, которые будут вызываться StoreKit после завершения процесса восстановления (успешно или с ошибкой), показано ниже:

```csharp
public override void PaymentQueueRestoreCompletedTransactionsFinished (SKPaymentQueue queue)
{
   Console.WriteLine(" ** RESTORE Finished ");
}
public override void RestoreCompletedTransactionsFailedWithError (SKPaymentQueue queue, NSError error)
{
   Console.WriteLine(" ** RESTORE FailedWithError " + error.LocalizedDescription);
}
```

В примере эти методы ничего не делать, однако в реальном приложении, можно реализовать сообщения пользователю или другие функциональные возможности.

## <a name="securing-purchases"></a>Обеспечение безопасности покупки

Два примера в этом документе используйте `NSUserDefaults` для отслеживания покупок:   
   
 **Материалы** — «баланс» кредит покупки — это простой `NSUserDefaults` целочисленное значение, которое увеличивается с каждой покупкой.   
   
 **Отличные материалы** — каждой покупкой фото фильтра сохраняется как пару "ключ значение" в `NSUserDefaults`.

С помощью `NSUserDefaults` сохраняют простой пример кода, но не предлагают решения высокий уровень безопасности, как она может быть технически minded пользователям возможность обновить параметры (обход механизма оплаты).   
   
Примечание: В реальных приложениях необходимо принимать безопасного механизма для хранения приобретенных содержимое, которое не подлежит подмены пользователя. Для этого может потребоваться шифрования и/или других методов, включая проверку подлинности с удаленным сервером.   
   
 Механизм также должны разрабатываться с преимуществами встроенных возможностей резервного копирования и восстановления операций ввода-вывода, iTunes и iCloud. Это обеспечит, после пользователь восстанавливает резервную копию предыдущего покупателям сразу станет доступен.   
   
   
 Найти Apple безопасного кодирования руководстве Дополнительные рекомендации по выбору конкретных операций ввода-вывода.

## <a name="receipt-verification-and-server-delivered-products"></a>Проверка поступления и предоставление сервером продуктов

Примеры в этом документе, в данный момент включал исключительно взаимодействовать непосредственно с серверами App Store приложение для проведения транзакции покупки, разблокировать функции и возможности, которые уже в коде в приложение.   
   
   
   
 Apple предоставляет для дополнительного уровня безопасности покупки, позволяя покупки должна выполняться проверка независимо друг от друга другой сервер, который можно использовать для проверки запроса перед доставкой цифрового содержимого как часть заказа на покупку (таких как цифровые книги или журнал).   
   
   
   
 **Встроенной продуктами** — как в примерах в этом документе приобретенный товар существует как функциональные возможности, поставляемых вместе с приложением. Покупка из приложения позволяет пользователю доступ к функциям.
Идентификатор продукта жестко запрограммированы.   
   
 **Предоставление сервером продуктов** – продукт состоит из загружаемое содержимое, хранящиеся на удаленном сервере, пока не будет успешно транзакция вызывает загрузку содержимого.
Примеры могут включать книг или проблем с журналом. Идентификатор продукта обычно получают данные из внешнего сервера (где продукта также размещается содержимое). Приложения должны реализовывать надежным способом записи после завершения транзакции, если происходит сбой загрузки содержимого может быть повторена без запутать пользователя.

### <a name="server-delivered-products"></a>Предоставление сервером продуктов

Некоторые продукта содержимого, такие как книги и журналы (или даже уровне игр) необходимо загрузить в процессе покупки с удаленного сервера. Это означает, что требуется для хранения и предоставления содержимого продукта после приобретения дополнительного сервера.

#### <a name="getting-prices-for-server-delivered-products"></a>Получение цены для сервера доставить продукты

Поскольку удаленно доставляются продукты, можно также добавлять дополнительные продукты со временем (без изменения кода приложения), такие как добавление дополнительные книги или новых проблем журнала. Чтобы приложение может обнаруживать такие продукты новости и отобразить их для пользователя, дополнительного сервера следует хранить и предоставления этих сведений.   
   
   
   
 [ ![](transactions-and-verification-images/image38.png "Получение цены для сервера доставить продукты")](transactions-and-verification-images/image38.png)   
   
   
   
 1. Сведения о продукте, которые должны храниться в нескольких местах: на сервере и в iTunes Connect. Кроме того каждый продукт будет иметь файлы содержимого, связанные с ним. Эти файлы будут доставлены после успешного покупки.   
   
 2. Когда пользователь хочет купят товар, приложение должно определить, какие продукты. Эти сведения могут кэшироваться, но должно быть доставлено с удаленного сервера, где хранится список продуктов.   
   
 3. Сервер возвращает список идентификаторов продуктов для приложения для синтаксического анализа.   
   
 4. Затем приложение определяет, какие из этих кодов продуктов для отправки и получения цены и описания StoreKit.   
   
 5. StoreKit отправляет список идентификаторов продукта на серверах компании Apple.   
   
 6. Серверы iTunes возвращать сведения продукта (описание и текущая цена).   
   
 7. Приложения `SKProductsRequestDelegate` передается информация для отображения для пользователя.

#### <a name="purchasing-server-delivered-products"></a>Приобретение сервера доставить продукты

Так как удаленный сервер требует какой-либо способ проверки, что запрос на содержимое является допустимым (т. е. выплаты для), о прочтении передается для проверки подлинности. Удаленный сервер пересылает данные iTunes для проверки и в случае успешного выполнения включает содержимое продукта в ответ на приложение.   
   
 [ ![](transactions-and-verification-images/image39.png "Приобретение сервера доставить продукты")](transactions-and-verification-images/image39.png)   
   
 1. Добавляет приложение `SKPayment` в очередь. При необходимости пользователь будет запрашиваться их идентификатора Apple ID и запрос на подтверждение платеж.   
   
 2. StoreKit отправляет запрос на сервер для обработки.   
   
 3. После завершения транзакции сервер в ответ отправляет уведомление о транзакции.   
   
 4. `SKPaymentTransactionObserver` Подкласс получению получает и обрабатывает его. Поскольку продукта необходимо загрузить с сервера, приложение инициирует сетевой запрос к удаленному серверу.   
   
 5. Запрос на загрузку сопровождается поступления данных, чтобы удаленный сервер можно проверить, что он имеет права доступа к содержимому. Приложения сетевой клиент ожидает ответа на запрос.   
   
 6. Когда сервер получает запрос на содержимое, он анализирует данные приемки и отправляет запрос непосредственно к серверам iTunes для проверки поступления относится допустимой транзакции. Сервер должен использовать логику для определения, следует ли отправлять запрос в производственной или "песочницы" URL-адрес. Apple предлагает всегда с помощью URL-адреса производственной и переключение "песочницы", если состояние: посвящены 21007 (производственный сервер отправляется "песочницы" поступление) — [технические 2259 Примечание 16 часто задаваемые вопросы о](https://developer.apple.com/library/ios/#technotes/tn2259/_index.html).   
   
 7. выполняется проверка получению iTunes и вернуть состояние 0, если он допустим.   
   
 8. Сервер ожидает ответа iTunes. При получении допустимого ответа, код должен найдите файл содержимого связанных продуктов для включения в ответ на приложение.   
   
 9. Приложение получает и анализирует ответ сохранения содержимого продукта файловой системе устройства.   
   
 10. Приложение включает продукта, а затем вызывает его StoreKit `FinishTransaction`. Приложение может при необходимости отображать Приобретенное содержимое (например, Показать первой страницы приобретенных книги или журнала проблема).

Альтернативной реализации для продукта, очень больших файлов содержимого может входить: просто хранения получению транзакции на шаге 9, #, чтобы быстро завершать транзакцию и предоставление пользовательского интерфейса для пользователя, для загрузки содержимого программных продуктов в дальнейшем. Запрос последующие загрузки можно повторно отправить хранимых получению доступа к файлу содержимого продукта.

### <a name="writing-server-side-receipt-verification-code"></a>Написание кода проверки поступления на стороне сервера

Проверка поступления в код на стороне сервера можно сделать с помощью простого HTTP POST запрос ответ, охватывающем шаги #5-#8 на схеме рабочего процесса.   
   
   
   
 Извлечение `SKPaymentTansaction.TransactionReceipt` свойства в приложении. Это данные, которые требуется отправить в iTunes для проверки (шаг #5).

Кодирование base64 поступления данных транзакции (либо на шаге #5 или #6).

Создание простого полезные данные JSON следующим образом:

```csharp
{
   "receipt-data" : "(base-64 encoded receipt here)"
}
```

HTTP POST JSON для [https://buy.itunes.apple.com/verifyReceipt](https://buy.itunes.apple.com/verifyReceipt) для производства или [https://sandbox.itunes.apple.com/verifyReceipt](https://sandbox.itunes.apple.com/verifyReceipt) для тестирования.   
   
 Ответ JSON содержит следующие разделы:

```csharp
{
   "status" : 0,
   "receipt" : { (receipt repeated here) }
}
```

Состояние 0 указывает допустимый поступления. Сервер можно перейти для удовлетворения содержимое приобретаемой продукции. Ключ подтверждения содержит словаря JSON с теми же свойствами, что `SKPaymentTransaction` объекта, который был получен приложением, поэтому код сервера может запросить этот словарь для получения сведений об Идентификатор_продукта и количество покупки.

. В разделе Apple [Проверка поступления хранилища](https://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/StoreKitGuide/VerifyingStoreReceipts/VerifyingStoreReceipts.html#//apple_ref/doc/uid/TP40008267-CH104-SW1) документации для получения дополнительных сведений.

#### <a name="using-aspnet"></a>С помощью ASP.NET

Для разработчиков C# является полезным открытая проект с именем [APNS Sharp](https://github.com/Redth/APNS-Sharp) включающее получение проверки кода, который работает в ASP.NET. В частности `Receipt.cs` и `ReceiptVerification.cs` файлы в [ `Jdsoft.Apple.AppStore` ](https://github.com/Redth/APNS-Sharp/tree/master/JdSoft.Apple.AppStore) каталога можно добавить на веб-сайте .NET могут легко реализовать действия #6-#8 из схемы продуктов Server-Delivered рабочего процесса.   
   
   
   
 Связь с серверами iTunes с помощью JSON, который легко обрабатывать на языке C#.   
   
   
   
 Ссылаться на покупку из приложения Apple [проверки поступления](https://developer.apple.com/library/ios/#releasenotes/StoreKit/IAP_ReceiptValidation/_index.html) документации подробные сведения о том, как проверить правильность уведомление.

### <a name="3rd-party-receipt-verification"></a>3-й проверки поступления стороннего производителя

Существует компании, предлагающие платформы для проверки поступления (и прочего), которые можно использовать вместо создания собственного сервера. Xamarin не имеет отношения к эти службы; они вы просто указанные здесь для справки.

#### <a name="urban-airship"></a>Городской Airship

Городской Airship предоставляет ряд различных внутренних служб для приложений iOS, включая подтверждения проверки и принудительной уведомлений.   
   
 [http://urbanairship.com/products/in-app-purchase/](http://urbanairship.com/products/in-app-purchase/)



